<!DOCTYPE html>
<html><head>
<meta charset="UTF-8"/> 
<title>AugmentedBalls</title>
<meta license="AugmentedBalls2 and Wikibinator203 license: The whole turing-complete and hypercomputing space derived from
this universal combinator/lambda or forks of it and other software (prototype by Ben F Rayfield Y2023),
including every lambda of this kind called on a lambda to find/create a lambda or which never halts
(which the author of is defined as the universal combinator since these are tiny shared math objects),
is offered to everyone under opensource GNU AGPL 3 license, plus these extra permissions:
* Classpath/linking exception. Hook it to whatever you want, but within the space (no proprietary lambdas) is AGPL.
* License is instantly unterminated when you start obeying it.
* Free speech absolutism in the evilbit=true namespace in which all possible lambdas are allowed, even viruses etc.
GNU AFFERO GENERAL PUBLIC LICENSE Version 3, 19 November 2007 ..."/>
<script>


/*
Not used in this software but maybe later explore this...
Equation gives number of subset-sum solutions (NP math) for 5 integers, for example
var subsetSumCount = (b, t, x1, x2, x3, x4, x5)=>{
	let B = 2**b;
	let a = (1+B**x1)*(1+B**x2)*(1+B**x3)*(1+B**x4)*(1+B**x5);
	let b1 = a % (B**t);
	let d = (a - b1) % (B**(t+1));
	return d/(B**t);
};
*/



	
/*
//an example of the datastruct that evolution and graphics transforms etc will use for input and output, going forward, TODO...
var exampleData = {
	w: 160,
	h: 120,
	bytes: [], //each size h*w*4
	floats: [], //each size h*w
	colorMatchExponent: 2,
	FIXMEFIXME balls datastruct, PotenTest datastruct, MultiPotenTest datastruct, and how do u put a func in here (code string with cached eval of it?)
};

var exampleData2 = ["(x,y,z)=>{return 0;}" TODO i want all the image transforms done as something lambdalike but allow {} and 2.34 and Float32Array and Uint8Array too.
They can call outside funcs, but i want to at least store funcs as data.
Do I need funcallCaching? When is cache cleared?
];
*/



//Not a full wikibinator, but make a simple lambda system so i can easier do functional programming in AugmentedBalls...

//FIXME maybe should remove this. im adding it just for an alternative of avm.Func.toString that outputs js code of itself. Do this only if avm.namesGoInVMap.
var V = {};







/*TODO
Get rid of avm.swapVX. Only have V, not X.
Change .nam from string to list of string, for duplicate names. Maybe have globalId be among them, or maybe a separate field. Put them all together?
Before importing any code, mod all its names so theres no overlap. Do this at string level.
If using existing fns in browser console, thats ok to keep their names as they are.
To choose which name to keep, use the shorter one, and prefer those that start with capital letter.
Add names while stuff is being imported, push the names onto the .nam list of string names if its not already there (indexOf).
Then drop all names except the first in each list and the globalId.
Also i want a bit field that says its the normed/deduped form or not. There can be at most 1 of those per unique node forest/data.
..
//TODO replace this.nam with this.nams list. For each of these nameX, V.nameX===this.
//All of these except 1 can be made up names, but that 1 (if its here at all) is globalId and exact dedups this forest shape/data.
this.nams = [];
*/
for(let i=0; i<20; i++) console.log('TODO .nam becomes list of names, for merging and dedup, including globalId. '+Math.random());






/*//for avm.Func.nam2 or maybe call it namx. This is for merging multiple code strings with V.varname,
//but instead V and X are swapped before evaling the incoming code, then swap again, then merge all the X names into V.
//use avm.swapVX() before, then eval it (such as on browser console just paste code in and run it),
//then avm.swapVX(), then avm.mergeVX(). Careful not to use V (stored in X, and X has V's val) during that.
var X = {};
*/

const A = (()=>{
	let avm = {


		//AugmentedBalls VM, that makes a simple kind of combinator work.
		cacheEval_: {},

		strictNameNonNullTests: false,
		//strictNameNonNullTests: true,

		throwIfChangeName: false,
		//throwIfChangeName: true,

		logLambdizedToStringDetails: false,
		//logLambdizedToStringDetails: true,

		logSettingName: false,
		//logSettingName: true,

		logNameAlreadyExistsSoNotChangingIt: false,
		//logNameAlreadyExistsSoNotChangingIt: false,

		//lambdaToStringReturnsJsSyntax: false, //(a b thingX#(c d e) f thingX 'hello')
		lambdaToStringReturnsJsSyntax: true, //a(b)(V.thingX=c(d)(e))(f)(V.thingX)('hello')

		//namesGoInVMap: false,
		namesGoInVMap: true, //V.thingX=c(d)(e)	

		logProxyGet: false,
		//logProxyGet: true,
		

		//wrapJsLambdasInProxy: false, //aLambda.n.fieldName
		wrapJsLambdasInProxy: true, //aLambda.fieldName. Also the .p function gets any field it doesnt have.

		logReturningFromCache: false,
		//logReturningFromCache: true,

		logDetailedParamsAtEveryCall: false,
		//logDetailedParamsAtEveryCall: true,

		logCurAndCurriesSoFarWhenCreateFunc: false,
		//logCurAndCurriesSoFarWhenCreateFunc: true,

		
		//putEvaledJsCodeInBrowserDebugger: false,
		putEvaledJsCodeInBrowserDebugger: true,

		logCp: false,
		//logCp: true,

		logRet: false,
		//logRet: true,

		//logIdentityFuncToStringUglyHackToAvoidInfiniteLoop: false,
		logIdentityFuncToStringUglyHackToAvoidInfiniteLoop: true,

		cacheEval: function(jsCode){
			//Example: cacheEval('(x,y)=>(x+y*y+3)')(10,20) returns 503, and if u call it again, it return faster cuz only compiles '(x,y)=>(x+y*y+3)' the first time.
			let ret = avm.cacheEval_[jsCode];
			if(ret === undefined){
				console.log('avm.cacheEval evaling jsCode=\n'+jsCode)
				ret = avm.cacheEval_[jsCode] = eval(jsCode);
			}
			return ret;
		},

		clearAllCacheEval: function(){
			avm.cacheEval_ = {};
		},

		nameCounter: 0,

		quoteString: str=>{
			return '"'+str.replace(/\\/g,'\\\\').replace(/"/g,'\\"').replace(/\n/g,'\\n')+'"'; //FIXME other escapes
		},

		prototypeOfSimpleJsMap: Object.getPrototypeOf({}),

		prototypeOfSimpleJsList: Object.getPrototypeOf([]),

		prototypeOfUint8Array: Object.getPrototypeOf(Uint8Array.of(1)),
		prototypeOfUint8ClampedArray: Object.getPrototypeOf(Uint8ClampedArray.of(1)),
		prototypeOfFloat32Array: Object.getPrototypeOf(Float32Array.of(1)),
		prototypeOfFloat64Array: Object.getPrototypeOf(Float64Array.of(1)),
		prototypeOfInt32Array: Object.getPrototypeOf(Int32Array.of(1)),
		prototypeOfUint32Array: Object.getPrototypeOf(Uint32Array.of(1)),

		//for testing. Pair(S)(T).id() aka the iota combinator.
		idOfPairST: 'AVMe7bc8ea96c512c442f09e6256b663e0dff2f4314b5bdb2ad6030a7dd45f1edb9',
		fullIdOfPairST: 'AVMe7bc8ea96c512c442f09e6256b663e0dff2f4314b5bdb2ad6030a7dd45f1edb9_3296fa189e2888a98e449b7f6ffeddfb5ff50ede11e168f6a8a07b6affdbb6f3ef63565a647d08200002680782484ffc861acf09106222567de144106df88fda64',



		//returns true (bigEndian) or false (littleEndian) or throws if overlapping Uint8Array and Float64Array dont store pi correctly either way.
		isBigEndian: ()=>{
			let bytes = new Uint8Array(8);
			//java at https://www.tutorialspoint.com/compile_java_online.php
			//says Long.toHexString(Double.doubleToLongBits(5 FIXME THIS COMMENT IS OLD)) is 400921fb54442d18L, and thats a bigEndian tostring of the long (regardless of how it is in memory).
			bytes[0] = 0x40;
			bytes[1] = 0x09;
			bytes[2] = 0x21;
			bytes[3] = 0xfb;
			bytes[4] = 0x54;
			bytes[5] = 0x44;
			bytes[6] = 0x2d;
			bytes[7] = 0x18;
			let doubles = new Float64Array(bytes.buffer);
			if(doubles[0] == Math.PI) return true; //bigEndian
			bytes[7] = 0x40;
			bytes[6] = 0x09;
			bytes[5] = 0x21;
			bytes[4] = 0xfb;
			bytes[3] = 0x54;
			bytes[2] = 0x44;
			bytes[1] = 0x2d;
			bytes[0] = 0x18;
			if(doubles[0] == Math.PI) return false; //littleEndian
			throw 'Is not bigEndian or littleEndian as tested by overlapping Uint8Array and Float64Array on pi';
		},

		testEndian: ()=>{
			if(avm.isBigEndian()){
				throw 'Avm detected bigEndian, but that is not supported in this VM. If you need that, it could be redesigned to support both but slower as it would have to auto adjust array indexs.';
			}else{
				console.log('Avm VM detected littleEndian and will use that for overlapping .buffer in Uint8Array, Int32Array, Float32Array, Float64Array, etc. Despite that bigEndian is how people usually write things, most hardware seems to be littleEndian.');
			}
		},

		testEndianOnce: function(){
			if(!avm.testEndianOnce_){
				avm.testEndian();
				testEndianOnce_ = true;
			}
		},

		bytesToHex: bytes=>{
			let s = '';
			for(let i=0; i<bytes.length; i++) s += avm.doubleHexDigits[bytes[i]];
			return s;
		},

		utf8TextEncoder: new TextEncoder('utf-8'),
	
		utf8TextDecoder: new TextDecoder('utf-8'),
	
		strToBytes: function(s){
			return avm.utf8TextEncoder.encode(s);
		},
		
		bytesToStr: function(bytes){
			return avm.utf8TextDecoder.decode(bytes);
		},

		hexToBytes: hex=>{
			if(hex.length&1){ //odd
				throw 'Cant be odd: hex.length='+hex.length;
			}
			let ret = new Uint8Array(hex.length/2);
			for(let i=0; i<ret.length; i++){
				ret[i] = avm.mapOfDoubleHexDigitsToInt[hex.substring(i*2,i*2+2)];
			}
			return ret;
		},
		
		bytesAndRangeToHex: (bytes,from,toExcl)=>{
			let s = '';
			for(let i=from; i<toExcl; i++) s += vm.doubleHexDigits[bytes[i]];
			return s;
		},

		hexDigits: '0123456789abcdef',
		
		mapOfHexDigitToInt: {}, //vals are 0 to 15
		mapOfDoubleHexDigitsToInt: {}, //vals are 0 to 255

		//256 pairs of hex digits
		doubleHexDigits: [],
		/*Moving this to outside... for(let i=0; i<16; i++){
			vm.mapOfHexDigitToInt[vm.hexDigits[i]] = i;
			for(let j=0; j<16; j++){
				let hh = vm.hexDigits[i]+vm.hexDigits[j];
				vm.doubleHexDigits.push(hh);
				vm.mapOfDoubleHexDigitsToInt[hh] = ((i<<4)|j);
			}
		}*/

		//returns 8 hex digits including any leading zeros.
		intToHex: function(i){ return avm.doubleHexDigits[(i>>24)&0xff]+avm.doubleHexDigits[(i>>16)&0xff]+avm.doubleHexDigits[(i>>8)&0xff]+avm.doubleHexDigits[i&0xff]; },

		//FIXME should globalId be stored in Uint8Array(32) in func.idBytes or string of prefix+hexOfThat in func.nams list or both?
		//need to do the recursion next.

		globalIdPrefix: 'AVM',
		tempNamePrefix: 'TEMP', //during merge, prefix all ids by this, except if it starts with avm.globalIdPrefix

		globalIdStrToBytes: globalIdStr=>avm.hexToBytes(globalIdStr.substring(avm.globalIdPrefix.length)),
		
		//FIXMEFIXME
		callPairToContentToHash: function(idA, idB){
			let a = idA;
			let b = idB;
			if(typeof(a) == 'string') a = avm.globalIdStrToBytes(a); //TODO cache this in avm.Func
			if(typeof(b) == 'string') b = avm.globalIdStrToBytes(b); //TODO cache this in avm.Func
			if(!(a instanceof Uint8Array) || a.length != 32) throw 'idA is not 32 bytes: '+a;
			if(!(b instanceof Uint8Array) || b.length != 32) throw 'idB is not 32 bytes: '+b;

			

			let ret = new Uint8Array(65);
			ret[0] = '2'.charCodeAt(0); //'2' means callpair.
			for(let i=0; i<32; i++){
				ret[1+i] = a[i];
				
			}
			for(let i=0; i<32; i++){
				ret[33+i] = b[i];
			}
			return ret;
		},

		emptyLeafContentToHash: Uint8Array.of('A'.charCodeAt(0)),

		doubleToBytes: d=>{
			avm.testEndianOnce();
			return new Uint8Array(Float64Array.of(d).buffer);
		},

		nodeDataToContentToHash: function(d){
			if(d == null || d === undefined) throw 'Is null or undefined';
			let ty = typeof(d);
			if(ty == 'string'){
				return avm.primitiveArrayToContentToHash(avm.strToBytes(d), 'S');
			}else if(ty == 'number'){
				return avm.primitiveArrayToContentToHash(avm.doubleToBytes(d), 'd');
			}else{
				return avm.primitiveArrayToContentToHash(d);
			}
		},

		
		//Prefix it by 1 byte for type: B for Uint8Array, I for Int32Array, F for Float32Array, D for Float64Array.
		//Non-primitiveArray stuff: S for string, and d for 1 double/number. 2 for call pair.
		primitiveArrayToContentToHash: function(arr, optionalForceFirstChar){
			avm.testEndianOnce();
			let byteView = new Uint8Array(arr.buffer);
			//FIXME norm float or double, if its that kind of array. dont have multiple kinds of NaN, Infinity, -Infinity, etc. Allow subnormals as long as its deterministic.
			let ret = new Uint8Array(1+byteView.length);
			let firstChar = optionalForceFirstChar;
			if(!firstChar){
				if(arr instanceof Uint8Array){
					firstChar = 'B';
				//}else if(arr instanceof UintClamped8Array){
				//	firstChar = 'C';
				}else if(arr instanceof Int32Array){
					firstChar = 'I';
				}else if(arr instanceof Float32Array){
					firstChar = 'F';
				}else if(arr instanceof Float64Array){
					firstChar = 'D';
				}else{
					throw 'Unknown type of this array: '+arr;
				}
			}
			let firstByte = firstChar.charCodeAt(0);
			console.log('firstChar='+firstChar+' firstByte='+firstByte);
			ret[0] = firstByte;
			for(let i=0; i<byteView.length; i++){ //TODO optimize by using some copy func from bytes range to bytes range
				ret[i+1] = byteView[i];
			}
			return ret;
		},
		//FIXME use a http data format with the 2 empty lines??

		//TODO? should there be a way to put optional names in the hashes? if so,
		//that should be a different datastruct than the main forest, something that points at the main forest, but the main forest doesnt point at it.



		//TODO should it do binary for big arrays, or convert them to text first?
		globalIdMakerA: function(stringIn){
			throw 'FIXMEFIXME';
		},

		//string in, hex string out
		sha256Utf8StringInHexOut: function(stringIn){
			throw 'FIXMEFIXME';
		},

		//returns a mutable Uint8Array(32).
		//Uint8Array(any size) in. Uint8Array(32) out.
		//WARNING, TODO CHECK SECURITY OF SHA3_256: checkIfSha3PermutationStepIsUnitaryAndIfItsNotThenCheckThatItExpandsItFirstInWayThatsSecureAgainstCreatingCollisionsInTheFirstNonunitarySoCalledPermutation
		//	But the main reason using sha256 instead of sha3_256 is sha256 is faster in CPU (and faster than that in GPU, todo find it i wrote that code using lazycl somewhere, was around 50 gflops i think) even though SHA3_256 is designed to be even faster in GPU (todo verify).
		sha256: function(bytesIn, optionalParam_skipPadding){
			//https://raw.githubusercontent.com/benrayfield/jsutils/master/src/sha256.js slightly modified by adding optionalParam_skipPadding param

			//var t = typeof bytesIn;
			//if(t != 'Uint8Array') throw 'Expected Uint8Array but got a '+t; //this check wont work because its like a map of index to byte
			
			var chunks = Math.floor((bytesIn.byteLength+(optionalParam_skipPadding?0:9)+63)/64); //512 bit each
			
			//Copy bytesIn[] into b[], then pad bit1, then pad bit0s,
			//then append int64 bit length, finishing the last block of 512 bits.
			//byte b[] = new byte[chunks*64];
			var b = new Uint8Array(chunks*64);
			
			//System.arraycopy(bytesIn, 0, b, 0, bytesIn.byteLength);
			b.set(bytesIn, 0);
			
			if(!optionalParam_skipPadding){
				b[bytesIn.byteLength] = 0x80;
			
				//long bitLenTemp = bytesIn.byteLength*8;
				var bitLenTemp = bytesIn.byteLength*8; //in js, this has float64 precision, which is more than enough for Uint8Array size
				for(var i=7; i>=0; i--){
					b[b.byteLength-8+i] = bitLenTemp&0xff;
					bitLenTemp >>>= 8;
				}
			}
			
			//log('b as hex = '+bitfuncs.uint8ArrayToHex(b));
			
			
			var a = new Uint32Array(136);
			//"first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311"
			a[0]=0x428a2f98;
			a[1]=0x71374491;
			a[2]=0xb5c0fbcf;
			a[3]=0xe9b5dba5;
			a[4]=0x3956c25b;
			a[5]=0x59f111f1;
			a[6]=0x923f82a4;
			a[7]=0xab1c5ed5;
			a[8]=0xd807aa98;
			a[9]=0x12835b01;
			a[10]=0x243185be;
			a[11]=0x550c7dc3;
			a[12]=0x72be5d74;
			a[13]=0x80deb1fe;
			a[14]=0x9bdc06a7;
			a[15]=0xc19bf174;
			a[16]=0xe49b69c1;
			a[17]=0xefbe4786;
			a[18]=0x0fc19dc6;
			a[19]=0x240ca1cc;
			a[20]=0x2de92c6f;
			a[21]=0x4a7484aa;
			a[22]=0x5cb0a9dc;
			a[23]=0x76f988da;
			a[24]=0x983e5152;
			a[25]=0xa831c66d;
			a[26]=0xb00327c8;
			a[27]=0xbf597fc7;
			a[28]=0xc6e00bf3;
			a[29]=0xd5a79147;
			a[30]=0x06ca6351;
			a[31]=0x14292967;
			a[32]=0x27b70a85;
			a[33]=0x2e1b2138;
			a[34]=0x4d2c6dfc;
			a[35]=0x53380d13;
			a[36]=0x650a7354;
			a[37]=0x766a0abb;
			a[38]=0x81c2c92e;
			a[39]=0x92722c85;
			a[40]=0xa2bfe8a1;
			a[41]=0xa81a664b;
			a[42]=0xc24b8b70;
			a[43]=0xc76c51a3;
			a[44]=0xd192e819;
			a[45]=0xd6990624;
			a[46]=0xf40e3585;
			a[47]=0x106aa070;
			a[48]=0x19a4c116;
			a[49]=0x1e376c08;
			a[50]=0x2748774c;
			a[51]=0x34b0bcb5;
			a[52]=0x391c0cb3;
			a[53]=0x4ed8aa4a;
			a[54]=0x5b9cca4f;
			a[55]=0x682e6ff3;
			a[56]=0x748f82ee;
			a[57]=0x78a5636f;
			a[58]=0x84c87814;
			a[59]=0x8cc70208;
			a[60]=0x90befffa;
			a[61]=0xa4506ceb;
			a[62]=0xbef9a3f7;
			a[63]=0xc67178f2;
			//h0-h7 "first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19"
			a[64]=0x6a09e667;
			a[65]=0xbb67ae85;
			a[66]=0x3c6ef372;
			a[67]=0xa54ff53a;
			a[68]=0x510e527f;
			a[69]=0x9b05688c;
			a[70]=0x1f83d9ab;
			a[71]=0x5be0cd19;
			//a[72..135] are the size 64 w array of ints
			for(var chunk=0; chunk<chunks; chunk++){
				var bOffset = chunk<<6;
				//copy chunk into first 16 words w[0..15] of the message schedule array
				for(var i=0; i<16; i++){
					//Get 4 bytes from b[]
					var o = bOffset+(i<<2);
					a[72+i] = ((b[o]&0xff)<<24) | ((b[o+1]&0xff)<<16) | ((b[o+2]&0xff)<<8) | (b[o+3]&0xff);
				}
				//Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array:
				for(var i=16; i<64; i++){
					//s0 := (w[i-15] rightrotate 7) xor (w[i-15] rightrotate 18) xor (w[i-15] rightshift 3)
					//s1 := (w[i-2] rightrotate 17) xor (w[i-2] rightrotate 19) xor (w[i-2] rightshift 10)
					//w[i] := w[i-16] + s0 + w[i-7] + s1
					var wim15 = a[72+i-15];
					var s0 = ((wim15>>>7)|(wim15<<25)) ^ ((wim15>>>18)|(wim15<<14)) ^ (wim15>>>3);
					var wim2 = a[72+i-2];
					var s1 = ((wim2>>>17)|(wim2<<15)) ^ ((wim2>>>19)|(wim2<<13)) ^ (wim2>>>10);
					a[72+i] = a[72+i-16] + s0 + a[72+i-7] + s1;
				}
				var A = a[64];
				var B = a[65];
				var C = a[66];
				var D = a[67];
				var E = a[68];
				var F = a[69];
				var G = a[70];
				var H = a[71];
				for(var i=0; i<64; i++){
					/* S1 := (e rightrotate 6) xor (e rightrotate 11) xor (e rightrotate 25)
					ch := (e and f) xor ((not e) and g)
					temp1 := h + S1 + ch + k[i] + w[i]
					S0 := (a rightrotate 2) xor (a rightrotate 13) xor (a rightrotate 22)
					maj := (a and b) xor (a and c) xor (b and c)
					temp2 := S0 + maj
					h := g
					g := f
					f := e
					e := d + temp1
					d := c
					c := b
					b := a
					a := temp1 + temp2
					*/
					var s1 = ((E>>>6)|(E<<26)) ^ ((E>>>11)|(E<<21)) ^ ((E>>>25)|(E<<7));
					var ch = (E&F) ^ ((~E)&G);
					var temp1 = H + s1 + ch + a[i] + a[72+i];
					var s0 = ((A>>>2)|(A<<30)) ^ ((A>>>13)|(A<<19)) ^ ((A>>>22)|(A<<10));
					var maj = (A&B) ^ (A&C) ^ (B&C);
					var temp2 = s0 + maj;
					H = G;
					G = F;
					F = E;
					E = D + temp1;
					D = C;
					C = B;
					B = A;
					A = temp1 + temp2;
				}
				a[64] += A;
				a[65] += B;
				a[66] += C;
				a[67] += D;
				a[68] += E;
				a[69] += F;
				a[70] += G;
				a[71] += H;
			}
			//RETURN h0..h7 = a[64..71]
			//byte ret[] = new byte[32];
			var ret = new Uint8Array(32);
			for(var i=0; i<8; i++){
				var ah = a[64+i];
				ret[i*4] = (ah>>>24)&0xff;
				ret[i*4+1] = (ah>>>16)&0xff;
				ret[i*4+2] = (ah>>>8)&0xff;
				ret[i*4+3] = ah&0xff;
			}
			return ret;
		},



		formatAvmCode: function(code){
			//FIXME parse it first. tab it over. change strings to `...` and auto convert them to remove tabs so less evals and less generated .js appearing in browser sources tab.
			
			//But for now, do something simpler...
			return code.replaceAll('\\n','\n').replaceAll('"','`');
		},






		
		/*
		countSwapVX: 0,
		
		//has avm.swapVX() been called an even (normal) vs odd (during merge) number of times
		swapVXIsEven: function(){
			return !(avm.countSwapVX&1);
		},
		
		swapVX: function(){
			let temp = V;
			V = X;
			X = temp;
			avm.countSwapVX++;
			console.log('swapVX_'+(avm.swapVXIsEven() ? 'even' : 'odd'));
		},
		
		//fills Func.replacement() if a fn needs replacing.
		mergeVX: function(){
			if(avm.swapVXIsEven()){
				throw 'Can only mergeVX when !avm.swapVXIsEven() aka odd';
			}
			for(let k in V){
				FIXMEFIXME
				
				FIXME does this need full dedup, including to hash contents of every .d wrapped array, string, etc?
				
				FIXME what if names overlap between V and X?
				
				FIXME what if theres already duplicates, that have different names, both within V, or both within X?
				
				FIXME what if code evaled during merge, such as on browser console, contains some already existing fns,
				and those fns were moved between V and X by swapVX, so now they cross between V and X?
				
				It seems the V and X system isnt gonna work, and should redesign to V and G
				where G is globalId and never allows dups,
				and V is vars that may have dups and can be humanReadable shorter names. ???
			}
			FIXMEFIXME
		},
		
		//The code is both javascript code and is AvmLambda code. Every part of the code is both,
		//unlike wikibinator203 which has a separate syntax than javascript even tho the prototype is made of javascript.
		//Returns what the code evals to.
		//TODO duplicates may be merged.
		mergeEval: function(jsAvmCode){
			if(avm.swapVXIsEven()){
				throw 'Can only mergeEval when avm.swapVXIsEven() aka even';
			}
			console.log('START: mergeEval of this code: '+jsAvmCode);
			console.log('mergeEval, about to swapVX to odd');
			avm.swapVX();
			let ret = null;
			try{
				ret = eval(jsAvmCode);
				console.log('During mergeEval, eval returned. About to mergeVX.
				mergeVX();
			}finally{
				console.log('During mergeEval, mergeVX returned. About to swapVX so go back to even.
				avm.swapVX();
			}
			console.log('END: mergeEval, returning '+ret);
			console.log('FIXME if ret (which was put into X, which was named V at the time) is a duplicate of something in V (which was named X at the time), then return the one from V instead. Also, mergeVX should have emptied X. Im adding Func.replacement() generated by mergeVX (replacement_ field will store that, else it just returns this same lambda (Func.lam), so know which to use.');
			let replac = ret.replacement(); //is same ret if theres no replacement, else is what to replace it with. is a fn/lambda either way.
			if(ret !== replac){
				console.log('Found lambda.replacement() of what eval returned during merge, so returning the replacement instead (part of dedup process, though may not be full dedup)');
				ret = replac;
			}else{
				console.log('replacement() didnt replace anything, returning as is');
			}
			return ret;
		},
		*/

		//read and written many times during avm.lambdizedToString() aka fn+''
		tempTabLevel: 0,

		repeatStr: (str,n)=>{
			let ret = '';
			for(let i=0; i<n; i++) ret += str;
			return ret;
		},

		lambdizedToString: function(){
			try{
				avm.tempTabLevel++;
				let tabs = avm.repeatStr('	',avm.tempTabLevel);
				let betweenLR = '\n'+tabs;

				if(avm.logLambdizedToStringDetails) console.log('START lambdizedToString');
				if(this == avm.I){
					if(avm.logIdentityFuncToStringUglyHackToAvoidInfiniteLoop) console.log('lambdizedToString returning name='+this.nam+' cuz this == avm.I');
					return this.n.nam; //should be "I" for identityFunc, made by F(A).
				}

				//TODO dedup
				//let prefix = avm.lambdaToStringReturnsJsSyntax ? ('V.'+(this.n.nam)+'=') : ((this.n.nam)+'#');
				
				if(!this.n.nam){
					if(avm.strictNameNonNullTests) throw 'No this.n.nam';
				}
				//let prefix = avm.lambdaToStringReturnsJsSyntax ? ('V.'+(this.nam)+'=') : ((this.nam)+'#'); //Proxy makes lambda appear to have the fields of avm.Func.
				let prefix = avm.lambdaToStringReturnsJsSyntax ? ('V.'+(this.n.nam)+'=') : ((this.n.nam)+'#'); //Proxy makes lambda appear to have the fields of avm.Func.
				//changed it from this.nam (which only works in Proxy) to this.n.nam (which also works in lambdized (which right after that will be wrapped in proxy depending on avm/options)).
				
				
				//if(prefix.startsWith("V.ret")){
					//throw 'FIXME';
				//}
				/*if(prefix.startsWith("V.undefined")){
					throw 'FIXME';
				}*/
				if(this.n.curriesSoFar){ //not a leaf (an empty leaf or wrapper of js objects). display as callpair
					//return prefix+'('+this.n.l+' '+this.n.r+')';
					if(avm.logLambdizedToStringDetails) console.log('lambdizedToString call');
					if(avm.lambdaToStringReturnsJsSyntax){
						//let call = this.n.l+'('+this.n.r+')';
						let lStr = ''+this.l;
						//let lStr = this.l.toString(); //may be faster than ''+this.r //but cant do this cuz of Proxy, dont know why.
						if(avm.logLambdizedToStringDetails) console.log('lambdizedToString lStr='+lStr);
						let rStr = ''+this.r;
						//let rStr = this.r.toString(); //may be faster than ''+this.r //but cant do this cuz of Proxy, dont know why.
						if(avm.logLambdizedToStringDetails) console.log('lambdizedToString rStr='+lStr);
						//let call = this.l+'('+this.r+')';
						//let call = lStr+'('+rStr+')';
						
						
						
						//let call = this.n.nam ? (lStr+'('+rStr+',\''+this.n.nam+'\')') : (lStr+'('+rStr+')');
						let call = this.n.nam ? (lStr+betweenLR+'('+rStr+','+betweenLR+'\''+this.n.nam+'\')') : (lStr+betweenLR+'('+rStr+')');
						
						
						if(avm.logLambdizedToStringDetails) console.log('lambdizedToString call='+call);
						/*let retStr;
						if(call.startsWith('V.')){
							retStr = prefix+'('+call+')';
						}else{
							retStr = prefix+call;
						}*/
						let retStr = call;
						if(avm.logLambdizedToStringDetails) console.log('lambdizedToString retStr='+retStr);
						return retStr;
					}else{
						//return prefix+'('+this.n.l+' '+this.n.r+')';
						return prefix+'('+this.l+' '+this.r+')';
					}
				}else if(this.n.d != null){ //display as data literal
					let ty = typeof(this.n.d);
					if(ty == 'string'){
						if(avm.logLambdizedToStringDetails) console.log('lambdizedToString string');
						let quoted = avm.quoteString(this.n.d);
						if(avm.logLambdizedToStringDetails) console.log('lambdizedToString quoted='+quoted);
						if(avm.lambdaToStringReturnsJsSyntax){
							//return prefix+'W('+quoted+')';
							if(this.n.nam){
								//FIXME what if nam needs escaping
								return 'W('+quoted+',\''+this.n.nam+'\')';
							}else{
								return 'W('+quoted+')';
							}
						}else{
							return prefix+quoted;
						}
					}else if(ty == 'number'){
						if(avm.logLambdizedToStringDetails) console.log('lambdizedToString number');
						return ''+this.n.d; //Example: '2.34'
						//TODO? if(avm.lambdaToStringReturnsJsSyntax) put W(this.n.d)?
					}else if(ty == 'object'){
						if(avm.logLambdizedToStringDetails) console.log('lambdizedToString object');
						let pro = Object.getPrototypeOf(this.n.d);
						if(pro == avm.prototypeOfSimpleJsMap || pro == avm.prototypeOfSimpleJsList){
							//FIXME what if it contains AvmLambdas instead of just strings and numbers?
							//The first usecase of this is to put the field names and values
							//of Ball (such as aBall.red and aBall.x and aBall.radius and aBall.maxRadius) into a {} in aLambda.n.d.
							return prefix+JSON.stringify(this.n.d);
						}else if(pro == avm.prototypeOfUint8Array){
							if(avm.lambdaToStringReturnsJsSyntax){
								//return prefix+'Uint8Array.of('+this.n.d+')';
								return (this.n.nam ? ('W(Uint8Array.of('+this.n.d+'),\''+this.n.nam+'\')') : ('W(Uint8Array.of('+this.n.d+'))'));
							}else{
								return prefix+JSON.stringify(this.n.d);
							}
						}else if(pro == avm.prototypeOfUint8ClampedArray){ //FIXME why is Uint8ClampedArray appearing? Does it come from canvas or webcam etc? I didnt make it.
							if(avm.lambdaToStringReturnsJsSyntax){
								return prefix+'Uint8ClampedArray.of('+this.n.d+')';
							}else{
								return prefix+JSON.stringify(this.n.d);
							}
						}else if(pro == avm.prototypeOfFloat32Array){
							if(avm.lambdaToStringReturnsJsSyntax){ //TODO merge duplicate code
								return prefix+'Float32Array.of('+this.n.d+')';
							}else{
								return prefix+JSON.stringify(this.n.d);
							}
						}else if(pro == avm.prototypeOfFloat64Array){
							if(avm.lambdaToStringReturnsJsSyntax){
								return prefix+'Float64Array.of('+this.n.d+')';
							}else{
								return prefix+JSON.stringify(this.n.d);
							}
						}else if(pro == avm.prototypeOfInt32Array){
							if(avm.lambdaToStringReturnsJsSyntax){
								return prefix+'Int32Array.of('+this.n.d+')';
							}else{
								return prefix+JSON.stringify(this.n.d);
							}
						}else if(pro == avm.prototypeOfUint32Array){
							if(avm.lambdaToStringReturnsJsSyntax){
								return prefix+'Uint32Array.of('+this.n.d+')';
							}else{
								return prefix+JSON.stringify(this.n.d);
							}
						}else{
							throw 'Know this.n.d typeof is is "object", but dont know its prototype (TODO handle more than {}, maybe [] also etc?): '+pro;
						}
					}else{
						if(avm.logLambdizedToStringDetails) console.log('lambdizedToString other');
						throw 'this should never happen? this.n.d='+this.n.d+' typeof='+ty;
						//return prefix+'DATA_'+this.n.d; //FIXME

						/*
						if(avm.lambdaToStringReturnsJsSyntax){
							return prefix+'['+this.n.d+']'; //FIXME
						}else{

							
							prototypeOfUint8Array = Object.getPrototypeOf(Uint8Array.of(1)),
							prototypeOfFloat32Array = Object.getPrototypeOf(Float32Array.of(1)),
							prototypeOfFloat64Array = Object.getPrototypeOf(Float64Array.of(1)),
							prototypeOfInt32Array = Object.getPrototypeOf(Int32Array.of(1)),
							prototypeOfUint32Array = Object.getPrototypeOf(Uint32Array.of(1)),
							let d = this.n.d;
							if(d instanceof Uint8Array){
								return 'Uint8Array.of('+d+')';
							}
							if(d instanceof Float32Array){
								return 'Float32Array.of('+d+')';
							}
							if(d instanceof Float64Array){
								return 'Float64Array.of('+d+')';
							}
							if(d instanceof Int32Array){
								return 'Int32Array.of('+d+')';
							}
							if(d instanceof Uint32Array){
								return 'Uint32Array.of('+d+')';
							}
							let d = this.n.d;
							if(d instanceof Uint8Array){
								return 'Uint8Array.of('+d+')';
							}
							if(d instanceof Float32Array){
								return 'Float32Array.of('+d+')';
							}
							if(d instanceof Float64Array){
								return 'Float64Array.of('+d+')';
							}
							if(d instanceof Int32Array){
								return 'Int32Array.of('+d+')';
							}
							if(d instanceof Uint32Array){
								return 'Uint32Array.of('+d+')';
							}
						}
						*/
					}
				}else{
					return 'A';
				}
			}finally{
				avm.tempTabLevel--;
			}
		},

		I: null, //identityFunc. Filled in later.

		runTheseAfterBoot: [],

		//get [] list of all fns in V
		allFns: function(){
			let dedup = new Map();
			let ret = [];
			for(let nam in V){
				let fn = V[nam];
				if(!dedup.get(fn)){
					dedup.set(fn,true);
					ret.push(fn);
				}
			}
			return ret;
		},

		//can be a wrapper of a string of js code like "(x,y,z)=>{return 0;}" or Uint8Array or {} or 2.34 or Float32Array or combos of other Funcs, etc.
		//FIXME .l of every leaf (that may be empty or wrap a string or Uint8Array or 2.34 etc) should be avm.I (identityFunc), but A.I doesnt exist until later in this code,
		//and similarly, .r of every leaf should be that leaf.
		Func: function(left, dataOrNull, right){
			this.l = left; //left lambdized child
			//this.l = left || avm.I; //left lambdized child
			/*if(avm.I === undefined){ //TODO optimize: remove this when bugs are fixed
				throw 'avm.I should have been set to null by now, and after that (and may also be after this) set to a nonnull value, but its undefined.';
			}
			if(!this.l){
				const FuncCreatedBeforeIdentityFuncExists = this;
				const todoNearEndOfBoot = function(){
					//console.log('avm.I = '+avm.I+' About to set it for FuncCreatedBeforeIdentityFuncExists.lam='+FuncCreatedBeforeIdentityFuncExists.lam);
					FuncCreatedBeforeIdentityFuncExists.l = FuncCreatedBeforeIdentityFuncExists.lam.l = avm.I;
				};
				avm.runTheseAfterBoot.push(todoNearEndOfBoot);
			}
			*/
			this.d = dataOrNull;
			this.r = right; //right lambdized child
			//cant do it here cuz have to avm.LambdizeFunc it first. this.r = right || this; //right lambdized child


			this.e = null; //evalsTo. If this.cur==0 then returns what that funcall evals to. If this.cur>0 then is this cuz evals to itself.



			//-1 cuz of "me" param that is the wrapper of the string of js code that starts with "(me,".
			this.cur = (this.d && typeof(this.d)=='string' && avm.appearsToBeJsCodeOfLambda(this.d)) ? (avm.getNumParamsOfJsCodeOfLambda(this.d)-1) : (left ? (left.n.cur-1) : 1);
			//this.cur = (this.d && typeof(this.d)=='string') ? avm.getNumParamsOfJsCodeOfLambda(this.d) : (left ? (left.n.cur-1) : 1);

			this.curriesSoFar = left ? (left.n.curriesSoFar+1) : 0; //Leaf/A/U or wrapper of an array or string, has curriesSoFar of 0.

			if(avm.logCurAndCurriesSoFarWhenCreateFunc){
				console.log('logCurAndCurriesSoFarWhenCreateFunc cur='+this.cur+' curriesSoFar='+this.curriesSoFar+' left='+left+' right='+right+' typeof(this.d)='+typeof(this.d)+' this.d='+this.d);
			}
			
			//This is a js Map, the slow kind where objects (especially functions) can be used as keys and vals. Map of param/paramAkaRight to cp(this,paramAkaRight).
			//FIXME this is cache that needs clearing. PrimaryKey is this.nam?
			this.funcallCache = null;

			//name/id, which is just local and is not the globalId which will be some kindo of hash and saying what kind of array .d is etc, 3 childs: l d r.
			this.nam = null;
			//this.nam2 = null; //TODO second name is for importing other code, then to be merged, and set all nam2's to null again after merged.

			//TODO replace this.nam with this.nams list. For each of these nameX, V.nameX===this.
			//All of these except 1 can be made up names, but that 1 (if its here at all) is globalId and exact dedups this forest shape/data.
			this.nams = [];

			//this.nam = 'n'+(avm.nameCounter++); //for display in case theres multiple parents of same node/avm.Func
			//number of curries left before it evals. FIXME if first param is like '(x,y)=>(x+y*y+3)' then that would be cur of 2, but right counts as 1, so 1 more.
			//moving to LambdizeFunc: this.setNam('n'+(avm.nameCounter++));
			//setNam_anInstanceFuncToBeCalledFromLambdized
		},

		/*Func.prototype.call(param){
			if()
			return this.cp(param).eval();
		};*/

		//If data already exists (by ===, as in Map key, or is that ==?) does not change its name. If you dont give a name and it doesnt already have one, uses avm.newName().
		wrapAsData: function(data, optionalNam){
			let ret = avm.wrapAsData_cache.get(data);
			if(ret === undefined){
				//ret = avm.LambdizeFunc(new avm.Func(null, data, null)); //FIXME dedup
				//ret.setNam(avm.newName());
				let func = new avm.Func(null, data, null);
				func.nam = optionalNam || avm.newName();




				//throw 'FIXME use .id() as 1 of the names in .nams, instead of .nam, depending on avm.alwaysUseIdAndFullDedup';








				//func.setNam(avm.newName()); //do this in func instead of after lambdize, so it will stop logging undefined like: V.undefined=Uint8ClampedArray.of(36,24,26,255,36,24,26,255,32,21,22,255,3
				ret = avm.LambdizeFunc(func);
				//if(optionalNam && !V[optionalNam]){
				//	throw 'No V[optionalNam]';
				//}
				if(optionalNam){
					V[optionalNam] = ret;
				}
				
				if(avm.I){
					ret.l = ret.n.l = avm.I; //(L x (R x)) equals x, forall x.
					ret.r = ret.n.r = ret;
				}else{
					//throw 'No avm.I yet'; //FIXME remove this when bugs are fixed
					console.log('WARNING: wrapAsData, no avm.I yet. This should only happen during boot.');
				}

				avm.wrapAsData_cache.set(data, ret);
			}
			return ret;
		},

		sizeOfMap: map=>{
			let siz = 0;
			for(let x in V) siz++;
			return siz;
		},

		wrapAsData_cache: new Map(),

		//leaves x as it is if already isAvmLambda, else makes it be a vm.Func.d in an avmLambda. avm means AugmentedBalls VM.
		wrap: function(x, optionalName){
			if(avm.isAvmLambda(x)) return x;
			return avm.wrapAsData(x,optionalName);
		},

		//includes the first "(me," param which is used for recursion.
		getParamsListJsCodeOfLambda: function(jsCode){
			let i = jsCode.indexOf(')');
			let j = jsCode.indexOf('=>');
			if(i==-1 && j==-1){
				throw 'No ) or => in lambda: '+jsCode;
			}
			let min = (i==-1) ? j : (j==-1 ? i : Math.min(i,j));
			return jsCode.substring(0,min).replaceAll(' ','').replaceAll('(','').split(',').map(n=>n.trim());
		},

		//includes the first "(me," param which is used for recursion.
		getNumParamsOfJsCodeOfLambda: function(jsCode){
			return avm.getParamsListJsCodeOfLambda(jsCode).length;
		},

		isAvmLambda: x=>(x.isAvmLambda && typeof(x)=='function'),

		//TODO rename avm.Func to avm.Node

		/*const proxy = new Proxy(original, {
			get(target, name, receiver) {
				let rv = Reflect.get(target, name, receiver);
				if(typeof rv === "string"){
					rv = rv.toUpperCase();
				}
				return rv;
			},
			set(target, name, value, receiver) {
				if(!Reflect.has(target, name)){
					console.log(`Setting non-existent property '${name}', initial value: ${value}`);
				}
				return Reflect.set(target, name, value, receiver);
			}
		});*/

		funcOfNoParamsThatReturns0: ()=>0, //TODO remove this if its not being used. i tried it 2023-5-3 in LambdizeFunc but may have commentedout that code.

		newName: function(){
			let ret;
			do{
				let num = (++avm.nameCounter);
				//ret = 'n'+num;
				ret = avm.numberToHumanReadable(num);
			}while(V[ret] !== undefined);
			return ret;
		},

		//englishConsonants: 'bcdfghjklmnpqrstvwxyz',
		lessEnglishConsonants: 'bcdfghjklmnprstvwxyz',

		englishVowels: 'aeiou',

		numberToHumanReadable: num=>{
			let n = num;
			let s = '';
			let consonant = true;
			while(n){
				//let letters = consonant ? avm.englishConsonants : avm.englishVowels;
				let letters = consonant ? avm.lessEnglishConsonants : avm.englishVowels;
				let digit = n%letters.length;
				s += letters[digit];
				n = (n-digit)/letters.length; //like a base letters.length number, except base alternates between englishConsonants.length and englishVowels.length
				consonant = !consonant;
			}
			return s;
		},
		
		//func is a Func object
		LambdizeFunc: function(func){
			const thisFunc = func;
			let ret = function(param, optionalNam){ //param is another lambdized (what LambdizeNode returns). optionalNam sets V[optionalNam] if so.
				if(param === undefined || param == null){ //FIXME remove this check after fix bugs. It should never happen.
					console.log('param is undefined or null, but logging here cuz there was an infinite loop when experimenting with Proxy in LambdizeFunc 2023-5-3');
					throw 'Evaler: param is undefined or null. this lambda = '+thisFunc.lam;
				}
				param = avm.wrap(param); //W(param). leaves param as it is if already isAvmLambda
				let funcall = thisFunc.cp(param);
				if(!funcall.n.nam){
					throw 'No funcall.n.nam in '+funcall;
				}
				if(funcall.n.e != null){
					if(avm.logReturningFromCache) console.log('Returning from cache: '+funcall.n.e);
					return funcall.n.e; //return cached eval
				}
				let evaler = thisFunc.getEvaler();
				let retur = evaler(avm,thisFunc.lam,param); //given a lambdized, returns a lambdized. Any of these may have .d of Float32Array, Uint8Array, 2.34, {}, etc.
				if(retur == null || retur === undefined){ //FIXME remove this check after fix bugs. it should never happen.
					throw 'retur is null or undefined';
				}
				retur = avm.wrap(retur); //W(retur), in case evaler returned a number, string, Uint8Array, etc, instead of an AvmLambda.
				funcall.n.e = retur; //cache the return val of func called on param in case its called again
				if(optionalNam){
					console.log('Evaler, setting retur.setNam(optionalNam) '+optionalNam);
					retur.setNam(optionalNam);
				}
				/*if(optionalNam){
					throw 'TODO hook into V[optionalName] = retur; but careful if it already has a name somehow';
				}*/
				return retur;
				//return thisFunc.call(param); //func is a Func. func.lam is a lambdized. param is a lambdized.
			};

			ret.n = func; //get the wrapped node as lambdized.n
			ret.toString = avm.lambdizedToString;
			ret.isAvmLambda = true;

			//for convenience, copy childs into lambdized form, but not all fields will be there.
			ret.l = ret.n.l;
			ret.r = ret.n.r;
			ret.d = ret.n.d;
			ret.p = ret.n.p; //FIXME might need to make a new func that gets .n first.
			//ret.setNam = avm.setNam_anInstanceFuncToBeCalledFromLambdized;
			func.lam = ret;

			if(avm.wrapJsLambdasInProxy){
				//FIXME dont do "ret.r = ret.n.r;" etc in this case?

				ret = new Proxy(ret, {
					get(theRetLambda, name, proxy){
				
						//FIXME find a way not to hardcode var names here, for speed and simple.
						if(name == 'valueOf') return proxy; //FIXME should this be theRetLambda?
						if(name == 'n') return thisFunc;
						if(name == 'avm') return avm;
						if(name == 'isAvmLambda') return true;
						//if(name == 'nam') return thisFunc.nam; //FIXME why wasnt that working thru proxy?
						if(name == 'setNam') return thisFunc.setNam;



						//if(name == Symbol.toPrimitive) return theRetLambda;
						//if(name == Symbol.toPrimitive) return Symbol.toPrimitive;
						//if(name == Symbol.toPrimitive) return undefined; //undefined, same as RootLam[Symbol.toPrimitive] returns if !avm.wrapJsLambdasInProxy
						//if(name == Symbol.toPrimitive) return 42; //FIXME
						//if(name == Symbol.toPrimitive) return theRetLambda; //FIXME
						//if(name == Symbol.toPrimitive) return eval(prompt('In Proxy, name='+name.description+'. Write js for it to return...'));
						//if(name == Symbol.toPrimitive) return avm.funcOfNoParamsThatReturns0;
						if(name == Symbol.toPrimitive){
							let ty = typeof(thisFunc.d);
							/*2023-5-3 this might be causing, in "let html = ''+this.fn;"...
							AugmentedBalls2.html:874 Uncaught TypeError: string "(me,funcA,funcB,param)=>funcB(funcA(param))" is not a function
								at UINode.display (AugmentedBalls2.html:874:16)
								at new UINode (AugmentedBalls2.html:829:7)
								at uiOf (AugmentedBalls2.html:925:10)
								at new UINode (AugmentedBalls2.html:834:13)
								at uiOf (AugmentedBalls2.html:925:10)
								at new UINode (AugmentedBalls2.html:834:13)
								at uiOf (AugmentedBalls2.html:925:10)
								at window.onload (AugmentedBalls2.html:4764:15)
							so commenting it out
							*/
							/*if(ty == 'number' || ty == 'string'){
								//TODO optimize
								return ()=>thisFunc.d; //get the primitive its wrapping, if its a primitive. does string count as a primitive for Symbol.toPrimitive?
							}*/
							
							/*
							if(ty == 'number'){
								return ()=>thisFunc.d;
							}
							*/

							//return avm.funcOfNoParamsThatReturns0;
							//return ()=>'hello';
							//if(!theRetLambda.n.nam){
							if(!theRetLambda.n.nam && theRetLambda != avm.I){
								let err = 'WARNING: No theRetLambda.n.nam. Was about to return ()=>theRetLambda.toString() in if(name == Symbol.toPrimitive). theRetLambda probably came from Proxy stuff so might not be exactly the object u expect even if it appears to be? Getting this mysterious error 2023-5-3. Saw this happen with theRetLambda being F(A) aka identityFunc, which happens during boot since its the left child of every leaf (and right child of a leaf is that leaf).';
								if(avm.strictNameNonNullTests) throw err;
								else console.log(err);
							}
							return ()=>theRetLambda.toString();
						}

						let ret;
						/*if(typeof(name) == 'symbol'){
							ret = thisFunc[name];
							//ret = Reflect.get(theRetLambda, name, proxy);
							//ret = Reflect.get(thisFunc, name, proxy);
							console.log('Proxy get Symbol varName='+name.description+' val='+ret);
						}else */
						//if(thisFunc.hasOwnProperty(name)){
						if(thisFunc[name] || thisFunc.hasOwnProperty(name)){ //by "thisFunc[name] ||" im trying to also get things in prototype like aLambda.id() instead of aLambda.n.id()
							ret = thisFunc[name];
							if(avm.logProxyGet) console.log('Proxy get existing field varName='+name+' val='+ret);
						}else{
							//FIXME what if the var name like r in in W('(me,r,y,z)=>(x+y+z)')(10)(20).r already existed?
							//Maybe should make them start with a capital in avm.Func fields and lowercase in js lambda strings?
							ret = thisFunc.p(name);
							if(avm.logProxyGet) console.log('Proxy get by .p varName='+name+' val='+ret);
						}
						return ret;
					},
					set(theRetLambda, name, value, proxy){
						theRetLambda[name] = value;
						/*if(!Reflect.has(target, name)){
							console.log(`Setting non-existent property '${name}', initial value: ${value}`);
						}
						return Reflect.set(target, name, value, receiver);
						*/
					}
				});
				func.lam = ret;

				/*const proxy = new Proxy(original, {
					get(target, name, receiver) {
						let rv = Reflect.get(target, name, receiver);
						if(typeof rv === "string"){
							rv = rv.toUpperCase();
						}
						return rv;
					},
					set(target, name, value, receiver) {
						if(!Reflect.has(target, name)){
							console.log(`Setting non-existent property '${name}', initial value: ${value}`);
						}
						return Reflect.set(target, name, value, receiver);
					}
				});*/
			}
			if(ret.n.nam){
				if(avm.logNameAlreadyExistsSoNotChangingIt) console.log('Name already exists in lambdizefunc, ret.n.nam='+ret.n.nam+' so not making a new one');
			}else{
				ret.setNam(avm.newName());
			}
			/*let newNam = optionalNam || ret.n.nam || avm.newName();
			if(ret.n.nam){
				if(avm.logNameAlreadyExistsSoNotChangingIt) console.log('Name already exists in lambdizefunc, ret.n.nam='+ret.n.nam+' so not making a new one');
			}else{
				ret.setNam(newNam);
			}*/
			
			

			return ret;
		},


		/* this was working 2023-5-3 but im making another one using Proxy so dont have to use .n anymore.
		//func is a Func object
		LambdizeFunc: function(func){
			const thisFunc = func;
			let ret = function(param){ //param is another lambdized (what LambdizeNode returns)
				if(param === undefined || param == null){ //FIXME remove this check after fix bugs. It should never happen.
					throw 'Evaler: param is undefined or null. this lambda = '+thisFunc.lam;
				}
				param = avm.wrap(param); //W(param). leaves param as it is if already isAvmLambda
				let funcall = thisFunc.cp(param);
				if(funcall.n.e != null){
					if(avm.logReturningFromCache) console.log('Returning from cache: '+funcall.n.e);
					return funcall.n.e; //return cached eval
				}
				let evaler = thisFunc.getEvaler();
				let retur = evaler(avm,thisFunc.lam,param); //given a lambdized, returns a lambdized. Any of these may have .d of Float32Array, Uint8Array, 2.34, {}, etc.
				if(retur == null || retur === undefined){ //FIXME remove this check after fix bugs. it should never happen.
					throw 'retur is null or undefined';
				}
				retur = avm.wrap(retur); //W(retur), in case evaler returned a number, string, Uint8Array, etc, instead of an AvmLambda.
				funcall.n.e = retur; //cache the return val of func called on param in case its called again
				return retur;
				//return thisFunc.call(param); //func is a Func. func.lam is a lambdized. param is a lambdized.
			};
			ret.n = func; //get the wrapped node as lambdized.n
			ret.toString = avm.lambdizedToString;
			ret.isAvmLambda = true;

			//for convenience, copy childs into lambdized form, but not all fields will be there.
			ret.l = ret.n.l;
			ret.r = ret.n.r;
			ret.d = ret.n.d;
			ret.p = ret.n.p; //FIXME might need to make a new func that gets .n first.

			func.lam = ret;
			//TODO toString
			return ret;
		},*/

		clearAllFuncallCache: function(){
			throw 'TODO';
		},

		//also callpairs. if u dont do this, then memory will run out. TODO 
		clearAllFuncallCacheAndCp: function(){
			throw 'TODO';
		},

		//evaler that just does .cp(param)
		evalerCp: function(avm,func,param){
			return func.n.cp(param);
		},

		getParamValsOfJsLambdaGettingItsLastParam: function(func,param){
			let ret = [];
			let x = func;
			while(x.n.curriesSoFar){
				ret.push(x.n.r);
				x = x.n.l;
			}
			if(typeof(x.d) != 'string'){
				throw 'Not a string wrapper (should be of js code (me,x,y,z...)=> etc): '+x;
			}
			ret.push(x); //the "me" param for recursion.
			ret.reverse();
			ret.push(param);
			return ret;
		},

		//a js lambda of any number of params thats at least 1. Wraps it in something that does currying 1 param at a time and calls the js lambda when gets enuf params.
		//The js lambda's params must all be lambdas (what avm.lambdize returns, or what calling combos of those on eachother returns).
		wrapJsLambda: function(jsLambda){
			return function(avm,func,param){
				if(avm.logDetailedParamsAtEveryCall){
					console.log('logDetailedParamsAtEveryCall: Evaler...');
					console.log('Func: '+func);
					console.log('Param: '+param);
				}
				let ret;
				let isCp;
				if(func.n.cur == 1){
					isCp = false;
					let params = avm.getParamValsOfJsLambdaGettingItsLastParam(func,param); //includes me param as in "(me,x,y,z)=>" etc.
					if(avm.logDetailedParamsAtEveryCall){
						console.log('Params.length: '+params.length+', about to call');
						for(let i=0; i<params.length; i++){
							console.log('Param'+i+': '+params[i]);
						}
					}
					if(params.length != jsLambda.length){ //TODO remove this check after bugs are fixed. It should happen automatically using .cur andOr .curriesSoFar
						throw 'Evaler: Wrong number of params. jsLambda.length='+jsLambda.length+', params.length='+params.length+', jsLambda='+jsLambda+', params='+params;
					}
					ret = jsLambda(...params);
				}else{
					isCp = true;
					if(avm.logCp) console.log('Cp, no eval.');
					ret = func.n.cp(param);

				}
				if(((typeof(ret) == 'number') && isNaN(ret)) || ret==null || ret===undefined){ //FIXME remove this check after fix bugs. it should never happen.
					if(avm.logCp) console.log('isCp = '+isCp);
					if(avm.logRet) console.log('ret = '+ret);
					if((typeof(ret) == 'number') && isNaN(ret)) throw 'Ret is NaN';
					if(ret == null) throw 'Ret is null';
					if(ret === undefined) throw 'Ret is undefined';
				}
				if(avm.logDetailedParamsAtEveryCall){
					console.log('Ret: '+ret);
				}
				return ret;
			};
		},

		manualAddToV: function(fn){
			//FIXME if nam already exists in V
			V[fn.n.nam] = fn;
		},

	};

	for(let i=0; i<16; i++){
		avm.mapOfHexDigitToInt[avm.hexDigits[i]] = i;
		for(let j=0; j<16; j++){
			let hh = avm.hexDigits[i]+avm.hexDigits[j];
			avm.doubleHexDigits.push(hh);
			avm.mapOfDoubleHexDigitsToInt[hh] = ((i<<4)|j);
		}
	}

	avm.Func.prototype.hexContentToHash = function(){
		return avm.bytesToHex(this.contentToHash());
	};

	/*
	//Before merging in new code, change all ids, except globalIds (that start with avm.globalIdPrefix) to start with avm.tempIdPrefix,
	//in case the new ids overlap them.
	avm.Func.prototype.changeToTempIds = function(){
		if(this.nam){
			throw 'TODO replace Func.nam with Func.nams as list';
		}
		for(let i=0; i<this.nams.length; i++){
			let nam = this.nams[i];
			if(!nam.startsWith(avm.globalIdPrefix)){
				let newNam = avm.tempIdPrefix+nam;;
				this.nams[i] = newNam;
				if(V[newNam]){
					throw 'V[newNam='+newNam+'] already exists';
				}
				delete V[nam];
				V[newNam] = this;
			}
		}
	};*/

	
	avm.Func.prototype.changeToTempIds = function(){
		let thiz = this.n ? this.n : this; //can call from lambda or avm.Func
		thiz.changeNams(nam=>{
			if(nam.startsWith(avm.globalIdPrefix)){
				return nam; //dont change globalIds, cuz they wont have duplicates
			}else if(nam.startsWith(avm.tempIdPrefix)){
				//FIXME what if user typed it that way?
				return nam; //no change cuz already starts with that
			}else{
				return avm.tempIdPrefix+nam;
			}
		});
	};

	//The opposite of changeToTempIds
	avm.Func.prototype.undoTempIds = function(){
		let thiz = this.n ? this.n : this; //can call from lambda or avm.Func
		thiz.changeNams(nam=>{
			if(nam.startsWith(avm.globalIdPrefix)){
				return nam; //dont change globalIds, cuz they wont have duplicates
			}else if(nam.startsWith(avm.tempIdPrefix)){
				//FIXME what if user typed it that way?
				return nam.substring(avm.tempIdPrefix.length); //remove tempIdPrefix
			}else{
				return nam; //no change but its not a globalId
			}
		});
	};

	//Example: forward is nam=>(avm.tempIdPrefix+nam) except if it starts with avm.globalIdPrefix dont change it
	avm.Func.prototype.changeNams = function(renamer){
		let thiz = this.n ? this.n : this; //can call from lambda or avm.Func
		if(thiz.nam){
			throw 'TODO replace Func.nam with Func.nams as list';
		}
		for(let i=0; i<thiz.nams.length; i++){
			let nam = thiz.nams[i];
			let newNam = renamer(nam);
			//if(!nam.startsWith(avm.globalIdPrefix)){
			if(nam != newNam){
				if(V[newNam]){
					throw 'V[newNam='+newNam+'] already exists';
				}
				thiz.nams[i] = newNam;
				delete V[nam];
				V[newNam] = thiz;
			}
		}
	};

	//Every avm.Func is defined by this. avm.globalIdPrefix+hex(contentToHash) is the id. Each contentToHash starts with a 1 byte header, a constant to say which kind.
	avm.Func.prototype.contentToHash = function(){
		let thiz = this.n ? this.n : this; //can call from lambda or avm.Func
		//when i say "no childs" I mean a leaf, even though its left child is identityFunc and right child is itself.
		if(thiz.d != null){
			if(thiz.curriesSoFar){ //has childs. has .d
				throw 'Cant have childs and .d/data';
			}else{ //no childs. has .d
				return avm.nodeDataToContentToHash(thiz.d);
			}
		}else{ //d == null
			if(thiz.curriesSoFar){ //has childs. no .d. Is nonempty leaf, wrapping some array or string or number.
				let leftId = thiz.l.n.id(); //may be expensive calculation, but only does it in each node the first time
				let rightId = thiz.r.n.id();
				//FIXME why do i have to .n.globalId() instead of .globalId()? Is Proxy broken?
				return avm.callPairToContentToHash(leftId, rightId);
			}else{ //no childs. no .d. the empty leaf.
				return avm.emptyLeafContentToHash;
			}
		}
	};

	//string, unique id of this lambda/data forest. globalId, 256 bits in hex with a prefix.
	avm.Func.prototype.id = function(){
		let thiz = this.n ? this.n : this; //can call from lambda or avm.Func
		if(!thiz.globalId_){
			let contentToHash = thiz.contentToHash();
			let hashBytes = avm.sha256(contentToHash);
			let hashHex = avm.bytesToHex(hashBytes);
			thiz.globalId_ = avm.globalIdPrefix+hashHex; //TODO should this be stored as bytes instead? Or store both?
		}
		return thiz.globalId_;
	},

	//includes id and contentToHash
	avm.Func.prototype.fullId = function(){
		let thiz = this.n ? this.n : this; //can call from lambda or avm.Func
		return thiz.id()+'_'+thiz.hexContentToHash();
	},

	//for when toString isnt working cuz editing the avm code.
	avm.Func.prototype.simpleToString = function(){
		if(this.d == null){
			if(this.curriesSoFar == 0){
				return 'A';
			}else{
				//TODO merge duplicate code
				let call = this.l+'('+this.r+')';
				if(call.startsWith('V.')){
					call = '('+call+')';
				}
				return 'V.'+this.nam+'='+call;
			}
		}else{
			if(this.curriesSoFar == 0){
				return 'V.'+this.nam+'=JSON'+JSON.stringify(this.d);
			}else{
				//TODO merge duplicate code
				let call = this.l+'('+this.r+')';
				if(call.startsWith('V.')){
					call = '('+call+')';
				}
				return '[V.'+this.nam+'='+call+'_withData_JSON'+JSON.stringify(this.d)+']';
			}
		}
	};

	//Cuz of Proxy and lambdized stuff, should be called as if this is a lambda, not the lambda.n of the node it wraps. ???
	//called in lambdized once per lambda when lambda is created. can call again and will move the lambda in V[name] to V[newName].
	avm.Func.prototype.setNam = function(newName){
		if(!newName) throw 'newName='+newName;
		let thiz = this.n ? this.n : this;
		if(avm.namesGoInVMap){
			//if(thiz.nam !== undefined){
			if(thiz.nam != null){
				if(avm.throwIfChangeName){
					throw 'avm.throwIfChangeName, oldName='+this.nam+', newName='+newName;
				}
				delete V[this.nam];
			}
			if(!thiz.lam){
				throw 'No thiz.lam';
			}
			V[newName] = thiz.lam;
			if(avm.logSettingName) console.log('V.'+newName+' = '+V[newName]+', ');
			if(!V[newName]){
				throw 'No V.'+newName+' in avm.Func.setNam('+newName+') after just set it.';
			}
		}
		thiz.nam = newName;
	};
	/*avm.setNam_anInstanceFuncToBeCalledFromLambdized = function(newName){
		if(avm.namesGoInVMap){
			if(this.n.nam !== undefined){
				delete V[this.n.nam];
			}else{
				V[newName] = this; //this lambda/lambdized
			}
		}
		this.n.nam = newName;
	};*/

	avm.Func.prototype.leftmost = function(){
		let x = this.lam;
		while(x.n.curriesSoFar) x = x.l;
		return x;
	};

	avm.appearsToBeJsCodeOfLambda = str=>(str.startsWith('(') && (str.endsWith('}') || str.endsWith(')'))); //FIXME

	avm.Func.prototype.paramNames = function(){
		if(this.paramNames_ === undefined){
			let leaf = this.leftmost(); //a leaf.
			if(typeof(leaf.d) == 'string' /*&& avm.appearsToBeJsCodeOfLambda(leaf.d)*/){
				this.paramNames_ = avm.getParamsListJsCodeOfLambda(leaf.d);
			}else{
				this.paramNames_ = [];
			}
		}
		return this.paramNames_;
	};

	//UPDATE: for compatibility with Proxy in LambdizeFunc (still experimenting 2023-5-3, TODO), this returns undefined if var not found, instead of throwing.
	//
	//get param by name, if this is a string of js code with curries. If you dont give it an optionalDefaultVal, throws if doesnt have that param.
	//W('(me,x,y,z)=>(x+y*z)')(10)(20).n.p('x') should return wrapped 10, and .p('y') should return wrapped 20, and .p('z') should throw cuz doesnt have val of z.
	//.p('me') returns wrapped '(me,x,y,z)=>(x+y*z)'.
	avm.Func.prototype.p = function(paramName, optionalDefaultVal){
		if(paramName.d !== undefined) paramName = paramName.d; //in case its wrapped in a lambda, get the string (or whatever it is) out.
		if(typeof(paramName) != 'string'){
			throw 'paramName is not a string: '+paramName;
		}
		let thiz = this.isAvmLambda ? this.n : this; //cuz putting the p func in the LambdizedFunc output too.
		let names = thiz.paramNames(); //Does this include the "me" var (which may be named something else, but the first param is always THIS lambda wrapped.
		let i = names.indexOf(paramName);
		let targetCurries = i; //in W('(me,x,y,z)=>(x+y*z)')(10)(20), x should have targetCurries of 1, y 2, and z 3, but curriesSoFar is 2 so cant get z.
		if(i == -1 || thiz.curriesSoFar < targetCurries){ //not found
			if(optionalDefaultVal !== undefined){
				return W(optionalDefaultVal);
			}else{
				//throw 'Var name not found (and you didnt give an optionalDefaultVal), or not enuf params to have a val for that yet, so throwing: '+paramName;

				//UPDATE: for compatibility with Proxy in LambdizeFunc (still experimenting 2023-5-3, TODO), this returns undefined if var not found, instead of throwing.
				return undefined;
			}
		}
		let x = thiz.lam;
		while(targetCurries < x.n.curriesSoFar){
			x = x.l;
		}
		return x.r;
	};

	//returns T or F depending if this and x equal, by content except theres dedup vs lazyDedup stuff to work out such as wrapping Uint8Array.
	avm.Func.prototype.eq = function(x){
		return this.nam==x.n.nam; //use Func.nam as primaryKey for now. FIXME this might not work for Func.data wrapping number of string
	};

	avm.Func.prototype.z = function(){
		return this.eq(T);
	};

	//returns the first lambda with that name, using a linear search, else returns null.
	avm.Func.prototype.getByName = function(name){
		return this.getByRecog(function(x){ console.log('name='+x.n.nam); return x.n.nam==name; });
	};

	//get the first lambda that recog(lambda) returns true for. Else returns null.
	avm.Func.prototype.getByRecog = function(recog){
		if(recog(this.lam)){
			return this.lam;
		}
		if(this.l){
			let foundInL = this.l.n.getByRecog(recog);
			if(foundInL) return foundInL;
		}
		if(this.r){
			let foundInR = this.r.n.getByRecog(recog);
			if(foundInR) return foundInR;
		}
		return null;
	};

	//callpair without evaling. this becomes left. param becomes right.
	
	//[[forkId is normally 0 but may be up to 2**53-1 and be a positive integer (fits in double),
	//and if is nonzero like that, then uses the forks of its childs that have all 0s recursively down to A/leaf.
	//This is a new design 2023-5-7 and im unsure if will keep it, havent coded much of it yet.]]
	//FIXME this cant emulate itself, has a self reference problem, if fns cant see forkId but its still a child of forkId.
	//Dont use forkId for now. Thinking...
	//
	avm.Func.prototype.cp = function(right, optionalForkId){
		let forkId = optionalForkId || 0; //addAnotherChild(forkId)ToEveryAvmlambdaOrALayerAboveThemThatAddsSuchData_sSoCanHaveMultipleOfTheSameContentOnScreenAtOnce
		if(avm.logCp){
			console.log('cp, this.lam='+this.lam); //FIXME remove this after fix bugs
			console.log('cp, right='+right); //FIXME remove this after fix bugs
		}
		
		//FIXME if this is avm.I (which isnt created until near end of boot), and param/right is a leaf, then must return that leaf.
		//I could just check for that here except avm.I might not exist yet.
		if(avm.I){
			if(this.lam==avm.I && right.n.curriesSoFar == 0){
				console.log('cp/callpair returning right/param to make (L x (R x)) equal x where x is some leaf.');
				return right; //cuz (L x (R x)) equals x forall x. If x is a leaf, (L x) is avm.I (identityFunc) so (identityFunc x) return x.
			}
		}else{
			console.log('WARNING: cp/callpair before avm.I (identityFunc) exists, and right is a leaf. This is called "tie the quine knot" in testcases in Wikibinator203VM.js. This is a simpler combinator than wikibinator203 made for AugmentedBalls and doesnt protect against infiniteLoops or other problems etc. Its meant as a temporary step to get AugmentedBalls working asap before porting AugmentedBalls to wikibinator203.');
		}

		//return new Func(this, null, right); //FIXME dedup
		if(!this.funcallCache){
			this.funcallCache = new Map();
		}
		let ret = this.funcallCache.get(right);
		if(!ret){
			ret = avm.LambdizeFunc(new avm.Func(this.lam, null, right));
			if(!ret.n.nam){
				let newName = avm.newName();












				//throw 'FIXME use .id() as 1 of the names in .nams, instead of .nam, depending on avm.alwaysUseIdAndFullDedup';

























				if(avm.logSettingName) console.log('Setting name '+newName);
				ret.setNam(newName);
			}
			this.funcallCache.set(right, ret);
		}
		if(!ret.n.nam){
			throw 'No ret.n.nam at end of cp/callPair, was about to return '+ret;
		}
		return ret;
	};

	//an evaler is a js func like (avm,func,param)=>{...return what func called on param should return...}
	avm.Func.prototype.getEvaler = function(){
		if(!this.cacheEvaler){
			//if(this.l){
			if(this.curriesSoFar){ //is not a leaf
				//only define evaler at leftmost node, which is a string if its js code. copy evaler from left child after that.
				this.cacheEvaler = this.l.n.getEvaler();
			}else{ //is a leaf
				if(typeof(this.d) == 'string' && avm.appearsToBeJsCodeOfLambda(this.d)){
					let jsCode = this.d;
					if(avm.putEvaledJsCodeInBrowserDebugger){
						//Example: eval('console.log("Hello, world!");\n//# sourceURL=blah.html')
						this.fileName = this.nam+'.js'; //FIXME dont allow this if theres already a file loaded of that name, either from actual files or another generated one if name changed to overlap an earlier name etc.
						console.log('options.putEvaledJsCodeInBrowserDebugger this.fileName='+this.fileName);
						jsCode += '\n//# sourceURL='+this.fileName;
					}
					this.cacheEvaler = avm.wrapJsLambda(avm.cacheEval(jsCode));
				}else{
					//FIXME why was this here... return this.cp(param); //just make another callpair
					this.cacheEvaler = avm.evalerCp;
				}
			}
		}
		return this.cacheEvaler;
	};

	let funcA = new avm.Func(null, null, null);
	funcA.nam = 'A';
	const A = avm.LambdizeFunc(funcA);
	avm.A = A; //the empty leaf. there can be other leafs such as wrapping a string, Uint8Array, Float32Array, 2.34, etc.

	avm.W = avm.wrap;

	avm.T = avm.W('(me,x,y)=>x', 'T');

	//avm.F = avm.W('(me,x,y)=>y');
	avm.F = avm.W('(me,x,y)=>y', 'F');

	//avm.I = avm.F(A); //identityFunc
	avm.I = avm.F.n.cp(A); //identityFunc
	avm.I.nam = 'I';
	avm.manualAddToV(avm.I);

	/* Dont do it this way cuz it breaks the names to setNam before const A = (()=>{...}) has returned.

	//a combinator, universal if you count that it can wrap javascript code strings and eval them
	const A = avm.LambdizeFunc(new avm.Func(null, null, null));
	avm.A = A; //the empty leaf. there can be other leafs such as wrapping a string, Uint8Array, Float32Array, 2.34, etc.
	avm.A.setNam('A');

	avm.W = avm.wrap;

	avm.T = avm.W('(me,x,y)=>x');
	avm.T.setNam('T');

	//avm.F = avm.W('(me,x,y)=>y');
	avm.F = avm.W('(me,x,y)=>y');
	avm.F.setNam('F');

	//avm.I = avm.F(A); //identityFunc
	avm.I = avm.F.n.cp(A); //identityFunc
	avm.I.setNam('I');
	*/
	
	//A.n.l = avm.I;
	//A.n.r = A;

	for(let fn of [avm.T, avm.F, avm.I, avm.A]){
		console.log('Tie the quine knot, during boot. Dont want to toString it yet.');
		fn.l = fn.n.l = avm.I;
		fn.r = fn.n.r = fn;
	}

	/*
	if(!avm.I) throw 'No avm.I yet'; //FIXME remove this when bugs are fixed
	ret.l = ret.n.l = avm.I; //(L x (R x)) equals x, forall x.
	ret.r = ret.n.r = ret;
	*/

	//FIXME do the same for all leafs that are wrappers of something (such as wraps a Uint8Array or string or 2.34)
	while(avm.runTheseAfterBoot.length){
		avm.runTheseAfterBoot.pop()();
	}
	//delete avm.runTheseAfterBoot;
	

	A.avm = avm;
	return A;
})();
//Example: W('(x,y)=>W(x.d*x.d+y.d*y.d)')(6)(8) returns a lambda wrapping the data 100, since u cant start with a string on browser console.
//U can put string or number or avmLambda as param of any avmLambda.
const W = A.avm.wrap;
console.log('the combinator A = '+A+' W='+W);

var Sqr = W("(me,x)=>(x.d**2)",'Sqr');

(()=>{
	let sqr20 = Sqr(20).d;
	if(sqr20 != 400){
		throw 'Sqr(20).d is '+sqr20+' but must be 400';
	}
	console.log('Test pass: sqr20');
})();

var Sqrt = W("(me,x)=>Math.sqrt(x.d)",'Sqrt');

var SlowHypot = W("(me,sq,sqrt,x,y)=>sqrt(sq(x).d+sq(y).d)")(Sqr)(Sqrt);

(()=>{
	let slowHypot_6_8 = SlowHypot(6)(8).d;
	if(slowHypot_6_8 != 10){
		throw 'SlowHypot(6)(8).d is '+slowHypot_6_8+' but must be 10';
	}
	//TODO test Fibonacci(78).d == 8944394323791464 (which is the biggest param of fibonacci where the return fits in double exactly)
	//to verify funcall caching works.
	console.log('Test pass: slowHypot_6_8');
})();

var Fibonacci = W("(me,x)=>(x.d<2 ? x.d : (me(x.d-1).d+me(x.d-2).d))", 'Fibonacci');

(()=>{
	let fib10 = Fibonacci(10).d;
	if(fib10 != 55){
		throw 'Fibonacci(10).d is '+fib10+' but must be 55';
	}
	console.log('Test pass: fib10');

	let fib70 = Fibonacci(70).d;
	if(fib70 != 190392490709135){
		throw 'Fibonacci(70).d is '+fib10+' but must be 190392490709135';
	}
	console.log('Test pass: fib70. This also verifies that func_param_return caching is working, else it would be exponentially slow.');

	//TODO test Fibonacci(78).d == 8944394323791464 (which is the biggest param of fibonacci where the return fits in double exactly)
	//to verify funcall caching works.
})();



var Chain2Calls = W('(me,funcA,funcB,param)=>funcB(funcA(param))', 'Chain2Calls');

var Chain3Calls = W('(me,funcA,funcB,funcC,param)=>funcC(funcB(funcA(param)))', 'Chain3Calls');

var Chain4Calls = W('(me,funcA,funcB,funcC,funcD,param)=>funcD(funcC(funcB(funcA(param))))', 'Chain4Calls');

var LOrNull = W('(me,x)=>x.n.l', 'LOrNull');

var ROrNull = W('(me,x)=>x.n.r', 'ROrNull');

//if x is a leaf, returns I (identity func), so (L x (R x)) equals x, forall x.
var L = W('(me,x)=>(x.n.l||I)', 'L');

//if x is a leaf, returns x, so (L x (R x)) equals x, forall x.
var R = W('(me,x)=>(x.n.r||x)', 'R');

var S = W('(me,x,y,z)=>x(z)(y(z))',	'S');

//churchPair
var Pair = W('(me,x,y,z)=>z(x)(y)', 'Pair');

var T = A.avm.T;

var F = A.avm.F;

//identityFunc
var I = A.avm.l;

//returns T if it has no childs, but in AvmLambdas theres the empty leaf and a leaf wrapper of any string, Uint8Array, Float32Array, 2.34, etc.
var IsAnyleaf = W('(me,x)=>(x.n.curriesSoFar ? F : T)', 'IsAnyleaf');

var IsEmptyLeaf = W('(me,x)=>((x.n.curriesSoFar && x.n.d==null) ? F : T)', 'IsEmptyLeaf');

var IsNonemptyLeaf = W('(me,x)=>((x.n.curriesSoFar && x.n.d!=null) ? F : T)', 'IsNonemptyLeaf');

var IsNonleaf = W('(me,x)=>(x.n.curriesSoFar ? T : F)', 'IsNonleaf');

(()=>{
	console.log('Testing id');
	let pairST = Pair(S)(T);
	let observedId = pairST.id();
	if(A.avm.idOfPairST != observedId){
		throw avm.idOfPairST+' == avm.idOfPairST != observedId == '+observedId;
	}
	let observedFullId = pairST.fullId();
	if(A.avm.fullIdOfPairST != observedFullId){
		throw avm.fullIdOfPairST+' == avm.fullIdOfPairST != observedFullId == '+observedFullId;
	}
	console.log('Test pass, Pair(S)(T) observedId='+observedId+' observedFullId='+observedFullId);
})();

var EmptyMap = W({}, 'EmptyMap');

//get from {} in ob.n.d
var Get = W(`(me,ob,key)=>W(ob.n.d[key])`, 'Get');

//forkEdit into {} in ob.n.d
var Put = W(`(me,ob,key,val)=>{
	let map = {};
	for(let k in ob.n.d) map[k] = ob.n.d[k];
	map[key.n.d] = val.n.d; //FIXME should val have to be the .d? or can val be an AvmLambda?
	return W(map);
}`, 'Put');


//FIXME should funcs have recursion ability? How do they see themself? Add a "me" param, the first param of every fn.

</script>
<script>

//This code is a fork of wikibinator203/Wikibinator203DirectedGraphUI.html 2023-5-1+, and was written for wikibinator203 lambdas
//but am modifying it for AvmLambdas (avm.A is an empty leaf lambda, for example).


var Rnd = ()=>Math.random();

//var countTemp = 0;

let countUINodes = 0;

var repelMult = 3;
var farAttractMult = 125;
var speedDecay = .85;
var pushParentAboveChild = 22.3;
var pushLToBeLeftOfRRegardlessOfHeight = 30;

//fn is a wikibinator203 lambda.
//TODO this might instead be a "pointer into a Human mind", like a temporary mutable variable that sometimes generates fns (which are immutable),
//since Humans seem to need the ability to edit inside a code string without replacing their own thoughts about code outside that {...} or (...) or [...] block.
//Mutable stuff would be in UI only, not part of Wikibinator203 spec.
var UINode = function(fn){

	countUINodes++;

	//dom object, maybe a div. It may contain text (of parts of wikibinator203 code), canvas (pixels chosen by wikibinator203), or other UI parts.
	this.dob = null;

	//TODO move this.dob into this.dobs.main or named something like that.
	//Also put the textarea that contains the code in here as .txt or .textarea etc.
	this.dobs = {};

	this.type = 'TODO theres less than 20 node types, including leaf, float64, evaling, etc';

	//this.size = 100; //similar to radius, but its actually a rectangle so that doesnt exactly describe it.
	//this.size = 30;
	//this.size = 50;
	this.size = 45;

	this.pos = [800+Rnd()*600, Rnd()*900]; //screen position
	//this.pos = [Rnd()*500, Rnd()*500]; //screen position
	//this.pos = [100, Rnd()*500]; //screen position

	//this.pos = [100, 100]; //screen position
	//this.pos = [100, countUINodes*400-300]; //screen position
	//this.pos = [100+countUINodes*50, countUINodes*400-300]; //screen position
	//this.pos = [countTemp+=100,0]; //FIXME

	this.vel = [0, 0]; //change of this.pos per second

	this.accel = [0, 0]; //change of this.vel per second. this is set by TODO some code that calls edgeEnergyFunc

	//forMutUinodeClickAnyNodeToEditUnderRecursively
	//forMutUinodeClickAnyNodeToEditUnderRecursively
	//If true, then this.fnMut must be true.
	this.isSelectedRoot = false;

	//Is this.fn field used as mutable (allowed to replace with diff immutable fn) vs immutable (dont replace)?
	//(this.fnMut || (!this.curriesSoFar || (!this.l.fnMut && !this.r.fnMut))) should always be true.
	this.fnMut = false;

	//(this.fnMut || !this.isEditing) should always be true. If editing, then this.dob might contain a textarea, checkbox, number chooser, etc,
	//and various related buttons and ways of dragging and dropping.
	this.isEditing = false;


	this.fn = fn; //display this.fn.localName or vm.eval(...) but modified to limit how big a code string it can generate and leave some branches closed.

	//this.edges = {};
	this.outs = {}; //edges out. theres less than 10 edge types, and at most 1 of each kind, from fns anyways, but mindmap nodes (if i add those later) might have weighted edges and many of the same kind outward.
	//this.ins =  //can have many incoming edges.

	fn.n.ui = this;
	this.display();

	if(!fn.n.curriesSoFar == 0){
		//recurse to create UINodes in left and right childs. FIXME if theres alot of nodes, or if theres big bigstrings,
		//this should be done sparsely instead, to only display parts that open/close when look deeper.
		let lUI = uiOf(fn.l);
		let rUI = uiOf(fn.r);
		//FIXME display overlapping edges (from and to the same node) different by a few pixels side by side so one isnt hidden by the other.
		//new UIEdge(this,'l',lUI); //FIXME why doesnt it do this? ets this.outs.l = lUI
		//new UIEdge(this,'r',rUI); //FIXME why doesnt it do this? sets this.outs.r = rUI
		this.outs.l = new UIEdge(this,'l',lUI);
		this.outs.r = new UIEdge(this,'r',rUI);
		/*TODO? if(fn.l.l == S){ //uses {...} syntax, the sCurryList syntax.
			let to = fn.l.r;
			let sUI = uiOf(to);
			this.outs.s = new UIEdge(this,'s',sUI); //sets this.outs.s = sUI
		}*/
	}

	nodes.push(this);
	let fnStr = ''+fn;
	console.log('Created uinode nodes['+(nodes.length-1)+'] for fn: '+fnStr);
	if(!fnStr){
		//let fnStr2 = ''+fn;
		throw 'Empty fnStr at nodes['+(nodes.length-1)+']';
	}
};

//if just 1 param, gets dom node by that id. if 2 or 3 params, makes new dom node.
var Dob = (parentDob_or_id,tag,optionalInnerHtml)=>{
	if(typeof(parentDob_or_id) == 'string'){
		return document.getElementById(parentDob_or_id);
	}
	let ret = document.createElement(tag);
	if(parentDob_or_id) parentDob_or_id.appendChild(ret);
	if(optionalInnerHtml) ret.innerHTML = optionalInnerHtml;
	return ret;
};

UINode.prototype.width = function(){
	if(!this.dobs.main) return 1;
	return this.dobs.main.clientWidth;
};

UINode.prototype.height = function(){
	if(!this.dobs.main) return 1;
	return this.dobs.main.clientHeight;
};

//returns 0 to 1 for amount of overlap of 2 rects, as a fraction of [max possible overlap ignoring position].
UINode.prototype.fractionOverlap = function(uinodeB){
	//enAtHere = potentialEnergyOfPairOfRectsForRepel(fr.pos[0], fr.pos[1], frHeight, frWidth, to.pos[0], to.pos[1], toHeight, toWidth);
	return fractionOverlap(this.pos[0], this.pos[1], this.height(), this.width(), uinodeB.pos[0], uinodeB.pos[1], uinodeB.height(), uinodeB.width());
};

/*
TODO should the harmonySearchable parts of UI each have a position and velocity automatically?
y x h w isSelectedRoot fnMut isEditing.
velY velX velH velW velIsSelectedRoot velFnMut velIsEditing.
..
But that seems it wouldnt work with forkId (primaryKey of UI being fn_and_uint53)
*/



//this might become the new UINode class, but is an AvmLambda.
//var UI = W(`(me,fn,cacheHtml,y,x,h,w,velY,velX,isSelectedRoot,fnMut,isEditing)=>0`);
var UI = W(`(me,fn,y,x,h,w,velY,velX,isSelectedRoot,fnMut,isEditing)=>0`);

var UIx = W(`(me,ui)=>(ui.x)`);

//FIXME how can i put a canvas or pic in these at realtime speed?

//var estimateTextWithButDontGoUnder = txt=>(5+txt.length*7); //FIXME *10 instead of *7?

var setHeightAndWidthByContent = dob=>{

	console.log('w='+dob.style.width+' sw='+dob.scrollWidth);
	dob.style.width = 'auto';
	let newW = dob.scrollWidth;
	if(!dob.value.includes('\n')){
		newW = Math.min(newW,Math.max(options.minTextareaWidthPx,5+dob.value.length*8));
	}
    dob.style.width = newW+'px';

	console.log('h='+dob.style.height+' sh='+dob.scrollHeight);
	dob.style.height = 'auto'; //set its height to normal, not the modified height, so can read scrollHeight from that
	dob.style.height = dob.scrollHeight+'px';
};

var setInputTypeTextWidthByContent = dob=>{
	console.log('setInputTypeTextWidthByContent w='+dob.style.width+' sw='+dob.scrollWidth);
	//dob.style['min-width'] = 0;
	dob.style.width = 'auto';
	dob.style.width = Math.min(dob.scrollWidth,5+dob.value.length*7)+'px';
	//dob.style['min-width'] = '10px';
	//dob.style.width = Math.max(dob.scrollWidth, dob.offsetWidth, dob.clientWidth, dob.getBoundingClientRect().width, parseInt(getComputedStyle(dob).getPropertyValue("min-width"))) + "px";
	//dob.style.width = '20px';
};

//when click a UINode, bring it to front of other UINodes by setting its z-index to ++astZIndex.
var lastZIndex = 1000;

var maxNamLength = 100;

var isValidNam = function(nam){
	return nam.length && (nam==nam.trim()) && (name.length<maxNamLength); //FIXME verify is no whitespace
};

//used for dom nodes with js code in their fields to get objects defined outside that js code such as UINodes.
//TODO garbcol
var IdToOb = {};
//Fills IdToOb
var NewIdOf = function(anything, optionalPrefix){
	let prefix = optionalPrefix || '';
	let id = newId(prefix);
	IdToOb[id] = anything; //TODO garbcol
	return id;
};

var bringToFront = function(dob){
	if(dob.uinode){
		console.log('bringToFront '+dob.uinode.fn.nam);
	}else{
		console.log('bringToFront no dob.uinode');
	}
	dob.style['z-index'] = (++lastZIndex)+1e7;
};

UINode.prototype.display = function(alsoUpdateUiedges){
	if(!this.dobs.main){
		//let extraHtml = '';

		this.id = NewIdOf(this);
		

		//let html = '<textarea style="resize:none;overflow:hidden;height:auto" oninput="console.log(\'h=\'+this.height+\' sh=\'+this.scrollHeight); this.height=this.scrollHeight+\'px\';">'+this.fn+'</textarea>'+extraHtml;
		//let html = '<textarea style="overflow:hidden;height:auto" oninput="console.log(\'h=\'+this.height+\' sh=\'+this.scrollHeight); this.height=this.scrollHeight+\'px\';">'+this.fn+'</textarea>'+extraHtml;
		let txtId = newId('txt');
		let html = '<table><tr><td>';
		//html += 'DRAG ME. isSelectedRoot='+this.isSelectedRoot+' fnMut='+this.fnMut+' isEditing='+this.isEditing+' <input type=checkbox>TODO edit, <input type=text value="'+this.fn.n.nam+'"></input>, <input type=button value="mcopy" title="make mutable copy"></input><input type=button style="float:right" value="X"></input>';
		let chkId = newId('chk');
		let nam = this.fn.n.nam;
		//let txtW = 20+12*nam.length;
		//html += '<input type=checkbox id="'+chkId+'"><label for="'+chkId+'">edit</label> ';
		html += '<input type=checkbox style="transform:scale(1.3)" disabled id="'+chkId+'" title="the code below is editable"> ';
		let idLButton = newId('lButton');
		let idRButton = newId('rButton');
		let idEButton = newId('eButton');
		let idCButton = newId('cButton');
		
		

		let namId = newId('nam');
		html +='<input type=text id="'+namId+'" style="width:10px" value="'+nam+'" oninput="setInputTypeTextWidthByContent(this); console.log(\'id=\'+this.id+\' uinode=\'+this.uinode); let undo = true; let err = null; if(isValidNam(this.value)){ try{ this.uinode.fn.setNam(this.value); }catch(e){ undo = true; err = e; } } if(undo) this.value=this.uinode.fn.nam; if(err) throw err;">';
		html += '<input type=button style="float:right" disabled value="X"><br>';

		html +='<input type=button id="'+idLButton+'" value="L" onclick="console.log(\'L, IdToOb.'+this.id+'.outs=\'+Object.keys(IdToOb.'+this.id+'.outs)+\' IdToOb.'+this.id+'.outs.l=\'+IdToOb.'+this.id+'.outs.l	); if(!IdToOb.'+this.id+'.outs.l){ console.log(\'!IdToOb.'+this.id+'.outs.l so returning early\'); return; } console.log(\'about to bringToFront\'); bringToFront(IdToOb.'+this.id+'.outs.l.to.dobs.main);" style="background-color:#0a0" title="get left/func child. Forall x, if x is halted then L(x)(R(x))===x">';
		html +='<input type=button id="'+idRButton+'" value="R" onclick="if(!IdToOb.'+this.id+'.outs.l) return; bringToFront(IdToOb.'+this.id+'.outs.r.to.dobs.main);" style="background-color:#88f" title="get right/param child. Forall x, if x is halted then L(x)(R(x))===x">';
		html +='<input type=button id="'+idEButton+'" value="E" disabled style="background-color:#d66" title="get evalsTo, what left child called on right child evals to. If this is halted, it evals to itself. If not, evals to another one or never halts.">';
		//html += '<input type=button value="mcopy" title="make mutable copy">';
		html += '<input type=button id="'+idCButton+'" value="C" disabled style="background-color:#bbb" title="make mutable copy"> ';

		let msgLabelId = newId('msgLabel');
		html += '<label id="'+msgLabelId+'"></label>'; //messages to user go here

		html += '</td></tr><tr><td>';
		let code = this.fn.curriesSoFar ? '//callPair' : ''+this.fn;
		html += '<textarea id="'+txtId+'" style="white-space:nowrap;" rows=1 oninput="setHeightAndWidthByContent(this);">'+code+'</textarea>';
		html += '</td></tr></table>'
		//html = html.replaceAll('\\n','\n<br>');
		html = html.replaceAll('\\n','\n');
		this.dobs.main = Dob(mainDiv,'div',html);
		this.dobs.main.addEventListener('click', function(event){
			console.log('this='+this);
			this.style.zIndex = (++lastZIndex); //bring to front
		});
		this.dobs.txt = Dob(txtId); //inside this.dobs.main
		if(!options.displayTextareaForCallPairsThatHaveNoDotDData && this.fn.curriesSoFar){
			this.dobs.txt.style.display = 'none';
		}
		this.dobs.editChk = Dob(chkId);
		this.dobs.nam = Dob(namId);
		this.dobs.lButton = Dob(idLButton);
		this.dobs.rButton = Dob(idRButton);
		this.dobs.eButton = Dob(idEButton);
		this.dobs.cButton = Dob(idCButton);
		this.dobs.msg = Dob(msgLabelId);
		//this.dobs.lButton.uinode = this;
		//this.dobs.rButton.uinode = this;
		//this.dobs.eButton.uinode = this;
		//this.dobs.cButton.uinode = this;
		//if(this.dobs.lButton.uinode !== this){
		//	throw 'this.dobs.lButton.uinode wasnt set';
		//}
		this.dobs.nam.uinode = this;
		this.dobs.main.style.opacity = options.uinodeOpacity;
		this.dobs.main.style['user-select'] = 'none'; //prevent selecting node since selecting text in it interferes with dragging node
		this.dobs.main.style.color = 'black';
		//this.dob = Dob(document.body,'div',''+this.fn);
		this.dobs.main.style.position = cssPositionType; //relative to mainDiv?
		this.dobs.main.style['background-color'] = randColorStr();
		//this.dob.style.height = '30px';
		//this.dob.style.height = '50px';
		//this.dob.style.width = '200px';
		//this.dob.style.width = '10px';
		//this.dob.style.background = 'url(redSawTooth.png)';
		setHeightAndWidthByContent(this.dobs.txt);
		setInputTypeTextWidthByContent(this.dobs.nam);
	}
	//this.dob.style.top = Math.floor(this.pos[0])+'px';
	//this.dob.style.left = Math.floor(this.pos[1])+'px';

	let msg = ''; //message to user
	if(options.displayRectCoordsInEachUinode){
		let coords = '<br>y'+this.pos[0]+'<br>y'+(this.pos[0]+this.height())+'<br>x'+this.pos[1]+'<br>x'+(this.pos[1]+this.width());
		msg += coords;
	}
	this.dobs.msg.innerHTML = msg;

	let a = 1, b = 0, c = 0, d = 1;
	let ty = this.pos[0];
	let tx = this.pos[1];
	this.dobs.main.style.transform = 'matrix('+a+','+b+','+c+','+d+','+tx+','+ty+')';

	//this.dob.style.transform = 'matrix3d('+a+','+b+',0,0,  '+c+','+d+',0,0,  0,0,1,0,  '+tx+','+ty+',0,1)';

	if(alsoUpdateUiedges){
		for(key in this.outs){
			this.outs[key].display(); //display edge from this UINode
			//this.outs[key].dob.style.zIndex = (++lastZIndex); //bring to front
		}
	}
};

var cssPositionType = 'absolute';

var randColorStr = ()=>colorStr(.45+.55*Math.random(), .45+.55*Math.random(), .45+.55*Math.random());

var asByte = num=>betweenInt(0,num,255);

var colorStr = function(redFraction, greenFraction, blueFraction){
	let r = asByte(redFraction*256);
	let g = asByte(greenFraction*256);
	let b = asByte(blueFraction*256);
	let s = '000000'+(r*65536+g*256+b).toString(16);
	return '#'+s.substring(s.length-6);
};

var nodes = [];

var allUiedges = ()=>{
	let ret = [];
	for(let node of nodes) for(let k in node.outs) ret.push(node.outs[k]);
	return ret;
};

var uiOf = function(fn){
	if(fn.n.ui) return fn.n.ui; //store it in field in the lambda (or whatever it is).
	//if(vm.isLambda(fn)){
	if(avm.isAvmLambda(fn)){
		return fn.n.ui = new UINode(fn); //sets fn.ui to that
	}else{
		throw 'TODO wrap other kind of object, thats not a wikibinator203 lambda';
	}
};


var repelMult = 3;
var farAttractMult = 125;
var speedDecay = .85;
var pushParentAboveChild = 22.3;
var pushLToBeLeftOfRRegardlessOfHeight = 30;

/*//This code copied (and maybe modified todo?) from Wikibinator203DirectedGraphUI.html 2023-5-9+
var getEdges = function(){
	let ret = [];
	for(let node of nodes){
		for(let edgeType in node.outs){
			let edge = node.outs[edgeType];
			ret.push(edge);
		}
	}
	return ret;
};*/

//from is l. to is r. todo rename those vars.
//This code copied (and maybe modified todo?) from Wikibinator203DirectedGraphUI.html 2023-5-9+
var potentialEnergyOfLR = (yFrom, xFrom, sizeFrom, yTo, xTo, sizeTo)=>{
	let en = 0;
	//let dy = yTo-yFrom;
	let dx = xTo-xFrom;
	let repelDist = sizeFrom+sizeTo;
	//let distSq = dy*dy + dx*dx;
	//let dist = Math.sqrt(distSq);
	if(dx < repelDist){
		let diff = repelDist-dx;
		en += diff*diff*pushLToBeLeftOfRRegardlessOfHeight;
	}
	return en;
};

//amount of overlap of 2 lines in 1d
var lineOverlap1d = (startA, endA, startB, endB)=>{
	return Math.max(0, Math.min(endA,endB) - Math.max(startA,startB));
};

var fractionOverlap = (yFrom, xFrom, heightFrom, widthFrom, yTo, xTo, heightTo, widthTo)=>{
	let overlapX = lineOverlap1d(xFrom, xFrom+widthFrom, xTo, xTo+widthTo);
	let overlapY = lineOverlap1d(yFrom, yFrom+heightFrom, yTo, yTo+heightTo);
	let maxPossibleOverlapY = Math.min(heightFrom, heightTo);
	let maxPossibleOverlapX = Math.min(widthFrom, widthTo);
	let overlapYFraction = overlapY/maxPossibleOverlapY;
	let overlapXFraction = overlapX/maxPossibleOverlapX;
	return overlapYFraction*overlapXFraction; //0 to 1
};

var potentialEnergyOfPairOfRectsForRepel = (yFrom, xFrom, heightFrom, widthFrom, yTo, xTo, heightTo, widthTo)=>{
	return fractionOverlap(yFrom, xFrom, heightFrom, widthFrom, yTo, xTo, heightTo, widthTo)*options.potenMultForRectOverlap;
};

//This code copied (and maybe modified todo?) from Wikibinator203DirectedGraphUI.html 2023-5-9+
//this is by distance of top left corners, not rect overlap.
var potentialEnergyOfPairOfNodesForRepel = (yFrom, xFrom, sizeFrom, yTo, xTo, sizeTo)=>{
	let en = 0;
	let dy = yTo-yFrom;
	let dx = xTo-xFrom;
	//let distSq = dy*dy + dx*dx;
	//let dist = Math.sqrt(distSq);
	let dist = Math.hypot(dy,dx);
	let repelDist = sizeFrom+sizeTo;
	if(dist < repelDist){
		let diff = repelDist-dist;
		en += diff*diff*repelMult;
	}
	return en;
};

/** This is used for spring-like positioning of uinodes on screen.
y and x are screen positions. nodeTypes are what kind of icon it is, such as evaling vs this kind of list [...] etc.
edgeType is 'l' for left child, 'r' for right child, 'e' for evals to what, etc.
Sizes are approx radius, even though radius doesnt describe a rectangle well, it will tend to give things more or less space on screen.
FIXME should this be called even if there is no edge? cuz they could overlap otherwise.
..
//This code copied (and maybe modified todo?) from Wikibinator203DirectedGraphUI.html 2023-5-9+
*/
var potentialEnergyOfEdge = (yFrom, xFrom, sizeFrom, fromType, edgeType, toType, yTo, xTo, sizeTo)=>{
	let en = 0;
	let dy = yTo-yFrom;
	let dx = xTo-xFrom;
	//let distSq = dy*dy + dx*dx;
	//let dist = Math.sqrt(distSq);
	let dist = Math.hypot(dy,dx);
	let repelDist = sizeFrom+sizeTo;
	/*do this in potentialEnergyOfPairOfNodesForRepel instead...
	if(dist < repelDist){
		let diff = repelDist-dist;
		en += diff*diff*repelMult;
	}*/
	if(pushParentAboveChild){ //can set pushParentAboveChild to 0 as an optimiziation to not do this code
		let diff = dy-repelDist;
		if(diff < 0){
			//child is near same height as parent or above parent.
			//move child down and parent up, so the forest shape is more intuitively displayed.
			en += diff*diff*pushParentAboveChild;
		}
	}
	//TODO optimize, only do this part if edgeType is a kind that exists (have 1 kind that means "noEdge", but use a shorter name?)
	en += dist*farAttractMult; //attract, but weaker than repelDist
	//en += dist*dist*farAttractMult; //attract, but weaker than repelDist
	return en;
};

//These epsilons are meant to be multiplied by the number they're used with, like if distance between 2 voxels is 507.3
//and you want potentialEnergy derivative there, use 507.3 and 507.3*(1+EPSILON) and divide that difference by EPSILON,
//else you will (more often than not, probably) lose more precision than the EPSILON was designed for, compared to 507.3+EPSILON.
//
const EPSILON_FOR_FLOAT = Math.pow(.5,13); //float is exact for all integers in plus/minus 2^24. Browser GPU.js uses floats, unknown if its IEEE754 deterministic.
const EPSILON_FOR_DOUBLE = Math.pow(.5,27); //double is exact for all integers in plus/minus 2^53. Unknown if browser javascript is IEEE754 deterministic.
const EPSILON = EPSILON_FOR_FLOAT; //even though using doubles 2021-7-25, planning to use GPU.js which creates Float32Arrays.

//FIXME rename this to uiNodeDims, cuz augmentedballs is 3d for balls (if you include radius).
//This code copied (and maybe modified todo?) from Wikibinator203DirectedGraphUI.html 2023-5-9+
const dims = 2;

//This code copied (and maybe modified todo?) from Wikibinator203DirectedGraphUI.html 2023-5-9+
//const epsilon = .000001;
const epsilon = EPSILON_FOR_DOUBLE; //FIXME use EPSILON_FOR_FLOAT if use GPU.js/GLSL for those parts.

//This code copied (and maybe modified todo?) from Wikibinator203DirectedGraphUI.html 2023-5-9+
//2023-5-9 theres no dragging in AugmentedBalls2 yet.
var draggingNode = null;

//uinodes (each wrapping a fn/lambda, a rectangle on screen with a few outgoing colored lines to eachother) accelerate by potential-energy gradient,
//as a way of laying out dom nodes on screen, considering their relations to eachother (and todo also considering what user is trying to do,
//seen in state vars in the uinodes, such as is it editable or not).
//This code copied (and maybe modified todo?) from Wikibinator203DirectedGraphUI.html 2023-5-9+
var doUinodePhysics = dt=>{
	//let edges = getEdges();
	let edges = allUiedges();
	for(let edge of edges){ //edges attract and in some cases TODO try to be at certain angles and distances relative to eachother.
		updateUinodeAccelsForEdge(dt,edge);
	}
	for(let i=1; i<nodes.length; i++){ //repel all pairs of nodes if closer than sum of their nodeA.size+nodeB.size
		let ni = nodes[i];
		for(let j=0; j<i; j++){ //all pairs of nodes, excluding self and self, and not again for the reverse pair
			let nj = nodes[j];
			updateUinodeAccelsForRepelPairIfTooClose(dt, ni, nj);
			//updateUinodeAccelsForRepelPairIfTooClose(ni.pos[0], ni.pos[1], ni.size, nj.pos[0], nj.pos[1], nj.size);
		}
	}
	for(let node of nodes){
		//forces between childs of each node (all edge types) such as node.l and node.r
		//but TODO also the other edge types
		updateUinodeAccelsBetweenChildsOfNode(dt,node);
	}
	let minY = 0; //FIXME leave some room at top for textareas of code, buttons, etc.
	let maxY = 1200; //FIXME what should this be?
	let minX = 0;
	let maxX = 900; //FIXME get from screen
	for(let node of nodes){ //dont let nodes get too far from main area of screen.
		let newY = between(minY, node.pos[0], maxY);
		let newX = between(minX, node.pos[1], maxX);
		if(node.pos[0] != newY){
			node.pos[0] = newY;
			node.vel[0] = 0; //if hit a wall, set velocity to 0
		}
		if(node.pos[1] != newX){
			node.pos[1] = newX;
			node.vel[1] = 0; //if hit a wall, set velocity to 0
		}
	}
	let speedMul = between(0,1-dt*speedDecay,1);
	for(let node of nodes){
		for(let d=0; d<dims; d++){
			node.vel[d] += node.accel[d]; //FIXME if put *dt here then dont *dt in updateUinodeAccelsForEdge.
			node.accel[d] = 0;
			node.vel[d] *= speedMul;
			if(draggingNode == node){
				node.vel[d] = 0; //dont move node by physics while mouse is dragging it
			}
			node.pos[d] += dt*node.vel[d];
		}
	}
};

//This code copied (and maybe modified todo?) from Wikibinator203DirectedGraphUI.html 2023-5-9+
var updateUinodeAccelsBetweenChildsOfNode = function(dt,node){
	let halfEpsilon = epsilon/2;
	let l = node.outs.l;
	let r = node.outs.r;
	if(l && r){
		l = l.to; //change from edge to node
		r = r.to;
		let enAtHere = potentialEnergyOfLR(l.pos[0], l.pos[1], l.size, r.pos[0], r.pos[1], r.size);
		let enAtHerePlusDy = potentialEnergyOfLR(l.pos[1]+halfEpsilon, l.pos[1], l.size, r.pos[0]-halfEpsilon, r.pos[1], r.size);
		let enAtHerePlusDx = potentialEnergyOfLR(l.pos[0], l.pos[1]+halfEpsilon, l.size, r.pos[0], r.pos[1]-halfEpsilon, r.size);
		let dEnergyOverDy = (enAtHerePlusDy-enAtHere)/epsilon;
		let dEnergyOverDx = (enAtHerePlusDx-enAtHere)/epsilon;
		let ay = dt*dEnergyOverDy/2; //FIXME is /2 right?
		let ax = dt*dEnergyOverDx/2;
		l.accel[0] -= ay;
		l.accel[1] -= ax;
		r.accel[0] += ay; //FIXME did i get the += and -= backward?
		r.accel[1] += ax;
	}
};

//This code copied (and maybe modified todo?) from Wikibinator203DirectedGraphUI.html 2023-5-9+
var updateUinodeAccelsForRepelPairIfTooClose = function(dt, nodeA, nodeB){
	let epsilon;
	let halfEpsilon;
	let fr = nodeA;
	let to = nodeB;
	let enAtHere;
	let enAtHerePlusDy;
	let enAtHerePlusDx;
	if(options.repelByRectOverlapElseJustDistanceOfTopLeftCorners){ //rects repel
		epsilon = 1; //have to move by at least 1 pixel. FIXME smoother subpixel.
		halfEpsilon = epsilon/2;
		let frHeight = fr.height();
		let frWidth = fr.width();
		let toHeight = to.height();
		let toWidth = to.width();
		enAtHere = potentialEnergyOfPairOfRectsForRepel(fr.pos[0], fr.pos[1], frHeight, frWidth, to.pos[0], to.pos[1], toHeight, toWidth);
		enAtHerePlusDy = potentialEnergyOfPairOfRectsForRepel(fr.pos[0]+halfEpsilon, fr.pos[1],  frHeight, frWidth, to.pos[0]-halfEpsilon, to.pos[1], toHeight, toWidth);
		enAtHerePlusDx = potentialEnergyOfPairOfRectsForRepel(fr.pos[0], fr.pos[1]+halfEpsilon,  frHeight, frWidth, to.pos[0], to.pos[1]-halfEpsilon, toHeight, toWidth);
	}else{ //top left corners repel
		epsilon = EPSILON_FOR_DOUBLE;
		halfEpsilon = epsilon/2;
		enAtHere = potentialEnergyOfPairOfNodesForRepel(fr.pos[0], fr.pos[1], fr.size, to.pos[0], to.pos[1], to.size);
		enAtHerePlusDy = potentialEnergyOfPairOfNodesForRepel(fr.pos[0]+halfEpsilon, fr.pos[1], fr.size, to.pos[0]-halfEpsilon, to.pos[1], to.size);
		enAtHerePlusDx = potentialEnergyOfPairOfNodesForRepel(fr.pos[0], fr.pos[1]+halfEpsilon, fr.size, to.pos[0], to.pos[1]-halfEpsilon, to.size);
	}
	let dEnergyOverDy = (enAtHerePlusDy-enAtHere)/epsilon;
	let dEnergyOverDx = (enAtHerePlusDx-enAtHere)/epsilon;
	let ay = dt*dEnergyOverDy/2; //FIXME is /2 right?
	let ax = dt*dEnergyOverDx/2;
	fr.accel[0] -= ay;
	fr.accel[1] -= ax;
	to.accel[0] += ay; //FIXME did i get the += and -= backward?
	to.accel[1] += ax;


	/*
	let dy = nodeB.pos[0]-nodeA.pos[0];
	let dx = nodeB.pos[1]-nodeA.pos[1];
	let distSq = dy*dy+dx*dx;
	let maxDistToRepel = nodeA.size+nodeB.size;
	let maxDistSqToRepel = maxDistToRepel*maxDistToRepel;
	if(distSq < maxDistToRepel){
		let dist = Math.sqrt(distSq);
		let diff = maxDistToRepel-dist;
		
	}

	let halfEpsilon = epsilon/2;
	*/
};

//dt is change in time (seconds).
//This code copied (and maybe modified todo?) from Wikibinator203DirectedGraphUI.html 2023-5-9+
var updateUinodeAccelsForEdge = function(dt, edge){
	let halfEpsilon = epsilon/2;
	let fr = edge.from;
	let to = edge.to;
	//var potentialEnergyOfEdge = (yFrom, xFrom, sizeFrom, fromType, edgeType, toType, yTo, xTo, sizeTo)=>{
	let enAtHere = potentialEnergyOfEdge(fr.pos[0], fr.pos[1], fr.size, fr.type, edge.type, to.type, to.pos[0], to.pos[1], to.size);
	let enAtHerePlusDy = potentialEnergyOfEdge(fr.pos[0]+halfEpsilon, fr.pos[1], fr.size, fr.type, edge.type, to.type, to.pos[0]-halfEpsilon, to.pos[1], to.size);
	let enAtHerePlusDx = potentialEnergyOfEdge(fr.pos[0], fr.pos[1]+halfEpsilon, fr.size, fr.type, edge.type, to.type, to.pos[0], to.pos[1]-halfEpsilon, to.size);
	let dEnergyOverDy = (enAtHerePlusDy-enAtHere)/epsilon;
	let dEnergyOverDx = (enAtHerePlusDx-enAtHere)/epsilon;
	let ay = dt*dEnergyOverDy/2; //FIXME is /2 right?
	let ax = dt*dEnergyOverDx/2;
	fr.accel[0] -= ay;
	fr.accel[1] -= ax;
	to.accel[0] += ay; //FIXME did i get the += and -= backward?
	to.accel[1] += ax;
};




//var edgeBackgroundOffset_speed = .4;
//var edgeBackgroundOffset_speed = 12;
var edgeBackgroundOffset_speed = 9;


var typeToPic = {
	//TODO ls: which is oftel (R (L x)) for any x, and is other times just (L x),
	//depending how it would normally e displayed in code strings (see "syntax type" syty etc).
	//l: 'pic/greenSawTooth.png', //left child
	l: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAABCAYAAAC/iqxnAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAvSURBVBhXY/wPBAxIYBvDaigLASYxNENZCHD5/GUoCwG+zIMysIBPU6AMFMDAAAAYXQwB1tySVwAAAABJRU5ErkJggg==', //left child. greenSawTooth	 
	//r: 'pic/blueSawTooth.png', //right child
	r: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAABCAIAAAAw6DswAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAfSURBVBhXY/iPBHbuREFJSShIRgYFMTBMx4ZQAQMDAJEWKy2sXIqdAAAAAElFTkSuQmCC', //right child. blueSawTooth
	//s: 'pic/sSawTooth.png', //sCurryList aka {...} syntax. {a b c} means (S (S a b) c) aka {{a b} c}.
	s: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAABCAYAAAC/iqxnAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAAkSURBVBhXY/wPBAx4wLbnclAWYfDg5g8oCzvIdnwNZcEAAwMARRIKAdnLXuQAAAAASUVORK5CYII=', //sCurryList aka {...} syntax. {a b c} means (S (S a b) c) aka {{a b} c}. sSawTooth
	//e: 'pic/redSawTooth.png', //evalsto
	e: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAABCAYAAAC/iqxnAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsIAAA7CARUoSoAAAAArSURBVBhXY/wPBAzIYNcuKAMJLFoEZSDA+aVLoSwEmAKlsYF5UBoVMDAAAM5KCgHwWIFZAAAAAElFTkSuQmCC', //evalsto. redSawTooth
};

//from and to are UINOdes. type is (TODO choose an edge
var UIEdge = function(from, type, to){
	
	//dom object, a div whose background shows direction like saw teeth, and css is used to make it a line at an angle between 2 UINodes.
	this.dob = null;

	this.from = from;
	this.type = type;
	from.outs[type] = this;
	//to.outs[type] = this; //FIXME remove this
	console.log('UIEdge set this.from.outs['+type+'] = this. outs keys = '+Object.keys(this.from.outs));
	this.to = to;
	this.display();
};

var edgeBackgroundOffset = 0;

var displayUiedges = true;
//var displayUiedges = false;

var countUiedgeDisplays = 0;

UIEdge.prototype.display = function(){
	if(!displayUiedges) return;
	countUiedgeDisplays++;
	//console.log('countUiedgeDisplays='+countUiedgeDisplays);
	if(!this.dob){
		let parentDob = mainDiv;
		//let parentDob = document.body;
		//let parentDob = this.from.dob;
		//if(!parentDob) throw 'UINode hasnt displayed yet so cant display edge from it, this='+this;
	
		//this.dob = Dob(parentDob,'div'); //put edge's div it in the div of the UINode its from.
		this.dob = Dob(parentDob,'div');
		this.dob.style.position = cssPositionType;
		//this.dob.style.height = '50px';
		//this.dob.style.width = '13px';
		//this.dob.style.width = '5px';
		//this.dob.style.width = '2px';
		//this.dob.style.height = '154px';
		//TODO css for angle
		//this.dob.style['background-color'] = randColorStr();
		
		
		//this.dob.style.background = 'url('+typeToPic[this.type]+')';
		
		
		//this.dob.style['z-index'] = -1;
	}
	

	
	//https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix
	let diffY = this.to.pos[0]-this.from.pos[0];
	let diffX = this.to.pos[1]-this.from.pos[1];
	let diffLen = Math.hypot(diffY,diffX);
	this.dob.style.height = '2px';
	this.dob.style.width = Math.ceil(diffLen)+'px';
	let normY = between(-1,diffY/diffLen,1);
	let normX = between(-1,diffX/diffLen,1);
	//let angle = Math.asin(normY);
	
	
	let a = normX;
	let b = normY;
	let c = -normY;
	let d = normX;
	
	
	//let a = 1/Math.sqrt(2), b = 0, c = 0, d = 1/Math.sqrt(2);
	//let a = 1, b = 0, c = 0, d = 1;
	//let a = Math.sin(angle), b = Math.cos(angle), c = -Math.cos(angle), d = Math.sin(angle);
	//this.dob.style.width = '90px';
	//let a = -1, b = 0, c = 0, d = -1;
	//let a = 5, b = 0, c = 0, d = 5;
	
	/*let a = 1;
	let b = 2.1;//let b = .3;
	let c = 0; //let c = -.1;
	let d = 1;
	*/
	//let tx = 0;
	//let ty = 0;
	
	//midpoint cuz [style.transform matrix or matrix3d] uses center of dob as (0,0,0) instead of top left corner as usual in html and as usual in opengl and other 3d frameworks.
	//let ty = this.from.pos[0]+diffY/2;
	//let tx = this.from.pos[1]+diffX/2;
	let ty = (this.from.pos[0]+this.to.pos[0])/2;
	let tx = (this.from.pos[1]+this.to.pos[1])/2;
	//let ty = this.from.pos[0];
	//let tx = this.from.pos[1];
	//let ty = this.to.pos[0];
	//let tx = this.to.pos[1];
	tx -= diffLen/2; //without this, it appears to the right of where it should be, in some strange coordinate system that rotates around the middle of a div, or something.
	
	
	//a = diffY*.01;
	//d = diffX*.01;
	
	//if(this.type == 'l'){ ty += 20; tx += 20; }
	//if(this.type == 'r'){ ty += 35; tx += 35; }
	//if(this.type == 'e'){ ty += 50; tx += 50; }
	this.dob.style.transform = 'matrix('+a+','+b+','+c+','+d+','+tx+','+ty+')';
	//this.dob.style.transform = 'matrix3d('+a+','+b+',0,0,  '+c+','+d+',0,0,  0,0,1,0,  '+tx+','+ty+',0,1)';
	
	//this.dob.style['background-position'] = Math.floor(edgeBackgroundOffset)+'px';
	this.dob.style.background = 'url('+typeToPic[this.type]+') '+edgeBackgroundOffset+'px center';

	//this.dob.style.zIndex = (++lastZIndex);
	this.dob.style['z-index'] = (++lastZIndex)+1000000; //FIXME
	
};




</script>
<script>

//TODO replace this with some tiny code similar to chatgptWebcamTest2023_4_26_225pEST.html cuz webcamjs was made long ago
//in the days of Flash when webcams barely worked in browser and has lots of special cases and may be causing incompatibility with recent browsers.

//webcamjs_mitLicense_1.0.24.js from https://raw.githubusercontent.com/benrayfield/jsutils/master/src/arvox/webcamjs_mitLicense_1.0.24.js



// WebcamJS v1.0.24
// Webcam library for capturing JPEG/PNG images in JavaScript
// Attempts getUserMedia, falls back to Flash
// Author: Joseph Huckaby: http://github.com/jhuckaby
// Based on JPEGCam: http://code.google.com/p/jpegcam/
// Copyright (c) 2012 - 2017 Joseph Huckaby
// Licensed under the MIT License

(function(window) {
var _userMedia;

// declare error types

// inheritance pattern here:
// https://stackoverflow.com/questions/783818/how-do-i-create-a-custom-error-in-javascript
function FlashError() {
	var temp = Error.apply(this, arguments);
	temp.nam = this.nam = "FlashError";
	this.stack = temp.stack;
	this.message = temp.message;
}

function WebcamError() {
	var temp = Error.apply(this, arguments);
	temp.nam = this.nam = "WebcamError";
	this.stack = temp.stack;
	this.message = temp.message;
}

IntermediateInheritor = function() {};
IntermediateInheritor.prototype = Error.prototype;

FlashError.prototype = new IntermediateInheritor();
WebcamError.prototype = new IntermediateInheritor();

var Webcam = {
	version: '1.0.24',
	
	// globals
	protocol: location.protocol.match(/https/i) ? 'https' : 'http',
	loaded: false,   // true when webcam movie finishes loading
	live: false,     // true when webcam is initialized and ready to snap
	userMedia: true, // true when getUserMedia is supported natively

	iOS: /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream,

	params: {
		width: 0,
		height: 0,
		dest_width: 0,         // size of captured image
		dest_height: 0,        // these default to width/height
		image_format: 'jpeg',  // image format (may be jpeg or png)
		jpeg_quality: 90,      // jpeg image quality from 0 (worst) to 100 (best)
		enable_flash: true,    // enable flash fallback,
		force_flash: false,    // force flash mode,
		flip_horiz: false,     // flip image horiz (mirror mode)
		fps: 30,               // camera frames per second
		upload_name: 'webcam', // name of file in upload post data
		constraints: null,     // custom user media constraints,
		swfURL: '',            // URI to webcam.swf movie (defaults to the js location)
		flashNotDetectedText: 'ERROR: No Adobe Flash Player detected.  Webcam.js relies on Flash for browsers that do not support getUserMedia (like yours).',
		noInterfaceFoundText: 'No supported webcam interface found.',
		unfreeze_snap: true,    // Whether to unfreeze the camera after snap (defaults to true)
		iosPlaceholderText: 'Click here to open camera.',
		user_callback: null,    // callback function for snapshot (used if no user_callback parameter given to snap function)
		user_canvas: null       // user provided canvas for snapshot (used if no user_canvas parameter given to snap function)
	},

	errors: {
		FlashError: FlashError,
		WebcamError: WebcamError
	},
	
	hooks: {}, // callback hook functions
	
	init: function() {
		// initialize, check for getUserMedia support
		var self = this;
		
		// Setup getUserMedia, with polyfill for older browsers
		// Adapted from: https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia
		this.mediaDevices = (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ? 
			navigator.mediaDevices : ((navigator.mozGetUserMedia || navigator.webkitGetUserMedia) ? {
				getUserMedia: function(c) {
					return new Promise(function(y, n) {
						(navigator.mozGetUserMedia ||
						navigator.webkitGetUserMedia).call(navigator, c, y, n);
					});
				}
		} : null);
		
		window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL;
		this.userMedia = this.userMedia && !!this.mediaDevices && !!window.URL;
		
		if (this.iOS) {
			this.userMedia = null;
		}
		
		// Older versions of firefox (< 21) apparently claim support but user media does not actually work
		if (navigator.userAgent.match(/Firefox\D+(\d+)/)) {
			if (parseInt(RegExp.$1, 10) < 21) this.userMedia = null;
		}
		
		// Make sure media stream is closed when navigating away from page
		if (this.userMedia) {
			window.addEventListener( 'beforeunload', function(event) {
				self.reset();
			} );
		}
	},
	
	exifOrientation: function(binFile) {
		// extract orientation information from the image provided by iOS
		// algorithm based on exif-js
		var dataView = new DataView(binFile);
		if ((dataView.getUint8(0) != 0xFF) || (dataView.getUint8(1) != 0xD8)) {
			console.log('Not a valid JPEG file');
			return 0;
		}
		var offset = 2;
		var marker = null;
		while (offset < binFile.byteLength) {
			// find 0xFFE1 (225 marker)
			if (dataView.getUint8(offset) != 0xFF) {
				console.log('Not a valid marker at offset ' + offset + ', found: ' + dataView.getUint8(offset));
				return 0;
			}
			marker = dataView.getUint8(offset + 1);
			if (marker == 225) {
				offset += 4;
				var str = "";
				for (n = 0; n < 4; n++) {
					str += String.fromCharCode(dataView.getUint8(offset+n));
				}
				if (str != 'Exif') {
					console.log('Not valid EXIF data found');
					return 0;
				}
				
				offset += 6; // tiffOffset
				var bigEnd = null;

				// test for TIFF validity and endianness
				if (dataView.getUint16(offset) == 0x4949) {
					bigEnd = false;
				} else if (dataView.getUint16(offset) == 0x4D4D) {
					bigEnd = true;
				} else {
					console.log("Not valid TIFF data! (no 0x4949 or 0x4D4D)");
					return 0;
				}

				if (dataView.getUint16(offset+2, !bigEnd) != 0x002A) {
					console.log("Not valid TIFF data! (no 0x002A)");
					return 0;
				}

				var firstIFDOffset = dataView.getUint32(offset+4, !bigEnd);
				if (firstIFDOffset < 0x00000008) {
					console.log("Not valid TIFF data! (First offset less than 8)", dataView.getUint32(offset+4, !bigEnd));
					return 0;
				}

				// extract orientation data
				var dataStart = offset + firstIFDOffset;
				var entries = dataView.getUint16(dataStart, !bigEnd);
				for (var i=0; i<entries; i++) {
					var entryOffset = dataStart + i*12 + 2;
					if (dataView.getUint16(entryOffset, !bigEnd) == 0x0112) {
						var valueType = dataView.getUint16(entryOffset+2, !bigEnd);
						var numValues = dataView.getUint32(entryOffset+4, !bigEnd);
						if (valueType != 3 && numValues != 1) {
							console.log('Invalid EXIF orientation value type ('+valueType+') or count ('+numValues+')');
							return 0;
						}
						var value = dataView.getUint16(entryOffset + 8, !bigEnd);
						if (value < 1 || value > 8) {
							console.log('Invalid EXIF orientation value ('+value+')');
							return 0;
						}
						return value;
					}
				}
			} else {
				offset += 2+dataView.getUint16(offset+2);
			}
		}
		return 0;
	},
	
	fixOrientation: function(origObjURL, orientation, targetImg) {
		// fix image orientation based on exif orientation data
		// exif orientation information
		//    http://www.impulseadventure.com/photo/exif-orientation.html
		//    link source wikipedia (https://en.wikipedia.org/wiki/Exif#cite_note-20)
		var img = new Image();
		img.addEventListener('load', function(event) {
			var canvas = document.createElement('canvas');
			var ctx = canvas.getContext('2d');
			
			// switch width height if orientation needed
			if (orientation < 5) {
				canvas.width = img.width;
				canvas.height = img.height;
			} else {
				canvas.width = img.height;
				canvas.height = img.width;
			}

			// transform (rotate) image - see link at beginning this method
			switch (orientation) {
				case 2: ctx.transform(-1, 0, 0, 1, img.width, 0); break;
				case 3: ctx.transform(-1, 0, 0, -1, img.width, img.height); break;
				case 4: ctx.transform(1, 0, 0, -1, 0, img.height); break;
				case 5: ctx.transform(0, 1, 1, 0, 0, 0); break;
				case 6: ctx.transform(0, 1, -1, 0, img.height , 0); break;
				case 7: ctx.transform(0, -1, -1, 0, img.height, img.width); break;
				case 8: ctx.transform(0, -1, 1, 0, 0, img.width); break;
			}

			ctx.drawImage(img, 0, 0);
			// pass rotated image data to the target image container
			targetImg.src = canvas.toDataURL();
		}, false);
		// start transformation by load event
		img.src = origObjURL;
	},
	
	attach: function(elem) {
		// create webcam preview and attach to DOM element
		// pass in actual DOM reference, ID, or CSS selector
		if (typeof(elem) == 'string') {
			elem = document.getElementById(elem) || document.querySelector(elem);
		}
		if (!elem) {
			return this.dispatch('error', new WebcamError("Could not locate DOM element to attach to."));
		}
		this.container = elem;
		elem.innerHTML = ''; // start with empty element
		
		// insert "peg" so we can insert our preview canvas adjacent to it later on
		var peg = document.createElement('div');
		elem.appendChild( peg );
		this.peg = peg;
		
		// set width/height if not already set
		if (!this.params.width) this.params.width = elem.offsetWidth;
		if (!this.params.height) this.params.height = elem.offsetHeight;
		
		// make sure we have a nonzero width and height at this point
		if (!this.params.width || !this.params.height) {
			return this.dispatch('error', new WebcamError("No width and/or height for webcam.  Please call set() first, or attach to a visible element."));
		}
		
		// set defaults for dest_width / dest_height if not set
		if (!this.params.dest_width) this.params.dest_width = this.params.width;
		if (!this.params.dest_height) this.params.dest_height = this.params.height;
		
		this.userMedia = _userMedia === undefined ? this.userMedia : _userMedia;
		// if force_flash is set, disable userMedia
		if (this.params.force_flash) {
			_userMedia = this.userMedia;
			this.userMedia = null;
		}
		
		// check for default fps
		if (typeof this.params.fps !== "number") this.params.fps = 30;

		// adjust scale if dest_width or dest_height is different
		var scaleX = this.params.width / this.params.dest_width;
		var scaleY = this.params.height / this.params.dest_height;
		
		if (this.userMedia) {
			// setup webcam video container
			var video = document.createElement('video');
			video.setAttribute('autoplay', 'autoplay');
			video.style.width = '' + this.params.dest_width + 'px';
			video.style.height = '' + this.params.dest_height + 'px';
			
			if ((scaleX != 1.0) || (scaleY != 1.0)) {
				elem.style.overflow = 'hidden';
				video.style.webkitTransformOrigin = '0px 0px';
				video.style.mozTransformOrigin = '0px 0px';
				video.style.msTransformOrigin = '0px 0px';
				video.style.oTransformOrigin = '0px 0px';
				video.style.transformOrigin = '0px 0px';
				video.style.webkitTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.mozTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.msTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.oTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
				video.style.transform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			}
			
			// add video element to dom
			elem.appendChild( video );
			this.video = video;
			
			// ask user for access to their camera
			var self = this;
			this.mediaDevices.getUserMedia({
				"audio": false,
				"video": this.params.constraints || {
					mandatory: {
						minWidth: this.params.dest_width,
						minHeight: this.params.dest_height
					}
				}
			})
			.then( function(stream) {
				// got access, attach stream to video
				video.onloadedmetadata = function(e) {
					self.stream = stream;
					self.loaded = true;
					self.live = true;
					self.dispatch('load');
					self.dispatch('live');
					self.flip();
				};
				// as window.URL.createObjectURL() is deprecated, adding a check so that it works in Safari.
				// older browsers may not have srcObject
				if ("srcObject" in video) {
				  	video.srcObject = stream;
				}
				else {
				  	// using URL.createObjectURL() as fallback for old browsers
				  	video.src = window.URL.createObjectURL(stream);
				}
			})
			.catch( function(err) {
				// JH 2016-07-31 Instead of dispatching error, now falling back to Flash if userMedia fails (thx @john2014)
				// JH 2016-08-07 But only if flash is actually installed -- if not, dispatch error here and now.
				if (self.params.enable_flash && self.detectFlash()) {
					setTimeout( function() { self.params.force_flash = 1; self.attach(elem); }, 1 );
				}
				else {
					self.dispatch('error', err);
				}
			});
		}
		else if (this.iOS) {
			// prepare HTML elements
			var div = document.createElement('div');
			div.id = this.container.id+'-ios_div';
			div.className = 'webcamjs-ios-placeholder';
			div.style.width = '' + this.params.width + 'px';
			div.style.height = '' + this.params.height + 'px';
			div.style.textAlign = 'center';
			div.style.display = 'table-cell';
			div.style.verticalAlign = 'middle';
			div.style.backgroundRepeat = 'no-repeat';
			div.style.backgroundSize = 'contain';
			div.style.backgroundPosition = 'center';
			var span = document.createElement('span');
			span.className = 'webcamjs-ios-text';
			span.innerHTML = this.params.iosPlaceholderText;
			div.appendChild(span);
			var img = document.createElement('img');
			img.id = this.container.id+'-ios_img';
			img.style.width = '' + this.params.dest_width + 'px';
			img.style.height = '' + this.params.dest_height + 'px';
			img.style.display = 'none';
			div.appendChild(img);
			var input = document.createElement('input');
			input.id = this.container.id+'-ios_input';
			input.setAttribute('type', 'file');
			input.setAttribute('accept', 'image/*');
			input.setAttribute('capture', 'camera');
			
			var self = this;
			var params = this.params;
			// add input listener to load the selected image
			input.addEventListener('change', function(event) {
				if (event.target.files.length > 0 && event.target.files[0].type.indexOf('image/') == 0) {
					var objURL = URL.createObjectURL(event.target.files[0]);

					// load image with auto scale and crop
					var image = new Image();
					image.addEventListener('load', function(event) {
						var canvas = document.createElement('canvas');
						canvas.width = params.dest_width;
						canvas.height = params.dest_height;
						var ctx = canvas.getContext('2d');

						// crop and scale image for final size
						ratio = Math.min(image.width / params.dest_width, image.height / params.dest_height);
						var sw = params.dest_width * ratio;
						var sh = params.dest_height * ratio;
						var sx = (image.width - sw) / 2;
						var sy = (image.height - sh) / 2;
						ctx.drawImage(image, sx, sy, sw, sh, 0, 0, params.dest_width, params.dest_height);

						var dataURL = canvas.toDataURL();
						img.src = dataURL;
						div.style.backgroundImage = "url('"+dataURL+"')";
					}, false);
					
					// read EXIF data
					var fileReader = new FileReader();
					fileReader.addEventListener('load', function(e) {
						var orientation = self.exifOrientation(e.target.result);
						if (orientation > 1) {
							// image need to rotate (see comments on fixOrientation method for more information)
							// transform image and load to image object
							self.fixOrientation(objURL, orientation, image);
						} else {
							// load image data to image object
							image.src = objURL;
						}
					}, false);
					
					// Convert image data to blob format
					var http = new XMLHttpRequest();
					http.open("GET", objURL, true);
					http.responseType = "blob";
					http.onload = function(e) {
						if (this.status == 200 || this.status === 0) {
							fileReader.readAsArrayBuffer(this.response);
						}
					};
					http.send();

				}
			}, false);
			input.style.display = 'none';
			elem.appendChild(input);
			// make div clickable for open camera interface
			div.addEventListener('click', function(event) {
				if (params.user_callback) {
					// global user_callback defined - create the snapshot
					self.snap(params.user_callback, params.user_canvas);
				} else {
					// no global callback definied for snapshot, load image and wait for external snap method call
					input.style.display = 'block';
					input.focus();
					input.click();
					input.style.display = 'none';
				}
			}, false);
			elem.appendChild(div);
			this.loaded = true;
			this.live = true;
		}
		else if (this.params.enable_flash && this.detectFlash()) {
			// flash fallback
			window.Webcam = Webcam; // needed for flash-to-js interface
			var div = document.createElement('div');
			div.innerHTML = this.getSWFHTML();
			elem.appendChild( div );
		}
		else {
			this.dispatch('error', new WebcamError( this.params.noInterfaceFoundText ));
		}
		
		// setup final crop for live preview
		if (this.params.crop_width && this.params.crop_height) {
			var scaled_crop_width = Math.floor( this.params.crop_width * scaleX );
			var scaled_crop_height = Math.floor( this.params.crop_height * scaleY );
			
			elem.style.width = '' + scaled_crop_width + 'px';
			elem.style.height = '' + scaled_crop_height + 'px';
			elem.style.overflow = 'hidden';
			
			elem.scrollLeft = Math.floor( (this.params.width / 2) - (scaled_crop_width / 2) );
			elem.scrollTop = Math.floor( (this.params.height / 2) - (scaled_crop_height / 2) );
		}
		else {
			// no crop, set size to desired
			elem.style.width = '' + this.params.width + 'px';
			elem.style.height = '' + this.params.height + 'px';
		}
	},
	
	reset: function() {
		// shutdown camera, reset to potentially attach again
		if (this.preview_active) this.unfreeze();
		
		// attempt to fix issue #64
		this.unflip();
		
		if (this.userMedia) {
			if (this.stream) {
				if (this.stream.getVideoTracks) {
					// get video track to call stop on it
					var tracks = this.stream.getVideoTracks();
					if (tracks && tracks[0] && tracks[0].stop) tracks[0].stop();
				}
				else if (this.stream.stop) {
					// deprecated, may be removed in future
					this.stream.stop();
				}
			}
			delete this.stream;
			delete this.video;
		}

		if ((this.userMedia !== true) && this.loaded && !this.iOS) {
			// call for turn off camera in flash
			var movie = this.getMovie();
			if (movie && movie._releaseCamera) movie._releaseCamera();
		}

		if (this.container) {
			this.container.innerHTML = '';
			delete this.container;
		}
	
		this.loaded = false;
		this.live = false;
	},
	
	set: function() {
		// set one or more params
		// variable argument list: 1 param = hash, 2 params = key, value
		if (arguments.length == 1) {
			for (var key in arguments[0]) {
				this.params[key] = arguments[0][key];
			}
		}
		else {
			this.params[ arguments[0] ] = arguments[1];
		}
	},
	
	on: function(name, callback) {
		// set callback hook
		name = name.replace(/^on/i, '').toLowerCase();
		if (!this.hooks[name]) this.hooks[name] = [];
		this.hooks[name].push( callback );
	},
	
	off: function(name, callback) {
		// remove callback hook
		name = name.replace(/^on/i, '').toLowerCase();
		if (this.hooks[name]) {
			if (callback) {
				// remove one selected callback from list
				var idx = this.hooks[name].indexOf(callback);
				if (idx > -1) this.hooks[name].splice(idx, 1);
			}
			else {
				// no callback specified, so clear all
				this.hooks[name] = [];
			}
		}
	},
	
	dispatch: function() {
		// fire hook callback, passing optional value to it
		var name = arguments[0].replace(/^on/i, '').toLowerCase();
		var args = Array.prototype.slice.call(arguments, 1);
		
		if (this.hooks[name] && this.hooks[name].length) {
			for (var idx = 0, len = this.hooks[name].length; idx < len; idx++) {
				var hook = this.hooks[name][idx];
				
				if (typeof(hook) == 'function') {
					// callback is function reference, call directly
					hook.apply(this, args);
				}
				else if ((typeof(hook) == 'object') && (hook.length == 2)) {
					// callback is PHP-style object instance method
					hook[0][hook[1]].apply(hook[0], args);
				}
				else if (window[hook]) {
					// callback is global function name
					window[ hook ].apply(window, args);
				}
			} // loop
			return true;
		}
		else if (name == 'error') {
			if ((args[0] instanceof FlashError) || (args[0] instanceof WebcamError)) {
				message = args[0].message;
			} else {
				message = "Could not access webcam: " + args[0].nam + ": " + 
					args[0].message + " " + args[0].toString();
			}

			// default error handler if no custom one specified
			alert("Webcam.js Error: " + message);
		}
		
		return false; // no hook defined
	},

	setSWFLocation: function(value) {
		// for backward compatibility.
		this.set('swfURL', value);
	},
	
	detectFlash: function() {
		// return true if browser supports flash, false otherwise
		// Code snippet borrowed from: https://github.com/swfobject/swfobject
		var SHOCKWAVE_FLASH = "Shockwave Flash",
			SHOCKWAVE_FLASH_AX = "ShockwaveFlash.ShockwaveFlash",
        	FLASH_MIME_TYPE = "application/x-shockwave-flash",
        	win = window,
        	nav = navigator,
        	hasFlash = false;
        
        if (typeof nav.plugins !== "undefined" && typeof nav.plugins[SHOCKWAVE_FLASH] === "object") {
        	var desc = nav.plugins[SHOCKWAVE_FLASH].description;
        	if (desc && (typeof nav.mimeTypes !== "undefined" && nav.mimeTypes[FLASH_MIME_TYPE] && nav.mimeTypes[FLASH_MIME_TYPE].enabledPlugin)) {
        		hasFlash = true;
        	}
        }
        else if (typeof win.ActiveXObject !== "undefined") {
        	try {
        		var ax = new ActiveXObject(SHOCKWAVE_FLASH_AX);
        		if (ax) {
        			var ver = ax.GetVariable("$version");
        			if (ver) hasFlash = true;
        		}
        	}
        	catch (e) {;}
        }
        
        return hasFlash;
	},
	
	getSWFHTML: function() {
		// Return HTML for embedding flash based webcam capture movie		
		var html = '',
			swfURL = this.params.swfURL;
		
		// make sure we aren't running locally (flash doesn't work)
		if (location.protocol.match(/file/)) {
			this.dispatch('error', new FlashError("Flash does not work from local disk.  Please run from a web server."));
			return '<h3 style="color:red">ERROR: the Webcam.js Flash fallback does not work from local disk.  Please run it from a web server.</h3>';
		}
		
		// make sure we have flash
		if (!this.detectFlash()) {
			this.dispatch('error', new FlashError("Adobe Flash Player not found.  Please install from get.adobe.com/flashplayer and try again."));
			return '<h3 style="color:red">' + this.params.flashNotDetectedText + '</h3>';
		}
		
		// set default swfURL if not explicitly set
		if (!swfURL) {
			// find our script tag, and use that base URL
			var base_url = '';
			var scpts = document.getElementsByTagName('script');
			for (var idx = 0, len = scpts.length; idx < len; idx++) {
				var src = scpts[idx].getAttribute('src');
				if (src && src.match(/\/webcam(\.min)?\.js/)) {
					base_url = src.replace(/\/webcam(\.min)?\.js.*$/, '');
					idx = len;
				}
			}
			if (base_url) swfURL = base_url + '/webcam.swf';
			else swfURL = 'webcam.swf';
		}
		
		// if this is the user's first visit, set flashvar so flash privacy settings panel is shown first
		if (window.localStorage && !localStorage.getItem('visited')) {
			this.params.new_user = 1;
			localStorage.setItem('visited', 1);
		}
		
		// construct flashvars string
		var flashvars = '';
		for (var key in this.params) {
			if (flashvars) flashvars += '&';
			flashvars += key + '=' + escape(this.params[key]);
		}
		
		// construct object/embed tag
		html += '<object classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000" type="application/x-shockwave-flash" codebase="'+this.protocol+'://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,0,0" width="'+this.params.width+'" height="'+this.params.height+'" id="webcam_movie_obj" align="middle"><param name="wmode" value="opaque" /><param name="allowScriptAccess" value="always" /><param name="allowFullScreen" value="false" /><param name="movie" value="'+swfURL+'" /><param name="loop" value="false" /><param name="menu" value="false" /><param name="quality" value="best" /><param name="bgcolor" value="#ffffff" /><param name="flashvars" value="'+flashvars+'"/><embed id="webcam_movie_embed" src="'+swfURL+'" wmode="opaque" loop="false" menu="false" quality="best" bgcolor="#ffffff" width="'+this.params.width+'" height="'+this.params.height+'" name="webcam_movie_embed" align="middle" allowScriptAccess="always" allowFullScreen="false" type="application/x-shockwave-flash" pluginspage="http://www.macromedia.com/go/getflashplayer" flashvars="'+flashvars+'"></embed></object>';
		
		return html;
	},
	
	getMovie: function() {
		// get reference to movie object/embed in DOM
		if (!this.loaded) return this.dispatch('error', new FlashError("Flash Movie is not loaded yet"));
		var movie = document.getElementById('webcam_movie_obj');
		if (!movie || !movie._snap) movie = document.getElementById('webcam_movie_embed');
		if (!movie) this.dispatch('error', new FlashError("Cannot locate Flash movie in DOM"));
		return movie;
	},
	
	freeze: function() {
		// show preview, freeze camera
		var self = this;
		var params = this.params;
		
		// kill preview if already active
		if (this.preview_active) this.unfreeze();
		
		// determine scale factor
		var scaleX = this.params.width / this.params.dest_width;
		var scaleY = this.params.height / this.params.dest_height;
		
		// must unflip container as preview canvas will be pre-flipped
		this.unflip();
		
		// calc final size of image
		var final_width = params.crop_width || params.dest_width;
		var final_height = params.crop_height || params.dest_height;
		
		// create canvas for holding preview
		var preview_canvas = document.createElement('canvas');
		preview_canvas.width = final_width;
		preview_canvas.height = final_height;
		var preview_context = preview_canvas.getContext('2d');
		
		// save for later use
		this.preview_canvas = preview_canvas;
		this.preview_context = preview_context;
		
		// scale for preview size
		if ((scaleX != 1.0) || (scaleY != 1.0)) {
			preview_canvas.style.webkitTransformOrigin = '0px 0px';
			preview_canvas.style.mozTransformOrigin = '0px 0px';
			preview_canvas.style.msTransformOrigin = '0px 0px';
			preview_canvas.style.oTransformOrigin = '0px 0px';
			preview_canvas.style.transformOrigin = '0px 0px';
			preview_canvas.style.webkitTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.mozTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.msTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.oTransform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
			preview_canvas.style.transform = 'scaleX('+scaleX+') scaleY('+scaleY+')';
		}
		
		// take snapshot, but fire our own callback
		this.snap( function() {
			// add preview image to dom, adjust for crop
			preview_canvas.style.position = 'relative';
			preview_canvas.style.left = '' + self.container.scrollLeft + 'px';
			preview_canvas.style.top = '' + self.container.scrollTop + 'px';
			
			self.container.insertBefore( preview_canvas, self.peg );
			self.container.style.overflow = 'hidden';
			
			// set flag for user capture (use preview)
			self.preview_active = true;
			
		}, preview_canvas );
	},
	
	unfreeze: function() {
		// cancel preview and resume live video feed
		if (this.preview_active) {
			// remove preview canvas
			this.container.removeChild( this.preview_canvas );
			delete this.preview_context;
			delete this.preview_canvas;
			
			// unflag
			this.preview_active = false;
			
			// re-flip if we unflipped before
			this.flip();
		}
	},
	
	flip: function() {
		// flip container horiz (mirror mode) if desired
		if (this.params.flip_horiz) {
			var sty = this.container.style;
			sty.webkitTransform = 'scaleX(-1)';
			sty.mozTransform = 'scaleX(-1)';
			sty.msTransform = 'scaleX(-1)';
			sty.oTransform = 'scaleX(-1)';
			sty.transform = 'scaleX(-1)';
			sty.filter = 'FlipH';
			sty.msFilter = 'FlipH';
		}
	},
	
	unflip: function() {
		// unflip container horiz (mirror mode) if desired
		if (this.params.flip_horiz) {
			var sty = this.container.style;
			sty.webkitTransform = 'scaleX(1)';
			sty.mozTransform = 'scaleX(1)';
			sty.msTransform = 'scaleX(1)';
			sty.oTransform = 'scaleX(1)';
			sty.transform = 'scaleX(1)';
			sty.filter = '';
			sty.msFilter = '';
		}
	},
	
	savePreview: function(user_callback, user_canvas) {
		// save preview freeze and fire user callback
		var params = this.params;
		var canvas = this.preview_canvas;
		var context = this.preview_context;
		
		// render to user canvas if desired
		if (user_canvas) {
			var user_context = user_canvas.getContext('2d');
			user_context.drawImage( canvas, 0, 0 );
		}
		
		// fire user callback if desired
		user_callback(
			user_canvas ? null : canvas.toDataURL('image/' + params.image_format, params.jpeg_quality / 100 ),
			canvas,
			context
		);
		
		// remove preview
		if (this.params.unfreeze_snap) this.unfreeze();
	},
	
	snap: function(user_callback, user_canvas) {
		// use global callback and canvas if not defined as parameter
		if (!user_callback) user_callback = this.params.user_callback;
		if (!user_canvas) user_canvas = this.params.user_canvas;
		
		// take snapshot and return image data uri
		var self = this;
		var params = this.params;
		
		if (!this.loaded) return this.dispatch('error', new WebcamError("Webcam is not loaded yet"));
		// if (!this.live) return this.dispatch('error', new WebcamError("Webcam is not live yet"));
		if (!user_callback) return this.dispatch('error', new WebcamError("Please provide a callback function or canvas to snap()"));
		
		// if we have an active preview freeze, use that
		if (this.preview_active) {
			this.savePreview( user_callback, user_canvas );
			return null;
		}
		
		// create offscreen canvas element to hold pixels
		var canvas = document.createElement('canvas');
		canvas.width = this.params.dest_width;
		canvas.height = this.params.dest_height;
		var context = canvas.getContext('2d');
		
		// flip canvas horizontally if desired
		if (this.params.flip_horiz) {
			context.translate( params.dest_width, 0 );
			context.scale( -1, 1 );
		}
		
		// create inline function, called after image load (flash) or immediately (native)
		var func = function() {
			// render image if needed (flash)
			if (this.src && this.width && this.height) {
				context.drawImage(this, 0, 0, params.dest_width, params.dest_height);
			}
			
			// crop if desired
			if (params.crop_width && params.crop_height) {
				var crop_canvas = document.createElement('canvas');
				crop_canvas.width = params.crop_width;
				crop_canvas.height = params.crop_height;
				var crop_context = crop_canvas.getContext('2d');
				
				crop_context.drawImage( canvas, 
					Math.floor( (params.dest_width / 2) - (params.crop_width / 2) ),
					Math.floor( (params.dest_height / 2) - (params.crop_height / 2) ),
					params.crop_width,
					params.crop_height,
					0,
					0,
					params.crop_width,
					params.crop_height
				);
				
				// swap canvases
				context = crop_context;
				canvas = crop_canvas;
			}
			
			// render to user canvas if desired
			if (user_canvas) {
				var user_context = user_canvas.getContext('2d');
				user_context.drawImage( canvas, 0, 0 );
			}
			
			// fire user callback if desired
			user_callback(
				user_canvas ? null : canvas.toDataURL('image/' + params.image_format, params.jpeg_quality / 100 ),
				canvas,
				context
			);
		};
		
		// grab image frame from userMedia or flash movie
		if (this.userMedia) {
			// native implementation
			context.drawImage(this.video, 0, 0, this.params.dest_width, this.params.dest_height);
			
			// fire callback right away
			func();
		}
		else if (this.iOS) {
			var div = document.getElementById(this.container.id+'-ios_div');
			var img = document.getElementById(this.container.id+'-ios_img');
			var input = document.getElementById(this.container.id+'-ios_input');
			// function for handle snapshot event (call user_callback and reset the interface)
			iFunc = function(event) {
				func.call(img);
				img.removeEventListener('load', iFunc);
				div.style.backgroundImage = 'none';
				img.removeAttribute('src');
				input.value = null;
			};
			if (!input.value) {
				// No image selected yet, activate input field
				img.addEventListener('load', iFunc);
				input.style.display = 'block';
				input.focus();
				input.click();
				input.style.display = 'none';
			} else {
				// Image already selected
				iFunc(null);
			}			
		}
		else {
			// flash fallback
			var raw_data = this.getMovie()._snap();
			
			// render to image, fire callback when complete
			var img = new Image();
			img.onload = func;
			img.src = 'data:image/'+this.params.image_format+';base64,' + raw_data;
		}
		
		return null;
	},
	
	configure: function(panel) {
		// open flash configuration panel -- specify tab name:
		// "camera", "privacy", "default", "localStorage", "microphone", "settingsManager"
		if (!panel) panel = "camera";
		this.getMovie()._configure(panel);
	},
	
	flashNotify: function(type, msg) {
		// receive notification from flash about event
		switch (type) {
			case 'flashLoadComplete':
				// movie loaded successfully
				this.loaded = true;
				this.dispatch('load');
				break;
			
			case 'cameraLive':
				// camera is live and ready to snap
				this.live = true;
				this.dispatch('live');
				break;

			case 'error':
				// Flash error
				this.dispatch('error', new FlashError(msg));
				break;

			default:
				// catch-all event, just in case
				// console.log("webcam flash_notify: " + type + ": " + msg);
				break;
		}
	},
	
	b64ToUint6: function(nChr) {
		// convert base64 encoded character to 6-bit integer
		// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
		return nChr > 64 && nChr < 91 ? nChr - 65
			: nChr > 96 && nChr < 123 ? nChr - 71
			: nChr > 47 && nChr < 58 ? nChr + 4
			: nChr === 43 ? 62 : nChr === 47 ? 63 : 0;
	},

	base64DecToArr: function(sBase64, nBlocksSize) {
		// convert base64 encoded string to Uintarray
		// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Base64_encoding_and_decoding
		var sB64Enc = sBase64.replace(/[^A-Za-z0-9\+\/]/g, ""), nInLen = sB64Enc.length,
			nOutLen = nBlocksSize ? Math.ceil((nInLen * 3 + 1 >> 2) / nBlocksSize) * nBlocksSize : nInLen * 3 + 1 >> 2, 
			taBytes = new Uint8Array(nOutLen);
		
		for (var nMod3, nMod4, nUint24 = 0, nOutIdx = 0, nInIdx = 0; nInIdx < nInLen; nInIdx++) {
			nMod4 = nInIdx & 3;
			nUint24 |= this.b64ToUint6(sB64Enc.charCodeAt(nInIdx)) << 18 - 6 * nMod4;
			if (nMod4 === 3 || nInLen - nInIdx === 1) {
				for (nMod3 = 0; nMod3 < 3 && nOutIdx < nOutLen; nMod3++, nOutIdx++) {
					taBytes[nOutIdx] = nUint24 >>> (16 >>> nMod3 & 24) & 255;
				}
				nUint24 = 0;
			}
		}
		return taBytes;
	},
	
	upload: function(image_data_uri, target_url, callback) {
		// submit image data to server using binary AJAX
		var form_elem_name = this.params.upload_name || 'webcam';
		
		// detect image format from within image_data_uri
		var image_fmt = '';
		if (image_data_uri.match(/^data\:image\/(\w+)/))
			image_fmt = RegExp.$1;
		else
			throw "Cannot locate image format in Data URI";
		
		// extract raw base64 data from Data URI
		var raw_image_data = image_data_uri.replace(/^data\:image\/\w+\;base64\,/, '');
		
		// contruct use AJAX object
		var http = new XMLHttpRequest();
		http.open("POST", target_url, true);
		
		// setup progress events
		if (http.upload && http.upload.addEventListener) {
			http.upload.addEventListener( 'progress', function(e) {
				if (e.lengthComputable) {
					var progress = e.loaded / e.total;
					Webcam.dispatch('uploadProgress', progress, e);
				}
			}, false );
		}
		
		// completion handler
		var self = this;
		http.onload = function() {
			if (callback) callback.apply( self, [http.status, http.responseText, http.statusText] );
			Webcam.dispatch('uploadComplete', http.status, http.responseText, http.statusText);
		};
		
		// create a blob and decode our base64 to binary
		var blob = new Blob( [ this.base64DecToArr(raw_image_data) ], {type: 'image/'+image_fmt} );
		
		// stuff into a form, so servers can easily receive it as a standard file upload
		var form = new FormData();
		form.append( form_elem_name, blob, form_elem_name+"."+image_fmt.replace(/e/, '') );
		
		// send data to server
		http.send(form);
	}
	
};

Webcam.init();

if (typeof define === 'function' && define.amd) {
	define( function() { return Webcam; } );
} 
else if (typeof module === 'object' && module.exports) {
	module.exports = Webcam;
} 
else {
	window.Webcam = Webcam;
}

}(window));


</script><script>
//This code is opensource MIT license, by Ben F Rayfield 2021-11+, or someone may have forked after that.

var options = {

	displayRectCoordsInEachUinode: false,
	//displayRectCoordsInEachUinode: true,

	//repelByRectOverlapElseJustDistanceOfTopLeftCorners: false,
	repelByRectOverlapElseJustDistanceOfTopLeftCorners: true,

	//how much UINodes repel when their rectangles overlap eachother. Per pair of UINodes, which each can be different widths and heights,
	//does it by fraction of possible overlapping area, so even if one fits completely inside the other and doesnt cover all its area, thats still 1 times this.
	potenMultForRectOverlap: 100000,

	//doUinodePhysics: false,
	doUinodePhysics: true,

	displayTextareaForCallPairsThatHaveNoDotDData: false,
	//displayTextareaForCallPairsThatHaveNoDotDData: true,
	
	minTextareaWidthPx: 50,

	//displayUinodesAndUiedgesEveryVideoFrame: false,
	displayUinodesAndUiedgesEveryVideoFrame: true,

	uinodeOpacity: .85,

	//startWebcamAtBoot: false,
	startWebcamAtBoot: true,

	//viewMode: 'liveResearchViewModeInOriginalColor',
	//viewMode: 'liveResearchViewModeInNormedColor',
	//viewMode: 'liveResearchViewModeCachedFloats',
	viewMode: 'avmLambdaViewMode',

	ballFinderFuncEvolveNumTriesPerVideoFrame: 100, //number of harmony-searched/randomMutated evolutions per video frame. Each is a state of all the balls (as of 2023-4-26 evolution only does 1 ball, but older ballFinderFunc's such as moveByDirectDeriv can do many balls, TODO evolve many after 1 ball is working well. Its all 1 potentialEnergy function to evolve, just more dimensions/dims at once. 50 is a little jumpy. 200 is a little too slow. on mobile browsers might have to reduce this.)

	//ballFinderFunc: 'moveByDirectDeriv', //the oldest way. doesnt do calculus on potentialEnergy funcs but tries to approximate it directly.
	//ballFinderFunc: 'moveByPotentialEnergyDeriv', //like moveByDirectDeriv except calls ByteRect.potentialEnergy 7 times for calculus 6d gradient.
	//ballFinderFunc: 'evolveByNoncachedPotentialEnergy', //like moveByPotentialEnergyDeriv except done by harmony-search/evolve.
	//ballFinderFunc: 'evolveByCumulativeCacheOfPotentialEnergyFloats', //ByteRect.cacheColorWeight with cumulative param true. Doesnt work as of 2023-4-26.
	ballFinderFunc: 'evolveByLoopSquareOverCacheOfPotentialEnergyFloats', //ByteRect.cacheColorWeight with cumulative param false. This is best as of 2023-4-26.

	logEvolutionSummaryPerVideoFrame: false,
	displayDetailedEvolution: false,




	/*useCumulativePixelsOptimization: true,
	//useCumulativePixelsOptimization: false,
	useCumulativePixelsOptimization_butDoNoncumulativeMiddleStepOnlyIfSo: true, //if useCumulativePixelsOptimization, chooses between 2 functions
	doRyxrgbDerivsUsingPotentialEnergy: true, //else an older way. for testing ryxrgbPotentialEnergy since its likely buggy (2023-4-23) and likely doesnt match ryxrgbDerivs
	*/
	startNumBalls: 1,
	displayDetailedEvolution: false,
	//putYellowCircleAtMouseAsTestBall: true,
	putYellowCircleAtMouseAsTestBall: false,
	//putYellowCircleAtMouseAsTestBall: false, //cuz interferes with testing tennis balls sometimes
	colorMatchExponent: 2,
	//startNumBalls: 20,
};














"use strict";


//2 canvases of same size. webcam goes in a <video> dom object which is copied to canvasIn, then preprocessing (flip horizontal, etc),
//then Sim.io(dt,byteRectIn,byteRectOut) reads canvasIn, does physics/energy calculations, and writes canvasOut,
//then repeat many times per second for realtime augmented reality using webcam.
//ODO Sim.io use GPU.js optimization for springs and nonlinear color pull on voxel near those pixels.
var canvasInContext = null;
var canvasOutContext = null;
var canvasInImageData = null;
var canvasOutImageData = null;
var canvasInPixels = null;
var canvasOutPixels = null;
var canvasIn = null;
var canvasOut = null;
var byteRectIn = null;
var byteRectOut = null;

const timeOffset_ = performance.timing.navigationStart;

var between = (min, val, max)=>Math.max(min,Math.min(val,max));

var betweenIntRoundMid = (min, val, max)=>Math.round(Math.max(min,Math.min(val,max)));

var betweenIntRoundDown = (min, val, max)=>Math.floor(Math.max(min,Math.min(val,max)));

//TODO test this vs Date.now()*.001. It seems to match that very close but often has more digits.
//utc seconds. TODO more precise time, like java.lang.System.nanoTime
//in practice has microsecond precision and in theory could have nanosecond precision,
//but only relative to System.currentTimeMillis() which in practice has .01 second precision
//in time sync between it and remote computers, so if you use the 2 together,
//you can use a double for the timing of sound amplitudes, gamepad movements, and dates.
//Is there something like that in browser javascript?
//Maybe https://developer.mozilla.org/en-US/docs/Web/API/Performance/now ?
//This line of code compares them: console.log(''+(performance.timing.navigationStart + performance.now())*.001+'\n'+(Date.now()*.001));

//utc seconds, with a little more precision than Date.now()*.001
var time = ()=>((timeOffset_+performance.now())*.001);

var updateCanvasObjects = function(){
	canvasIn = document.getElementById('canvasIn');
	canvasOut = document.getElementById('canvasOut');
	if((canvasIn.width != canvasOut.width) || (canvasIn.height != canvasOut.height)) throw 'Diff size canvases, canvasIn and canvasOut';
	canvasInContext = canvasIn.getContext('2d');
	canvasOutContext = canvasOut.getContext('2d');
	canvasInImageData = canvasInContext.getImageData(0, 0, canvasIn.width, canvasIn.height);
	canvasOutImageData = canvasOutContext.getImageData(0, 0, canvasOut.width, canvasOut.height);
	canvasInPixels = canvasInImageData.data;
	canvasOutPixels = canvasOutImageData.data;
	byteRectIn = new ByteRect(canvasInPixels, canvasIn.height, canvasIn.width);
	byteRectOut = new ByteRect(canvasOutPixels, canvasOut.height, canvasOut.width);
	//console.log('updateCanvasObjects done.');
};

const AX = 0; //affineTransform X
const AY = 1; //affineTransform Y
const AZ = 2; //affineTransform Z
const AS = 3; //affineTransform S. TODO rename to M for Move or P for position.

const AXX = AX*4+AX; //affineTransform X-&gt;X (FIXME or is it <- ?)
const AXY = AX*4+AY;
const AXZ = AX*4+AZ;
const AXS = AX*4+AS;
const AYX = AY*4+AX;
const AYY = AY*4+AY;
const AYZ = AY*4+AZ;
const AYS = AY*4+AS;
const AZX = AZ*4+AX;
const AZY = AZ*4+AY;
const AZZ = AZ*4+AZ;
const AZS = AZ*4+AS;
const ASX = AS*4+AX;
const ASY = AS*4+AY;
const ASZ = AS*4+AZ;
const ASS = AS*4+AS; //TODO rename S to O for offset or P for position, or something like that. its not scale. its for position.

//byte offsets for ByteRect, canvas, etc, in js.
const RED = 0, GREEN = 1, BLUE = 2, ALPHA = 3; //ALPHA isnt used in voxels, so another const also equals alpha's constant.


//readable and writable pixels as Uint8Array. A canvas is a kind of Uint8Array.
//Single pixel read and write funcs are slow unless you just do a few places.
//TODO Write horizontal lines of same color or 2 colors on end interpolating between,
//and these lines can be derived from triangle which has different color at each corner.
var ByteRect = function(bytes, height, width){
	this.bytes = bytes;
	this.height = height;
	this.width = width;
};

ByteRect.prototype.copy = function(){
	let newBytes = new Uint8Array(this.bytes.length);
	copyBytes(this.bytes, newBytes);
	return new ByteRect(newBytes, this.height, this.width);
};

//TODO choose [y x] vs [x y z scale] order. Swap y and x in ByteRect params order? aftrans is [x y z scale].

ByteRect.prototype.index = function(y, x, colorDim){
	return (y*this.width+x)*4+colorDim;
};

ByteRect.prototype.read = function(y, x, colorDim){
	return this.bytes[(y*this.width+x)*4+colorDim];
};

//TODO bilinear interpolation for smoother color?
ByteRect.prototype.readSafe = function(y, x, colorDim){
	return this.bytes[betweenInt(0,(Math.round(y)*this.width+Math.round(x))*4+colorDim,this.bytes.length-1)];
};

ByteRect.prototype.readBrightnessSafe = function(y, x){
	let i = between(0, (Math.round(y)*this.width+Math.round(x))*4, this.bytes.length-4);
	return (this.bytes[i+RED]+this.bytes[i+GREEN]+this.bytes[i+BLUE])/3;
};

/** same as readBrightnessSafe but as Float32Array whose length is this.bytes.length/4. a copy, not backing. */
ByteRect.prototype.brightnessFloats = function(y, x){
	let ret = new Float32Array(this.bytes.length/4);
	let i = 0;
	for(let j=0; j<this.bytes.length; j+=4){
		ret[i++] = (this.bytes[j+RED]+this.bytes[j+GREEN]+this.bytes[j+BLUE])/3;
	}
	return ret;
};

ByteRect.prototype.write = function(y, x, colorDim, bright){
	this.bytes[(y*this.width+x)*4+colorDim] = bright;
};

ByteRect.prototype.writeSafe = function(y, x, colorDim, bright){
	this.bytes[between(0,(Math.round(y)*this.width+Math.round(x))*4+colorDim,this.bytes.length-1)] = bright;
};

ByteRect.prototype.writeSafeRGBA = function(y, x, redByte, greenByte, blueByte, optionalAlphaByte){
	if(optionalAlphaByte === undefined) optionalAlphaByte = 255; //visible
	let index = between(0,(Math.round(y)*this.width+Math.round(x))*4,this.bytes.length-4);
	this.bytes[index+RED] = redByte;
	this.bytes[index+GREEN] = greenByte;
	this.bytes[index+BLUE] = blueByte;
	this.bytes[index+ALPHA] = optionalAlphaByte;
};

ByteRect.prototype.writeSafeBright = function(y, x, brightByte){
	let index = between(0,(Math.round(y)*this.width+Math.round(x))*4,this.bytes.length-4);
	this.bytes[index+RED] = brightByte;
	this.bytes[index+GREEN] = brightByte;
	this.bytes[index+BLUE] = brightByte;
	this.bytes[index+ALPHA] = 255;
};

ByteRect.prototype.atYXWriteRGB = function(y, x, redByte, greenByte, blueByte){
	let ind = (y*this.width+x)*4;
	this.bytes[ind+RED] = redByte;
	this.bytes[ind+GREEN] = greenByte;
	this.bytes[ind+BLUE] = blueByte;
};

ByteRect.prototype.writeHoriz = function(y, fromX, toXExclusive, colorDim, fromBright, toBright){
	var indexStart = this.index(y, fromX, colorDim);
	var pixelSiz = toXExclusive-fromX;
	var siz = pixelSiz*4;
	var bright = fromBright;
	var brightAdd = (toBright-fromBright)/pixelSiz;
	for(var i=0; i<siz; i+=4){
		bright += brightAdd;
		this.bytes[indexStart+i] = Math.floor(bright) & 0xff;
	}
};

ByteRect.prototype.flipHorizontal = function(){
	let bytes = this.bytes;
	for(let y=0; y<this.height; y++){
		let xMid = Math.floor(this.width/2);
		let offsetA = y*this.width*4; //first byte index of first pixel in row
		let offsetB = ((y+1)*this.width-1)*4; //first byte of last pixel in row
		for(let x=0; x<xMid; x++){
			for(let colorDim=0; colorDim<4; colorDim++){ //swap 2 pixels as 4 bytes each
				let temp = bytes[offsetA+colorDim];
				bytes[offsetA+colorDim] = bytes[offsetB+colorDim];
				bytes[offsetB+colorDim] = temp;
			}
			offsetA += 4;
			offsetB -= 4;
		}
	}
};

ByteRect.prototype.verifySameSizeAs = function(byteRect){
	if(!byteRect) throw 'Param ByteRect = '+byteRect;
	if(this.height != byteRect.height) throw this.height+' == this.height != byteRect.height == '+byteRect.height;
	if(this.width != byteRect.width) throw this.width+' == this.width != byteRect.width == '+byteRect.width;
};

ByteRect.prototype.loopAve = function(loopSize, firstByteIndex, addByteIndex){
	let sum = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		sum += this.bytes[i];
		i += addByteIndex;
	}
	return sum/loopSize;
};

ByteRect.prototype.loopFractionOfBytesThatAreAtLeastVal = function(loopSize, firstByteIndex, addByteIndex, brightnessIsAtLeastThisByteVal){
	let count = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		if(brightnessIsAtLeastThisByteVal <= this.bytes[i]) count++;
		i += addByteIndex;
	}
	return count/loopSize;
};

ByteRect.prototype.loopWriteByte = function(loopSize, firstByteIndex, addByteIndex, writeByteVal){
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		this.bytes[i] = writeByteVal;
		i += addByteIndex;
	}
};

ByteRect.prototype.loopWriteBlack = function(loopSize, firstByteIndex, addByteIndex){
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		this.bytes[i+RED] = 0;
		this.bytes[i+GREEN] = 0;
		this.bytes[i+BLUE] = 0;
		i += addByteIndex;
	}
};

/** stdDev of looping over bytes (a row or column and colorDim).
optionalAve is from loopAve or as optional param it computes that.
*/
ByteRect.prototype.loopDev = function(loopSize, firstByteIndex, addByteIndex, optionalAve){
	if(optionalAve === undefined) optionalAve = this.loopAve(byteRect, firstByteIndex, addByteIndex);
	let sumOfSquares = 0;
	let i = firstByteIndex;
	for(let a=0; a<loopSize; a++){
		let diff = this.bytes[i]-optionalAve;
		sumOfSquares += diff*diff;
		i += addByteIndex;
	}
	return Math.sqrt(sumOfSquares/loopSize);
};

/** ave brightness of a certain row and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.rowAve = function(y, colorDim){
	return this.loopAve(this.width, y*this.width*4+colorDim, 4);
};

/** stdDev of brightness of a certain row and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.rowDev = function(y, colorDim, optionalAve){
	return this.loopDev(this.width, y*this.width*4+colorDim, 4, optionalAve);
};

/** ave brightness of a certain column and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.colAve = function(x, colorDim){
	return this.loopAve(this.height, x*4+colorDim, this.width*4);
};

/** stdDev of brightness of a certain column and [RED, GREEN, BLUE, or ALPHA]. Range 0 to 255. */
ByteRect.prototype.colDev = function(x, colorDim, optionalAve){
	return this.loopDev(this.height, x*4+colorDim, this.width*4, optionalAve);
};

ByteRect.prototype.setRowAndColordimToByte = function(y, colorDim, byteVal){
	this.loopWriteByte(this.width, y*this.width*4+colorDim, 4, byteVal);
};

ByteRect.prototype.setColAndColordimToByte = function(x, colorDim, byteVal){
	this.loopWriteByte(this.height, x*4+colorDim, this.width*4, byteVal);
};

ByteRect.prototype.rowFractionOfBytesThatAreAtLeastVal = function(y, colorDim, brightnessIsAtLeastThisByteVal){
	return this.loopFractionOfBytesThatAreAtLeastVal(this.width, y*this.width*4+colorDim, 4, brightnessIsAtLeastThisByteVal);
};

ByteRect.prototype.colFractionOfBytesThatAreAtLeastVal = function(x, colorDim, brightnessIsAtLeastThisByteVal){
	return this.loopFractionOfBytesThatAreAtLeastVal(this.height, x*4+colorDim, this.width*4, brightnessIsAtLeastThisByteVal);
};

ByteRect.prototype.setRowToBlack = function(y){
	this.loopWriteBlack(this.width, y*this.width*4, 4);
};

ByteRect.prototype.setColToBlack = function(x){
	this.loopWriteBlack(this.height, x*4, this.width*4);
};

/*
//picfn(y,x,RED_or_GREEN_or_BLUE)->brightnessFraction. Its a kind of smooth image, that can wrap a ByteRect or equation.
Byterect.prototype.asPicfn = function(){
	const byteRect = this;
	return function(y,x,colorDim){
		TODO use byteRect
	};
};
*/

//centerY, centerX, and radius can be scalars. Does bounds checking
var paintDonut = function(byteRect, centerY, centerX, minRadius, maxRadius, redByte, greenByte, blueByte){
	if(minRadius > maxRadius) throw 'minRadius='+minRadius+' maxRadius='+maxRadius;
	var minYI = Math.max(0, Math.min(Math.floor(centerY-maxRadius), byteRect.height-1));
	var maxYI = Math.max(0, Math.min(Math.ceil(centerY+maxRadius), byteRect.height-1));
	var minXI = Math.max(0, Math.min(Math.floor(centerX-maxRadius), byteRect.width-1));
	var maxXI = Math.max(0, Math.min(Math.ceil(centerX+maxRadius), byteRect.width-1));
	var minRadiusSq = minRadius*minRadius;
	var maxRadiusSq = maxRadius*maxRadius;
	for(var y=minYI; y<=maxYI; y++){
		var i = byteRect.index(y, minXI, 0);
		for(var x=minXI; x<=maxXI; x++){
			var dy = y-centerY;
			var dx = x-centerX;
			let sq = dy*dy + dx*dx;
			if((minRadiusSq <= sq) && (sq <= maxRadiusSq)){
				//TODO optimize by skipping parts where this isnt true, in the loop before getting here.
				byteRect.bytes[i+RED] = redByte;
				byteRect.bytes[i+GREEN] = greenByte;
				byteRect.bytes[i+BLUE] = blueByte;
				byteRect.bytes[i+ALPHA] = 255;
			}
			i += 4;
		}
	}
};

ByteRect.prototype.paintLineYXYXRGB = function(fromY, fromX, toY, toX, redByte, greenByte, blueByte){
	let diffY = toY-fromY;
	let diffX = toX-fromX;
	let len = Math.hypot(diffY, diffX);
	let numPoints = Math.ceil(len*1.5);
	for(let i=0; i<numPoints; i++){
		//TODO optimize
		let y = Math.round(fromY+diffY*i/numPoints);
		let x = Math.round(fromX+diffX*i/numPoints);
		this.atYXWriteRGB(y, x, redByte, greenByte, blueByte);
	}
};

ByteRect.prototype.paintCircleRadiusYXRGBSafe = function(radius, cy, cx, redByte, greenByte, blueByte){
	let circle = 2*Math.PI;
	let numPoints = Math.ceil(radius*circle*1.5);
	let anglePerPoint = 2*Math.PI/numPoints;
	for(let i=0; i<numPoints; i++){
		let angle = anglePerPoint*i;
		let x = cx+radius*Math.cos(angle);
		let y = cy+radius*Math.sin(angle);
		this.writeSafeRGBA(y, x, redByte, greenByte, blueByte);
	}
};


var bytesToFloats = function(bytes){
	let floats = new Float32Array(bytes.length);
	for(let i=0; i<bytes.length; i++) floats[i] = bytes[i];
	return floats;
};

var floatsToBytes = function(floats){
	let bytes = new Uint8Array(floats.length);
	for(let i=0; i<bytes.length; i++) bytes[i] = floats[i];
	return bytes;
};

var floatsAsMonochromeToPic = function(floats, height, width){
	if(floats.length != height*width) throw 'floats.length='+floats.length+' height='+height+' width='+width+' are diff sizes';
	let ret = new ByteRect(new Uint8Array(floats.length*4), height, width);
	let outb = ret.bytes;
	let j = 0;
	for(let i=0; i<ret.bytes.length; i+=4){
		//let bright = floats[j++];
		let bright = asByte(floats[j++]);
		outb[i+RED] = bright;
		outb[i+GREEN] = bright;
		outb[i+BLUE] = bright;
		outb[i+ALPHA] = 255; //visible
	}
	return ret;
};

var isByteRect = function(b){
	return (b.bytes && b.height && b.width);
};


var floats2dToFloats1d = function(floats2d){
	let size = 0;
	for(let i=0; i<floats2d.length; i++) size += floats2d[i].length;
	let ret = new Float32Array(size);
	let j = 0;
	for(let i=0; i<floats2d.length; i++){
		let innerFloats = floats2d[i];
		for(let k=0; k<innerFloats.length; k++){ //TODO optimize by range copy
			ret[j++] = innerFloats[k];
		}
	}
	return ret;
};

const maxPossibleColorDistanceSquared = 3*255*255;

//distance between observed red and redness of voxel (r g b in param) moving near it. sqrt of sum of square diffs.
//Since colors range 0..255, distance ranges 0..sqrt(3*255^2)=441.6729559300637.
const maxPossibleColorDistance = Math.sqrt(maxPossibleColorDistanceSquared);

/*TODO update this to also do radius deriv, which is jumpier than y x red green blue cuz
radius wants to get smaller as much as color doesnt match at circle perimeter
and wants to get bigger as much as color does match, depending how much of the circle perimeter
is on the ball pixels that webcam sees.
//
//Returns [dradius, dy, dx, dred, dgreen, dblue], the direction to change 3d position and color,
//given what webcam sees as this ByteRect.
//Caller will normally change color a different speed than position andOr radius.
//
//get y x velocity, given a certain color (of a voxel there), at an x, y, and rectangle_or_2d_bellcurve, to accel that voxel, and how to change its color
//View it as a 5d vector field of x y red green blue, or maybe 6d if you count the size of rectangle_or_2d_bellcurve but since it doesnt
//give a derivative for the size, maybe shouldnt include that. Also z dim (into or out of the screen) is a dim in other parts of the system but not here.
//TODO find a more efficient way to do this than 1 at a time and returning a new [5 numbers] each time, but this is early experiments.
//size (UPDATE: its now radius) param is normally 1-20 and must always be at least 1. size is 2*radius.
//r g b are 0..255. Derivatives returned are floats.
//0 <= y < byteRect.height.
//0 <= x < byteRect.width.
//OLD: If isPaintOver, then paints over the area observed, to show what its observing and the weights there.
//optionalByteRectOut is undefined to not paint anything, else paint at optionalByteRectOut.
//What it paints tends to (TODO or is it always?) have near the same brightness as what was already there
//but like viewed thru colored glass,
//the color of the r g b params.
//
//FIXME this isnt working yet its mirrored in some options.potentialEnergyFunc and not others...
//2023-4-26 flipping the sign on potentialEnergy to match physics so lower is better and it rolls down high dimensional potential energy hills,
//so just adding minuses at the end (and in an IF near the start if(options.ballFinderFunc == 'moveByPotentialEnergyDeriv')),
//both in a 'Float32Array.of'.
*/
ByteRect.prototype.ryxrgbDerivs = function(radius, y, x, r, g, b, optionalByteRectOut){
	let returnThisIfNonNull = null;
	//if(options.doRyxrgbDerivsUsingPotentialEnergy){
	if(options.ballFinderFunc == 'moveByPotentialEnergyDeriv'){
		//let ep = EPSILON;
		//let ep = 5; //FIXME, has to be this big cuz its in units of pixels andOr 0..255 colors. EPSILON constant was getting 0 derivatives.
		let ep = 2; //FIXME, has to be this big cuz its in units of pixels andOr 0..255 colors. EPSILON constant was getting 0 derivatives.
		let ifSelf = this.ryxrgbPotentialEnergy(radius, y, x, r, g, b);
		let ifRadius = this.ryxrgbPotentialEnergy(radius+ep, y, x, r, g, b);
		let ifY = this.ryxrgbPotentialEnergy(radius, y+ep, x, r, g, b);
		let ifX = this.ryxrgbPotentialEnergy(radius, y, x+ep, r, g, b);
		let ifR = this.ryxrgbPotentialEnergy(radius, y, x, r+ep, g, b);
		let ifG = this.ryxrgbPotentialEnergy(radius, y, x, r, g+ep, b);
		let ifB = this.ryxrgbPotentialEnergy(radius, y, x, r, g, b+ep);
		//FIXME 2023-5-2 i noticed that the monochrome potentialEnergy pixels were wrapping around byte range
		//for the ball, so its going higher instead of lower, so this is likely gonna negate the derivatives,
		//so might need to remove the negatives below (-dradius, -dy, -dx, -dr, -dg, -db), or something like that, a few places in code.
		//Im about to change a potential energy func somewhere, maybe cacheColorWeight or funcs that use it,
		//to flip the sign, and maybe add an offset. I want the ball to appear darker on screen cuz thats valleys,
		//that the sim ball looks for and is repelled by bright.
		//Nevermind... This is getting complicated. Just do that in AvmLambdas (RootLam)???


		let dradius = (ifRadius-ifSelf)/ep;
		let dy = (ifY-ifSelf)/ep;
		let dx = (ifX-ifSelf)/ep;
		console.log('doRyxrgbDerivsUsingPotentialEnergy ryxrgbDerivs dx='+dx+' ifSelf='+ifSelf);
		let dr = (ifR-ifSelf)/ep;
		let dg = (ifG-ifSelf)/ep;
		let db = (ifB-ifSelf)/ep;
		//returnThisIfNonNull = Float32Array.of(dradius, dy, dx, dr, dg, db);
		returnThisIfNonNull = Float32Array.of(-dradius, -dy, -dx, -dr, -dg, -db); //minuses so lower potentialEnergy is better, to match physics.
		if(!optionalByteRectOut){
			return returnThisIfNonNull;
		}
		//else continue the code below, to paint optionalByteRectOut,
		//ignore what else the code below does, then return returnThisIfNonNull.
	}/*else if(options.ballFinderFunc != 'moveByDirectDeriv'){
		console.log('WARNING: ByteRect.ryxrgbDerivs is being called but options.ballFinderFunc is not moveByDirectDeriv or moveByPotentialEnergyDeriv. It is '+options.ballFinderFunc);
	}*/

	//FIXME if size is even, or x and y are not integers, then can pull a direction cuz of roundoff?
	//Or will it avoid that to compare weightedSum of x and y to the average x and y of the pixels measured
	//instead of comparing it to the param x and y?

	let size = 2*radius;
	if(radius < 1) throw 'radius='+radius+' so what pixels is it supposed to look at?';
	let radiusSquared = radius*radius;
	let xStart = Math.max(0,Math.round(x-size/2));
	let xEndExcl = Math.min(xStart+size,this.width);
	let yStart = Math.max(0,Math.round(y-size/2));
	let yEndExcl = Math.min(yStart+size,this.height);
	let numPixels = (yEndExcl-yStart)*(xEndExcl-xStart);
	//do it the simple square way for now, but bellcurve is better todo that
	let dradius = 0;
	let dy = 0;
	let dx = 0;
	let dr = 0;
	let dg = 0;
	let db = 0;
	let sumR = 0, sumG = 0, sumB = 0;
	let bytes = this.bytes;
	//use Math.pow (such as of 2 for leastSquares, or 2.1 for a little stronger matching (ignore more colors that differ slightly), 1 for linear, etc.
	let colorMatchExponent = options.colorMatchExponent;
	//let colorMatchExponent = 1;
	let sumYByWeight = 0;
	let sumXByWeight = 0;
	let sumWeight = 0;
	let aveYUnweighted = (yStart+(yEndExcl-1))/2;
	let aveXUnweighted = (xStart+(xEndExcl-1))/2;
	let paintBytes = (optionalByteRectOut ? optionalByteRectOut.bytes : null);
	for(let yy=yStart; yy<yEndExcl; yy++){
		for(let xx=xStart; xx<xEndExcl; xx++){
			let ptr = (yy*this.width+xx)*4; //pixel starts at which byte (and is 4 bytes)
			let rr = bytes[ptr+RED];
			let gg = bytes[ptr+GREEN];
			let bb = bytes[ptr+BLUE];
			sumR += rr;
			sumG += gg;
			sumB += bb;
			let colorDistanceFraction = Math.hypot(rr-r, gg-g, bb-b)/maxPossibleColorDistance; //TODO optimize
			//weightedSum of colors accelerates voxel in x and y dims toward colors similar to its current color,
			//and TODO its current color is accelerated (or just decay toward?) toward whatever colors its near.
			let weight = Math.pow(1-colorDistanceFraction,colorMatchExponent); //TODO optimize
			//let distanceXYFromCenterPointAskedAbout = Math.hypot(yy-aveYUnweighted, xx-aveXUnweighted);
			let diffY = yy-aveYUnweighted;
			let diffX = xx-aveXUnweighted;
			if(diffY*diffY + diffX*diffX <= radiusSquared){ //only whats inside the circle within radius of param 2d point, to be angle invariant.
			
				//let distanceSquaredXYFromCenterPointAskedAbout = diffY*diffY + diffX*diffX;
				//let weightMulForShapeOfMovingWindow = ((distanceSquaredXYFromCenterPointAskedAbout <= radiusSquared) ? 1 : 0);
				//weight *= weightMulForShapeOfMovingWindow;
			
			
				sumYByWeight += yy*weight;
				sumXByWeight += xx*weight;
				sumWeight += weight;
				if(paintBytes){
					//let mult = weight; //weight ranges 0 to 1 (or 0 to 1/sqrt(3) if norming color to sum to constant?)
					//let mult = weight*2; //FIXME
					/* //paint weight as grayscale
					paintBytes[ptr+RED] = weight*255;
					paintBytes[ptr+GREEN] = weight*255;
					paintBytes[ptr+BLUE] = weight*255;
					*/
					//paint weight as varying brightness of the color of the voxel
					paintBytes[ptr+RED] = weight*r;
					paintBytes[ptr+GREEN] = weight*g;
					paintBytes[ptr+BLUE] = weight*b;
				}
			}
		}
	}
	if(returnThisIfNonNull){
		//just came this far to paint optionalByteRectOut.
		//Ignore Float32Array.of(dradius, dy, dx, dr, dg, db); gradients computed. Return from earlier instead.
		return returnThisIfNonNull;
	}else{
		if(sumWeight > 0){
		//if(sumWeight > 10){ //FIXME
			let aveYByWeight = sumYByWeight/sumWeight;
			let aveXByWeight = sumXByWeight/sumWeight;
			dy += (aveYByWeight-aveYUnweighted)/size;
			dx += (aveXByWeight-aveXUnweighted)/size;
			let aveR = sumR/numPixels;
			let aveG = sumG/numPixels;
			let aveB = sumB/numPixels;
			dr += aveR-r; //diff of average color of the square of pixels observed and the param voxel color
			dg += aveG-g;
			db += aveB-b;
		}else{
			//console.log("yxrgbDerivs.sumWeight="+sumWeight);
		}
		//return Float32Array.of(-dradius, -dy, -dx, -dr, -dg, -db); //minuses so lower potentialEnergy is better, to match physics.
		return Float32Array.of(dradius, dy, dx, dr, dg, db);
	}
};


//returns a Float32Array of size this.height*this.width. It allows you to sum "let weight = Math.pow(1 - colorDistanceFraction, colorMatchExponent);" between any 2 pixels at same y,
//in constant time, which normally will be used in horizontal slices of circles on screen (and later "rounded line" shape to handle motionBlur too).
ByteRect.prototype.cacheColorWeight = function(red, green, blue, isCumulative){
	let bytes = this.bytes;
	let cumulative = 0;
	let siz = this.height * this.width;
	let ret = new Float32Array(siz);
	for(let i=0; i<siz; i++){
		let pixelIndex = i<<2;
		let rr = bytes[pixelIndex+RED];
		let gg = bytes[pixelIndex+GREEN];
		let bb = bytes[pixelIndex+BLUE];
		let colorDistanceFraction = Math.hypot(rr - red, gg - green, bb - blue) / maxPossibleColorDistance; //TODO optimize
		//weightedSum of colors accelerates voxel in x and y dims toward colors similar to its current color,
		//and TODO its current color is accelerated (or just decay toward?) toward whatever colors its near.
		let weight = Math.pow(1 - colorDistanceFraction, options.colorMatchExponent); //TODO optimize
		cumulative += weight;
		ret[i] = isCumulative ? cumulative : weight;
	}
	return ret;
};





//TODO verify gradient of this 6d scalarField (radius y x r g b) or for constant r g b a 3d scalar field of ball 3d position,
//...verify that gradient is the same as ryxrgbDerivs. But use this with harmonySearch etc to get solution directly
//instead of bouncing around like a spring that often goes too far or doesnt go far enough. Get more precision and lower lag.
//ByteRect.prototype.ryxrgbPotentialEnergy = function(radius, y, x, r, g, b, optionalByteRectOut){
//var ryxrgbPotentialEnergyAtCacheCumulative_butDoNoncumulativeMiddleStepOnly_2 = function(colorMatchFloats, height, width, radius, y, x, r, g, b, optionalByteRectOut){
var loopSquareOverCacheOfPotentialEnergyFloats = function(colorMatchFloats, height, width, radius, y, x, r, g, b, optionalByteRectOut){
	let size = 2*radius;
	if(radius < 1) throw 'radius='+radius+' so what pixels is it supposed to look at?';
	let radiusSquared = radius*radius;
	let xStart = Math.max(0,Math.round(x-size/2));
	let xEndExcl = Math.min(xStart+size,width); //FIXME use width-1
	let yStart = Math.max(0,Math.round(y-size/2));
	let yEndExcl = Math.min(yStart+size,height); //FIXME use height-1
	let numPixels = (yEndExcl-yStart)*(xEndExcl-xStart);

	/*
	//do it the simple square way for now, but bellcurve is better todo that
	let dradius = 0;
	let dy = 0;
	let dx = 0;
	let dr = 0;
	let dg = 0;
	let db = 0;
	let sumR = 0, sumG = 0, sumB = 0;
	let bytes = this.bytes;
	//use Math.pow (such as of 2 for leastSquares, or 2.1 for a little stronger matching (ignore more colors that differ slightly), 1 for linear, etc.
	let colorMatchExponent = 2;
	//let colorMatchExponent = 1;
	let sumYByWeight = 0;
	let sumXByWeight = 0;
	let sumWeight = 0;
	let aveYUnweighted = (yStart+(yEndExcl-1))/2;
	let aveXUnweighted = (xStart+(xEndExcl-1))/2;
	let paintBytes = (optionalByteRectOut ? optionalByteRectOut.bytes : null);
	*/

	let paintBytes = (optionalByteRectOut ? optionalByteRectOut.bytes : null);
	let aveYUnweighted = (yStart+(yEndExcl-1))/2;
	let aveXUnweighted = (xStart+(xEndExcl-1))/2;
	let colorMatchExponent = options.colorMatchExponent;
	//let bytes = bytesIn.bytes;
	let sumWeight = 0;
	let sumPotentialEnergy = 0;

	let countPixels = 0;


	//FIXME this shouldnt be here. im trying to figure out why useCumulativePixelsOptimization_butDoNoncumulativeMiddleStepOnlyIfSo isnt finding the ball but this func is.
	//let testCache = bytesIn.cacheColorWeight(r, g, b, false);
	for(let yy=yStart; yy<yEndExcl; yy++){
		for(let xx=xStart; xx<xEndExcl; xx++){
			let ptr = (yy*width+xx)*4; //pixel starts at which byte (and is 4 bytes)
			/*let rr = bytes[ptr+RED];
			let gg = bytes[ptr+GREEN];
			let bb = bytes[ptr+BLUE];
			//sumR += rr;
			//sumG += gg;
			//sumB += bb;
			let colorDistanceFraction = Math.hypot(rr-r, gg-g, bb-b)/maxPossibleColorDistance; //TODO optimize
			//weightedSum of colors accelerates voxel in x and y dims toward colors similar to its current color,
			//and TODO its current color is accelerated (or just decay toward?) toward whatever colors its near.
			//let weight = Math.pow(1-colorDistanceFraction,colorMatchExponent); //TODO optimize
			*/

			//let weight = testCache[yy*width+xx];
			let weight = colorMatchFloats[yy*width+xx];
			//if(Math.abs(weight-weight2) > .000001){
			//	throw 'weight='+weight+' weight2='+weight2+' but should be the same except roundoff.';
			//}


			//let distanceXYFromCenterPointAskedAbout = Math.hypot(yy-aveYUnweighted, xx-aveXUnweighted);
			let diffY = yy-aveYUnweighted;
			let diffX = xx-aveXUnweighted;
			if(diffY*diffY + diffX*diffX <= radiusSquared){ //only whats inside the circle within radius of param 2d point, to be angle invariant.
				
				countPixels++; //TODO smoother sigmoid shaped border of maybe 1.5 pixels thick?

				//let distanceSquaredXYFromCenterPointAskedAbout = diffY*diffY + diffX*diffX;
				//let weightMulForShapeOfMovingWindow = ((distanceSquaredXYFromCenterPointAskedAbout <= radiusSquared) ? 1 : 0);
				//weight *= weightMulForShapeOfMovingWindow;
			
			
				//sumYByWeight += yy*weight;
				//sumXByWeight += xx*weight;
				sumWeight += weight;
				if(paintBytes){
					//let mult = weight; //weight ranges 0 to 1 (or 0 to 1/sqrt(3) if norming color to sum to constant?)
					//let mult = weight*2; //FIXME
					/* //paint weight as grayscale
					paintBytes[ptr+RED] = weight*255;
					paintBytes[ptr+GREEN] = weight*255;
					paintBytes[ptr+BLUE] = weight*255;
					*/
					//paint weight as varying brightness of the color of the voxel
					paintBytes[ptr+RED] = weight*r;
					paintBytes[ptr+GREEN] = weight*g;
					paintBytes[ptr+BLUE] = weight*b;
				}
			}
		}
	}
	/*if(sumWeight > 0){
	//if(sumWeight > 10){ //FIXME
		let aveYByWeight = sumYByWeight/sumWeight;
		let aveXByWeight = sumXByWeight/sumWeight;
		dy += (aveYByWeight-aveYUnweighted)/size;
		dx += (aveXByWeight-aveXUnweighted)/size;
		let aveR = sumR/numPixels;
		let aveG = sumG/numPixels;
		let aveB = sumB/numPixels;
		dr += aveR-r; //diff of average color of the square of pixels observed and the param voxel color
		dg += aveG-g;
		db += aveB-b;
	}else{
		//console.log("yxrgbDerivs.sumWeight="+sumWeight);
	}
	return Float32Array.of(dradius, dy, dx, dr, dg, db);
	*/

	//weight is higher when more color matches.

	//let mul = Math.log1p(radius); //include radius here to slightly prefer bigger radius
	let mul = 1+Math.log1p(radius); //include radius here to slightly prefer bigger radius
	//let mul = 2+Math.sqrt(radius);
	//let mul = Math.sqrt(Math.log1p(radius)); //include radius here to slightly prefer bigger radius
	//let mul = 1;
	//let mul = 1+.1*Math.pow(radius,.3);
	let add = 0;
	sumPotentialEnergy += -sumWeight/countPixels*mul+add; //minus so lower potentialEnergy is better, to match physics
	return sumPotentialEnergy;
};


//cumulative is what pic.cacheColorWeight(r,g,b,true) returns.
//The reason to use this instead of ByteRect.prototype.ryxrgbPotentialEnergy is this is alot faster if you reuse the cumulative many times, in theory.
var ryxrgbPotentialEnergyAtCacheCumulative = function(cumulative, height, width, radius, centerY, centerX){
	//let xStart = Math.max(0,Math.round(x-radius/2));
	//let xEndExcl = Math.min(xStart+size,this.width);
	let size = radius*2;
	let yStart = Math.max(0,Math.round(centerY-radius)); //FIXME for subpixel accuracy do bilinear interpolation
	let yEndExcl = Math.floor(Math.min(yStart+size,height));
	//let numPixels = (yEndExcl-yStart)*(xEndExcl-xStart);
	let yEnd = yEndExcl-1;
	let radiusSquared = radius**2;
	let countPixels = 0;
	let sumWeight = 0;
	for(let y=yStart; y<yEndExcl; y++){
		//(x-centerX)**2 + (y-centerY)**2 = radius**2, approximately but still rounds to int pixel numbers.
		//(x-centerX)**2 = radius**2 - (y-centerY)**2
		//abs(x-centerX) = sqrt(radius**2 - (y-centerY)**2)
		//2 solutions:
		//x = sqrt(radius**2 - (y-centerY)**2) + centerX
		//x = sqrt(radius**2 - (y-centerY)**2) - centerX
		//FIXME might have put the plus/minus the wrong place(s).
		//Doesnt look right. shouldnt change radius by centerX being bigger or smaller.
		//
		//
		//
		//Test this...
		let sqrtStuff = Math.sqrt(radiusSquared - (y-centerY)**2);

		let xFrom = Math.floor(centerX - sqrtStuff);
		let xTo = Math.floor(centerX + sqrtStuff);
		
		//FIXME testing simple square...
		xFrom = Math.max(0,Math.round(centerX-radius));
		xTo = Math.min(xFrom+size-1,width-1);
		
		//FIXME what if it goes outside 0..(cumulative.length-1)
		let indexFrom = y*width + xFrom;
		let indexTo = y*width + xTo;
		let sumWeightInRow = cumulative[indexTo]-cumulative[indexFrom];
		sumWeight += sumWeightInRow;
		let pixelsThere = xTo+1-xFrom;
		countPixels += pixelsThere;
		//Thats alot of code. in loop body. might be faster to just loop over cumulative array as square and check if each is within the circle and sum it?



		/*
		let yFraction = (y-yStart)/(yEnd-yStart); //0 to 1

		let yBifraction = yFraction*2-1; //-1 to 1. 0 is mid height in the circle on screen and the biggest width. -1 and 1 are top and bottom and the smallest (near 0) width.

		//let xStart = Math.max(0,Math.round(x-size/2));
		//let xEndExcl = Math.min(xStart+size,this.width);
		*/

		
	}
	let mul = 1+Math.log1p(radius); //include radius here to slightly prefer bigger radius
	let add = 0;
	return -sumWeight/countPixels*mul+add; //minus so lower potentialEnergy is better, to match physics
};





/*
//TODO remove bytesForTesting param
var ryxrgbPotentialEnergyAtCacheCumulative_butDoNoncumulativeMiddleStepOnly = function(colorMatchFloats, height, width, radius, y, x, bytesForTesting){

	let bytes = bytesForTesting;

	let size = 2*radius;
	if(radius < 1) throw 'radius='+radius+' so what pixels is it supposed to look at?';
	let radiusSquared = radius*radius;
	let xStart = Math.max(0,Math.round(x-size/2));
	let xEndExcl = Math.min(xStart+size,width);
	let yStart = Math.max(0,Math.round(y-size/2));
	let yEndExcl = Math.min(yStart+size,height);
	let numPixels = (yEndExcl-yStart)*(xEndExcl-xStart);

	//let paintBytes = (optionalByteRectOut ? optionalByteRectOut.bytes : null);
	let aveYUnweighted = (yStart+(yEndExcl-1))/2;
	let aveXUnweighted = (xStart+(xEndExcl-1))/2;
	let colorMatchExponent = options.colorMatchExponent;
	//let bytes = this.bytes;
	let sumWeight = 0;
	let sumPotentialEnergy = 0;

	let countPixels = 0;


	for(let yy=yStart; yy<yEndExcl; yy++){
		for(let xx=xStart; xx<xEndExcl; xx++){
			let ptr = (yy*width+xx)*4; //pixel starts at which byte (and is 4 bytes)
			let rr = bytes[ptr+RED];
			let gg = bytes[ptr+GREEN];
			let bb = bytes[ptr+BLUE];
			let colorDistanceFraction = Math.hypot(rr-r, gg-g, bb-b)/maxPossibleColorDistance; //TODO optimize
			let weightOriginal = Math.pow(1-colorDistanceFraction,colorMatchExponent); //TODO optimize
			
			let weight = colorMatchFloats[yy*width+xx];

			if(Math.abs(weight-weightOriginal) > .000001){
				throw 'weight='+weight+' weightOriginal='+weightOriginal+' so ryxrgbPotentialEnergyAtCacheCumulative_butDoNoncumulativeMiddleStepOnly doesnt compute the same thing as ryxrgbPotentialEnergy which it was copied and modified from.';
			}
			let diffY = yy-aveYUnweighted;
			let diffX = xx-aveXUnweighted;
			if(diffY*diffY + diffX*diffX <= radiusSquared){ //only whats inside the circle within radius of param 2d point, to be angle invariant.			
				countPixels++; //TODO smoother sigmoid shaped border of maybe 1.5 pixels thick?
				sumWeight += weight;
				*if(paintBytes){
					paintBytes[ptr+RED] = weight*r;
					paintBytes[ptr+GREEN] = weight*g;
					paintBytes[ptr+BLUE] = weight*b;
				}*
			}
		}
	}

	let mul = 1+Math.log1p(radius); //include radius here to slightly prefer bigger radius

	let add = 0;
	sumPotentialEnergy += sumWeight/countPixels*mul+add;
	return sumPotentialEnergy;

};
*/



//TODO verify gradient of this 6d scalarField (radius y x r g b) or for constant r g b a 3d scalar field of ball 3d position,
//...verify that gradient is the same as ryxrgbDerivs. But use this with harmonySearch etc to get solution directly
//instead of bouncing around like a spring that often goes too far or doesnt go far enough. Get more precision and lower lag.
//2023-4-26 flipping the sign of potentialEnergy so lower is better, to match physics.
ByteRect.prototype.ryxrgbPotentialEnergy = function(radius, y, x, r, g, b, optionalByteRectOut){

	let size = 2*radius;
	if(radius < 1) throw 'radius='+radius+' so what pixels is it supposed to look at?';
	let radiusSquared = radius*radius;
	let xStart = Math.max(0,Math.round(x-size/2));
	let xEndExcl = Math.min(xStart+size,this.width);
	let yStart = Math.max(0,Math.round(y-size/2));
	let yEndExcl = Math.min(yStart+size,this.height);
	let numPixels = (yEndExcl-yStart)*(xEndExcl-xStart);

	/*
	//do it the simple square way for now, but bellcurve is better todo that
	let dradius = 0;
	let dy = 0;
	let dx = 0;
	let dr = 0;
	let dg = 0;
	let db = 0;
	let sumR = 0, sumG = 0, sumB = 0;
	let bytes = this.bytes;
	//use Math.pow (such as of 2 for leastSquares, or 2.1 for a little stronger matching (ignore more colors that differ slightly), 1 for linear, etc.
	let colorMatchExponent = 2;
	//let colorMatchExponent = 1;
	let sumYByWeight = 0;
	let sumXByWeight = 0;
	let sumWeight = 0;
	let aveYUnweighted = (yStart+(yEndExcl-1))/2;
	let aveXUnweighted = (xStart+(xEndExcl-1))/2;
	let paintBytes = (optionalByteRectOut ? optionalByteRectOut.bytes : null);
	*/

	let paintBytes = (optionalByteRectOut ? optionalByteRectOut.bytes : null);
	let aveYUnweighted = (yStart+(yEndExcl-1))/2;
	let aveXUnweighted = (xStart+(xEndExcl-1))/2;
	let colorMatchExponent = options.colorMatchExponent;
	let bytes = this.bytes;
	let sumWeight = 0;
	let sumPotentialEnergy = 0;

	let countPixels = 0;


	//FIXME this shouldnt be here. im trying to figure out why useCumulativePixelsOptimization_butDoNoncumulativeMiddleStepOnlyIfSo isnt finding the ball but this func is.
	let testCache = this.cacheColorWeight(r, g, b, false);


	for(let yy=yStart; yy<yEndExcl; yy++){
		for(let xx=xStart; xx<xEndExcl; xx++){
			let ptr = (yy*this.width+xx)*4; //pixel starts at which byte (and is 4 bytes)
			/*let rr = bytes[ptr+RED];
			let gg = bytes[ptr+GREEN];
			let bb = bytes[ptr+BLUE];
			//sumR += rr;
			//sumG += gg;
			//sumB += bb;
			let colorDistanceFraction = Math.hypot(rr-r, gg-g, bb-b)/maxPossibleColorDistance; //TODO optimize
			//weightedSum of colors accelerates voxel in x and y dims toward colors similar to its current color,
			//and TODO its current color is accelerated (or just decay toward?) toward whatever colors its near.
			//let weight = Math.pow(1-colorDistanceFraction,colorMatchExponent); //TODO optimize
			*/

			let weight= testCache[yy*this.width+xx];
			//if(Math.abs(weight-weight2) > .000001){
			//	throw 'weight='+weight+' weight2='+weight2+' but should be the same except roundoff.';
			//}


			//let distanceXYFromCenterPointAskedAbout = Math.hypot(yy-aveYUnweighted, xx-aveXUnweighted);
			let diffY = yy-aveYUnweighted;
			let diffX = xx-aveXUnweighted;
			if(diffY*diffY + diffX*diffX <= radiusSquared){ //only whats inside the circle within radius of param 2d point, to be angle invariant.
				
				countPixels++; //TODO smoother sigmoid shaped border of maybe 1.5 pixels thick?

				//let distanceSquaredXYFromCenterPointAskedAbout = diffY*diffY + diffX*diffX;
				//let weightMulForShapeOfMovingWindow = ((distanceSquaredXYFromCenterPointAskedAbout <= radiusSquared) ? 1 : 0);
				//weight *= weightMulForShapeOfMovingWindow;
			
			
				//sumYByWeight += yy*weight;
				//sumXByWeight += xx*weight;
				sumWeight += weight;
				if(paintBytes){
					//let mult = weight; //weight ranges 0 to 1 (or 0 to 1/sqrt(3) if norming color to sum to constant?)
					//let mult = weight*2; //FIXME
					/* //paint weight as grayscale
					paintBytes[ptr+RED] = weight*255;
					paintBytes[ptr+GREEN] = weight*255;
					paintBytes[ptr+BLUE] = weight*255;
					*/
					//paint weight as varying brightness of the color of the voxel
					paintBytes[ptr+RED] = weight*r;
					paintBytes[ptr+GREEN] = weight*g;
					paintBytes[ptr+BLUE] = weight*b;
				}
			}
		}
	}
	/*if(sumWeight > 0){
	//if(sumWeight > 10){ //FIXME
		let aveYByWeight = sumYByWeight/sumWeight;
		let aveXByWeight = sumXByWeight/sumWeight;
		dy += (aveYByWeight-aveYUnweighted)/size;
		dx += (aveXByWeight-aveXUnweighted)/size;
		let aveR = sumR/numPixels;
		let aveG = sumG/numPixels;
		let aveB = sumB/numPixels;
		dr += aveR-r; //diff of average color of the square of pixels observed and the param voxel color
		dg += aveG-g;
		db += aveB-b;
	}else{
		//console.log("yxrgbDerivs.sumWeight="+sumWeight);
	}
	return Float32Array.of(dradius, dy, dx, dr, dg, db);
	*/

	//weight is higher when more color matches.
	
	//let mul = Math.log1p(radius); //include radius here to slightly prefer bigger radius
	let mul = 1+Math.log1p(radius); //include radius here to slightly prefer bigger radius
	//let mul = 2+Math.sqrt(radius);
	//let mul = Math.sqrt(Math.log1p(radius)); //include radius here to slightly prefer bigger radius
	//let mul = 1;
	//let mul = 1+.1*Math.pow(radius,.3);
	let add = 0;
	sumPotentialEnergy += -sumWeight/countPixels*mul+add; //the minus is so lower is better, to match physics rolling down high dimensional hills
	return sumPotentialEnergy;
};

var dom = (id)=>document.getElementById(id);

var prevTime = time();

var webcamFrames = 0;
var webcamFpsObserved = 1;

/*
//targetSum is target red+green+blue to norm each pixel to. returns new ByteRect.
var normPixelsAllToSameBrightness = function(byteRect, targetSum){
	let inb = byteRect.bytes;
	let ret = new ByteRect(new Uint8Array(inb.length), byteRect.height, byteRect.width);
	let retb = ret.bytes;
	for(let i=0; i<inb.length; i+=4){
		let sum = inb[i+RED]+inb[i+GREEN]+inb[i+BLUE];
		if(sum == 0){
			let bright = targetSum/3;
			retb[i+RED] = bright;
			retb[i+GREEN] = bright;
			retb[i+BLUE] = bright;
		}else{
			let mul = targetSum/sum;
			retb[i+RED] = inb[i+RED]*mul;
			retb[i+GREEN] = inb[i+GREEN]*mul;
			retb[i+BLUE] = inb[i+BLUE]*mul;
		}
		retb[i+ALPHA] = 255; //visible
		//FIXME? floor ceil round range as its probably a Uint8ClampedArray?
	}
	return ret;
};*/

var normPixelsAllToSameBrightness_mutable = function(byteRect, targetSum){
	let by = byteRect.bytes;
	for(let i=0; i<by.length; i+=4){
		let mul = targetSum/(1+by[i+RED]+by[i+GREEN]+by[i+BLUE]);
		by[i+RED] *= mul;
		by[i+GREEN] *= mul;
		by[i+BLUE] *= mul;
	}
};

var normPixelsAllToSameBrightness = function(byteRect, targetSum){
	//let b = new ByteRect(new Uint8Array(byteRect.bytes.length), byteRect.height, byteRect.width);
	let b = byteRect.copy();
	normPixelsAllToSameBrightness_mutable(b, targetSum);
	return b;
};

//AvmLambda form of 
var NormPixelsAllToSameBrightness = W(`(me,bytes,targetSum)=>{
	let by = bytes.d;
	for(let i=0; i<by.length; i+=4){
		let mul = targetSum.d/(1+by[i+RED]+by[i+GREEN]+by[i+BLUE]);
		by[i+RED] *= mul;
		by[i+GREEN] *= mul;
		by[i+BLUE] *= mul;
	}
	return W(bytes);
}`);

var displayOnlyYellow_mutable = function(byteRect){
	let by = byteRect.bytes;
	for(let i=0; i<by.length; i+=4){
		let r = by[i+RED], g = by[i+GREEN], b = by[i+BLUE];
		let yellowness = .35*(r+g)/(1+b);
		yellowness *= yellowness;
		yellowness *= yellowness;
		yellowness *= yellowness;
		//yellowness *= yellowness;
		//yellowness *= yellowness;
		by[i+RED] *= yellowness;
		by[i+GREEN] *= yellowness;
		by[i+BLUE] *= yellowness;
	}
};


var lastDatauri = null;

//modifies
var writeTestsOntoPicIn_mutable = picIn=>{
	if(options.putYellowCircleAtMouseAsTestBall){
		//picIn.paintCircleRadiusYXRGBSafe(14, mouseY, mouseX, 200, 200, 20);
		
		//FIXME shouldnt have to +160. fix the coordinate system.
		//problem is the style matrix affine transform on canvas andOr adjustments to mouseY and mouseX for it
		paintDonut(picIn, mouseY, mouseX+160, 0, 14, 200, 200, 20);
		//var paintDonut = function(byteRect, centerY, centerX, minRadius, maxRadius, redByte, greenByte, blueByte){
	}
};

//doesnt modify. returns a ByteRect, same one if there are no such tests.
var testsOntoPicIn = function(picIn){
	if(options.putYellowCircleAtMouseAsTestBall){
		let byteRect = new ByteRect(new Uint8Array(picIn.bytes.length), byteRect.height, byteRect.width);
		writeTestsOntoPicIn(byteRect);
		return byteRect;
	}else{
		return picIn;
	}
};

//var lastPopulation = null; //just for testing

var is_ballFinderFuncName_aKindOfEvolve = function(ballFinderFuncName){
	return (ballFinderFuncName != 'moveByDirectDeriv' && ballFinderFuncName != 'moveByPotentialEnergyDeriv');
};

var updateGameObjectsAndPaint = function(dt,picIn,picOut){
	let retMap = {
		population: null,
		cumulativePotentialEnergyFloats: null,
		potentialEnergyFloats: null
	};
	for(let i=0; i<balls.length; i++){
		let ball = balls[i];
		//FIXME order of these next few lines?

		//if(ball.evolveInsteadOfGradient){
		if(is_ballFinderFuncName_aKindOfEvolve(options.ballFinderFunc)){
			//let numTries = 200;
			//let numTries = 100;
			let numTries = options.ballFinderFuncEvolveNumTriesPerVideoFrame;
			//let numTries = 50;

			////returns {population: [...], cumulativePotentialEnergyFloats: ..., potentialEnergyFloats: ...} but either of those *floats may be null.
			let map = ball.evolveBallXYRadiusToward(picIn,numTries); //TODO rename to RadiusYX cuz is normally in that order.
			for(let key in map){
				if(map[key]) retMap[key] = map[key];
			}

			//remember it in lastPopulation var just for testing. dont actually need to remember it.

			ball.updateGradient(picIn,picOut); //FIXME remove this but i just want to paint the circle how it varies brightness by color match
		}else{
			ball.move(dt);
			ball.holdInRange();
			ball.updateGradient(picIn,picOut);
		}
		//ball.holdInRange();
		//paint perimeter of ball the opposite color of the ball
		//so its not invisible before it finds the ball on screen and sticks to it
		picOut.paintCircleRadiusYXRGBSafe(ball.radius, ball.y, ball.x, 255-ball.red, 255-ball.green, 255-ball.blue);
	}
	return retMap;
};

//var normBrightnessOfInputPic = true;

var AddColor_0_100_200 = W(`(me,addToRed,addToGreen,addToBlue,bytes)=>{
	//FIXME instanceof Uint8Array isnt working inside this eval, maybe it got converted to something else?
	//if(!((bytes.d) instanceof Uint8Array)){
	//	throw 'addcolor. bytes.d is a '+typeof(bytes.d)+' BYTES_PER_ELEMENT='+bytes.d.BYTES_PER_ELEMENT+' val='+bytes.d;
	//}
	let by = new Uint8Array(bytes.d);
	for(let i=0; i<by.length; i+=4){
		by[i+ALPHA] = 255;
		by[i+RED] += addToRed.d;
		by[i+GREEN] += addToGreen.d;
		by[i+BLUE] += addToBlue.d;
	}
	return by;
}`,'AddColor')(0)(100)(200,'AddColor_0_100_200');

var SimpleTestPicMaker345345 = W(`(me,bytes)=>{
	let by = new Uint8Array(bytes.d);
	for(let i=0; i<by.length; i+=4){
		by[i+ALPHA] = 255;
		by[i+RED] = i;
		by[i+GREEN] = i*i;
		by[i+BLUE] = (i%17)+(i*i%23);
	}
	return by;
}`,'SimpleTestPicMaker345345');

//lambda of wrapped Uint8Array(height*width*4) to Uint8Array(height*width*4).
//You can change this var to different lambdas to try different graphics effects etc.
//TODO expand this to have a {} map (in .d the data) of evolvable options, different ball finder evolution algorithms, etc.
//Put as much of the state of AugmentedBalls as i can into this.
var RootLam = AddColor_0_100_200;
//var RootLam = SimpleTestPicMaker345345;
//var RootLam = W('(me,bytes)=>bytes');



var NegateColorsInLastHalfOfBytes = W(`(me,bytes)=>{
	//FIXME instanceof Uint8Array isnt working inside this eval, maybe it got converted to something else?
	//if(!(bytes.d instanceof Uint8Array)) throw 'negcolor. bytes.d is a '+typeof(bytes.d)+' val='+bytes.d;
	let by = new Uint8Array(bytes.d);
	for(let i=(by.length/2)&~3; i<by.length; i+=4){
		by[i+RED] = 255-by[i+RED];
		by[i+GREEN] = 255-by[i+GREEN];
		by[i+BLUE] = 255-by[i+BLUE];
	}
	return by;
}`,'NegateColorsInLastHalfOfBytes');
//NegateColorsInLastHalfOfBytes.n.nam = 'NegateColorsInLastHalfOfBytes';


RootLam = Chain2Calls(RootLam)(NegateColorsInLastHalfOfBytes);
//RootLam = NegateColorsInLastHalfOfBytes;


var nextState = function(){
	canvasInContext.drawImage(Webcam.video, 0, 0, canvasIn.width, canvasIn.height);
	updateCanvasObjects();
	let now = time();
	let dt = now-prevTime;
	prevTime = now

	webcamFrames++;
	webcamFpsObserved = webcamFpsObserved*(1-dt) + 1; //TODO adjustable decay rate
	let fpsDisplay = (57 < webcamFpsObserved && webcamFpsObserved < 63) ? 'around 60 where it should be' : ''+webcamFpsObserved;
	dom('fpsLabel').innerHTML = 'fps='+fpsDisplay;
	let pic = byteRectIn;
	let h = byteRectIn.height;
	let w = byteRectIn.width;

	if(options.doUinodePhysics){
		doUinodePhysics(dt);
	}

	if(options.viewMode == 'liveResearchViewModeInOriginalColor' || options.viewMode == 'liveResearchViewModeInNormedColor' || options.viewMode == 'liveResearchViewModeCachedFloats'){

		pic = testsOntoPicIn(pic); //FIXME norm color again after that?
	
		if(options.viewMode != 'liveResearchViewModeInOriginalColor'){
			//normPixelsAllToSameBrightness_mutable(pic,500);
			pic = normPixelsAllToSameBrightness(pic,500);
			//pic = normPixelsAllToSameBrightness(pic,255); //cuz 255 is max brightness of each color channel, dont want to truncate ever.
		}

		//FIXMEFIXME todo liveResearchViewModeInColor liveResearchViewModeCachedFloats
		

		//displayOnlyYellow_mutable(pic);
		
		//normPixelsAllToSameBrightness_mutable(pic,500);
		//filterByBrightOfOther_mutable(pic);
		
		//writeTestsOntoPicIn(pic);
		//pic = testsOntoPicIn(pic); //FIXME norm color again after that?

		/*if(options.viewMode == 'liveResearchViewModeCachedFloats'){
			throw 'FIXME where do i get the Float32Array?'
		}*/

	}else if(options.viewMode == 'avmLambdaViewMode'){
		let nextBytes = RootLam(pic.bytes).d;
		pic = new ByteRect(nextBytes, h, w);
	}
	
	//without this line, you dont see the background that webcam sees,
	//just the parts of it that balls are over as if the balls are colored glass
	//that gradually becomes the color of whatever they're over and are attracted to
	//that color aka "sticky color". Also, without this, the ALPHA (255-transparency)
	//might be 0/transparent but you could put 255 everywhere once to fix that.
	copyBytes(pic.bytes, byteRectOut.bytes);
	
	let map = updateGameObjectsAndPaint(dt, pic, byteRectOut); //read pic, write byteRectOut
	//has fields population, cumulativePotentialEnergyFloats, potentialEnergyFloats, but any may be null.
	
	if(options.viewMode == 'liveResearchViewModeCachedFloats' && map.potentialEnergyFloats){
		let normedPotentialEnergyFloats = normFloatsToUnitBell(map.potentialEnergyFloats);
		pic = floatsToMonochromeByteRect(normedPotentialEnergyFloats, w, float=>(128+80*float));
		//pic = floatsToMonochromeByteRect(normedPotentialEnergyFloats, w, float=>between(0,128+80*float,255));
		copyBytes(pic.bytes, byteRectOut.bytes); //TODO optimize?? dont "copyBytes(pic.bytes, byteRectOut.bytes);" twice.
	}
	
	canvasOutContext.putImageData(canvasOutImageData, 0, 0);

	edgeBackgroundOffset += dt*edgeBackgroundOffset_speed;
	if(options.displayUinodesAndUiedgesEveryVideoFrame){
		//uiOf(RootLam).display();
		/*for(let uiedge of allUiedges()){
			uiedge.display(); //cuz edgeBackgroundOffset moves to show edge direction (background in thin colored lines moves along the line)
		}*/
		for(let uinode of nodes){ //display node and its edges
			uinode.display(true);
		}
	}
};

/*
var take_snapshot = function(sim){
	// play sound effect
	//shutter.play();
	
	canvasInContext.drawImage(Webcam.video, 0, 0, canvasIn.width, canvasIn.height);
	updateCanvasObjects();
	let now = time();
	let dt = now-prevTime;
	prevTime = now

	webcamFrames++;
	webcamFpsObserved = webcamFpsObserved*(1-dt) + 1; //TODO adjustable decay rate
	let fpsDisplay = (57 < webcamFpsObserved && webcamFpsObserved < 63) ? 'around 60 where it should be' : ''+webcamFpsObserved;
	dom('fpsLabel').innerHTML = 'fps='+fpsDisplay;
	let pic = byteRectIn;
	let h = byteRectIn.height;
	let w = byteRectIn.width;
	//normPixelsAllToSameBrightness_mutable(pic,500);
	displayOnlyYellow_mutable(pic);
	//normPixelsAllToSameBrightness_mutable(pic,500);
	//filterByBrightOfOther_mutable(pic);
	copyBytes(pic.bytes, byteRectOut.bytes);
	canvasOutContext.putImageData(canvasOutImageData, 0, 0);
	

	// take snapshot and get image data
	if(false) Webcam.snap(
		function(data_uri){
			lastDatauri = data_uri;
			dom('theImg').src = lastDatauri;
			
			return;
			
			let video = Webcam.video;
			if(video !== undefined){
				
				canvasInContext.drawImage(video, 0, 0, canvasIn.width, canvasIn.height);
				updateCanvasObjects();
				let now = time();
				let dt = now-prevTime;
				prevTime = now

				webcamFrames++;
				webcamFpsObserved = webcamFpsObserved*(1-dt) + 1; //TODO adjustable decay rate
				let fpsDisplay = (57 < webcamFpsObserved && webcamFpsObserved < 63) ? 'around 60 where it should be' : ''+webcamFpsObserved;
				dom('fpsLabel').innerHTML = 'fps='+fpsDisplay;

				byteRectIn.flipHorizontal(); //part of preprocessing
				//TODO move color norming here, so sim.io doesnt modify byteRectIn. part of preprocessing.
				//if(sim.paintTestObjectsAsInput){
					//FIXME also paint them onto output (in sim.io(...) if !sim.copyInputPicToOutputPicBeforeVoxelsPaintOntoOutput_elseClearToBlack ?
					//paintTestsOntoByteRectIn(now,byteRectIn);
				//}
				let pic = byteRectIn;
				
				
				
				let h = byteRectIn.height;
				let w = byteRectIn.width;
				
				//normPixelsAllToSameBrightness_mutable(pic,500);
				//normPixelsAllToSameBrightness_mutable(pic,500);
				
				//pic = normPixelsAllToSameBrightness(pic, 500);
								
				
				//if(sim.normColorsToSumRedGreenAndBlueToConst_warningAddsALittleLagTodoFixByUsingGPU){
					//pic = normPixelsAllToSameBrightness(pic, 255);
					//pic = normPixelsAllToSameBrightness(pic, 500);
				//}
				
				//if(sim.isFindEdgesAndKeepTheirColor){
				//	sim.findEdgesAndKeepTheirColor_modifyByterect(pic, sim.minColorDiffFractionToBeADot);
				//}
				
				//if(sim.isFindDots){
				//	pic = sim.findDots(pic, sim.findDots_maxDotSize_param);
				//}
				
				
				
				//if(sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_warningAddsLagTodoFixUsingGPU){
				//	pic = sim.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls(pic);
				//}
				//if(//sim.isDoExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu_WARNINGTHISISONLYONETHATBYTEARRAYTOGPUISTHATTHEBUG){
					//let allowBytesIntoGpu = sim.allowBytesIntoGpuElseCopyBytesToFloats_thisMayBeBuggy;
					//pic = sim.doExperimentalImagePreprocessingToFindEdgesOrWhateverMightHelpFindBalls_usingGpu(pic, true, allowBytesIntoGpu);
					//TODO optimize: let pic be monochrome Float32Array here (gpujs outputs that)
					//so preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu can take Float32Array as input,
					//skipping a step of copying each float into 3 equal bytes then back to float.
				//}
				
				/*if(sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic){
					//these lines seem to be caused by camera norming color in a grid of many small rectangles, and the
					//code to norm colors is so good that it finds them which are otherwise not much visible to the naked eye.
					sim.preprocessPicToRemoveHorizontalAndVerticalLines_modifiesPic(
						pic, //modifies pic
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction
					);
				}
				if(sim.isPreprocessPicToRemoveHorizontalAndVerticalLines_usingGpu){
					pic = sim.preprocessPicToRemoveHorizontalAndVerticalLines_usingGpu(
						pic, //this can be ByteRect or  (TODO?)[Float32Array as monochrome]
						h,
						w,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_bright,
						sim.brightLimitForRowsAndColsToNotBeSetToBlack_fraction,
						true //isModifyByteRectIn
						//true //true return ByteRect (else Float32Array)
					);
				}*
				
				//if(pic != byteRectIn){
					//copyBytes(pic.bytes, byteRectIn.bytes);
					//TODO optimize: by not creating another ByteRect?
					//TODO optimize: is bytaeRectIn from canvasIn? Does it need to be? Or just call sim.io(dt, pic, byteRectOut) to skip this copyBytes?
				//}
				//sim.io(dt, byteRectIn, byteRectOut);
				//canvasInContext.putImageData(canvasInImageData, 0, 0);
				
				copyBytes(pic.bytes, byteRectOut.bytes);
				
				canvasOutContext.putImageData(canvasOutImageData, 0, 0);
				//if((webcamFrames%10)==0) console.log("webcamFpsObserved="+webcamFpsObserved+"    frames="+webcamFrames+" time="+now);
			}
			// display results in page
			//document.getElementById('results').innerHTML =  '<img src="'+data_uri+'"/>';
		}
	);
};
*/

var between = (min, val, max)=>Math.max(min,Math.min(val,max));

var betweenInt = (min, val, max)=>Math.round(Math.max(min,Math.min(val,max)));

var asByte = x=>Math.max(0,Math.min(Math.floor(x),255));

var warnIfStrangeDt = function(dt){
	//a good dt is .02 for 50 fps, or .01 is better, but anything less than .01 wont be much noticable improvement in graphics,
	//but it might improve the convergence of the physics energy equations
	//(springs, color matching, etc, all part of a single energy equation, TODO)
	//to run multiple physics/energy/puzzleSolving cycles per display/webcam cycle.
	if((dt <= 0) || (dt > .2)) console.log('dt='+dt);
};

var rand = function(min,max){
	return min+(max-min)*Math.random();
};

//0 to maxExcl-1, if 0<=maxExcl<approx_2pow53minusALittleForRoundoffSoMaybe2pow50 after that doubles cant represent all possible integers.
var randInt = (maxExcl)=>Math.floor(Math.random() * maxExcl);

/*var Slidebar = function(){
	this.getFraction = 
	<input type="range" id="vol" min="0" max="1000000" value="777777" oninput="console.log(this.valueAsNumber/1000000);">
};*/

//0..255
var randByte = ()=>Math.floor(Math.random()*256);

var onceRandomBytes = [];
var testPointEnabled = [];
for(let i=0; i<30000; i++){
	onceRandomBytes.push(randByte());
	//onceRandomBytes.push(Math.floor(Math.random()*256));
	testPointEnabled.push(true);
}

var paintTestsOntoByteRectIn = function(now, byteRect){
	let circleRadius = 15;
	let which_onceRandomBytes = 0;
	let isDisplaying = true;
	let numTestPoints = 70;
	let freq = .05; //turns of this test object per second
	/*if(Math.random()<.15){
		for(let j=0; j<numTestPoints; j++){
			if(Math.random() < .3){
				//randomly display or not display some parts of this object, to test if the voxels move there anyways cuz of springs
				isDisplaying = !isDisplaying;
			}
			testPointEnabled[j] = isDisplaying;
		}
	}*/
	for(let i=0; i<numTestPoints; i++){
		
		if(testPointEnabled[i]){
			let a = 2*Math.PI*(i/numTestPoints+now*freq);
			let yFraction = .5+.3*Math.sin(a);
			let xFraction = .5+.3*Math.cos(a);
			let red = onceRandomBytes[which_onceRandomBytes];
			let green = onceRandomBytes[which_onceRandomBytes+1];
			let blue = onceRandomBytes[which_onceRandomBytes+2];
			paintDonut(
				byteRect,
				byteRect.height*yFraction,
				byteRect.width*xFraction,
				0, //inner radius
				circleRadius,
				red,
				green,
				blue
			);
		}
		which_onceRandomBytes += 3;
	}
};

/** 4x4 identityFunc affine transform */
var newIdentAftrans = function(){
	return Float32Array.of(1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1);
	/*let a = new Float32Array(16);
	a[AXX] = 1;
	a[AYY] = 1;
	a[AZZ] = 1;
	a[ASS] = 1;
	return a;
	*/
};

var newRandAftransNearIdent = function(){
	let a = newIdentAftrans();
	for(let i=0; i<a.length; i++){
		a[i] += .1*(Math.random()*2-1);
	}
	return a;
};

var newRandAftrans = function(){
	let a = new Float32Array(16);
	for(let i=0; i<a.length; i++){
		a[i] = Math.random()*4-2; //-2 to 2. TODO unit bellcurve
	}
	return a;
};

var defaultNumAnglesOfCircle = 100;

var verifyAftrans = function(aftrans){
	if(!aftrans) throw 'aftrans='+aftrans;
	//if(!(aftrans.length)) throw 'aftrans.length='+aftrans.length;
	if(aftrans.length != 16) throw 'aftrans.length='+aftrans.length+' but must be 16 cuz 4x4';
};

const emptyArray = new Float32Array(0);

//ab is Float32Array(a*b). bc is Float32Array(b*c). Returns Float32Array(a*c).
//TODO GPU.js if its big, but might want to merge multiple kernels to happen at once for intheory lower lag.
//Theres some func to "combine kernels" in GPU.js.
//
//Dont use GPU.js every time cuz this will be called about 150 times per video frame, on small arrays,
//just to create equatorAngles+poleAngles balls to check for equatorAngles*equatorAngles*poleAngles possible rotations
//(then do a similar thing but to get about 0.1 pixel precision of 3d position and 3d angle of tennis ball used as 6d joystick).
var matmul = function(ab, bc, a, b, c){
	return matmulCpu(ab, bc, a, b, c);
};

var aftransOfAftrans = function(outerAftrans, innerAftrans){
	//FIXME is this right? Use transpose or not? Swap the order of outer and inner?
	//return matmul(outerAftrans,transpose4x4(innerAftrans),4,4,4);
	return matmul(outerAftrans,innerAftrans,4,4,4);
};

var copyBytes = function(bytesIn, bytesOut){
	for(let i=0; i<bytesOut.length; i++){
		bytesOut[i] = bytesIn[i];
	}
};


var matmulCpu = function(ab, bc, aSize, bSize, cSize){
	let ret = new Float32Array(aSize*cSize);
	for(let a=0; a<aSize; a++){
		for(let c=0; c<cSize; c++){
			//TODO this will be most of the GPU code in matmulGpu:
			let sum = 0; //double*double then cast to float differs from [float*float which is intheory what you get in GPU.js. TODO align with lazycl]
			for(let b=0; b<bSize; b++){
				sum += ab[a*bSize+b]*bc[b*cSize+c];
			}
			ret[a*cSize+c] = sum;
		}
	}
	return ret;
};

var transpose4x4 = function(aftrans){
	let a = new Float32Array(16);
	for(let i=0; i<4; i++){
		for(let j=0; j<4; j++){
			a[4*i+j] = aftrans[4*j+i];
		}
	}
	return a;
};

var dom = id=>document.getElementById(id);


/** matrix inverse for Float32Array(16) as 4x4. Throws if matrix is not invertible (happens when it has 0s in certain places, etc) Example:
<br><br>
Float32Array(16)[40, -40, 0, 0, 40, 80, 0, 0, 50, -40, 10, 0, 190, 200, 0, 0]
for(i in af) if(af[i] == 0) af[i] = 1
<br><br>
1
inverse4x4(af)
Float32Array(16)[0.006666666828095913, -0.013333333656191826, -0, 0.006666666828095913, -0.008333333767950535, 0.008333333767950535, -0, -0, -0.11851851642131805, 0.014814814552664757, 0.1111111119389534, -0.007407407276332378, 0.5185185074806213, 0.8518518805503845, -0.1111111119389534, -0.25925925374031067]
aftransOfAftrans(inverse4x4(af),af)
Float32Array(16)[1, 0, 0, 0, 0, 1, 0, 0, 1.3969838619232178e-7, -1.1175870895385742e-7, 1, 2.7939677238464355e-9, 0.0000017136335372924805, 0.000003874301910400391, 1.4901161193847656e-8, 1]
<br><br>
af
Float32Array(16)[38.17185974121094, -37.34263610839844, 0.567450225353241, 0.9653493165969849, 44.762725830078125, 75.62342834472656, 2.032400608062744, 1.092972755432129, 47.32026290893555, -49.86602020263672, 9.876603126525879, 0.9346176981925964, 314.396484375, 233.5746307373047, 4.626655578613281, 4.095148086547852]
aftransOfAftrans(af,inverse4x4(af))
Float32Array(16)[1, -2.8939762586333018e-8, -6.901840432504969e-9, 6.330946877852739e-9, 6.891576731504756e-8, 0.9999999403953552, -4.097648442780155e-9, 7.388507139438616e-9, 2.5632354905269494e-8, -1.2609987720679783e-8, 1, 7.609613383863234e-9, 2.213476051338148e-7, -1.2695329587586457e-7, -1.5567275468697517e-8, 1.0000001192092896]
aftransOfAftrans(inverse4x4(af),af)
Float32Array(16)[1.0000001192092896, 6.570027011321145e-8, 1.0449441312232466e-9, 1.00316499551667e-9, 1.7116050798904325e-8, 1, 6.754415915466438e-10, 4.2082873297211165e-10, 2.8648202032854897e-8, 9.683519408554275e-8, 1, 1.570354069002633e-9, -0.0000015082332538440824, -0.000004397804332256783, -1.0071694589441904e-7, 1]
<br><br>
got this from asking wolframalpha "inverse {{a, b, c, d}, {e, f, g, h}, {i, j, k, l}, {m, n, o, p}}", and it responded with the fact of math in this code.
https://www.wolframalpha.com/input/?i=inverse+%7B%7Ba%2C+b%2C+c%2C+d%7D%2C+%7Be%2C+f%2C+g%2C+h%7D%2C+%7Bi%2C+j%2C+k%2C+l%7D%2C+%7Bm%2C+n%2C+o%2C+p%7D%7D
*/
var inverse4x4 = function(aftrans){
	let a = aftrans[0];
	let b = aftrans[1];
	let c = aftrans[2];
	let d = aftrans[3];
	let e = aftrans[4];
	let f = aftrans[5];
	let g = aftrans[6];
	let h = aftrans[7];
	let i = aftrans[8];
	let j = aftrans[9];
	let k = aftrans[10];
	let l = aftrans[11];
	let m = aftrans[12];
	let n = aftrans[13];
	let o = aftrans[14];
	let p = aftrans[15];
	let W = a*f*k*p - a*f*l*o - a*g*j*p + a*g*l*n + a*h*j*o - a*h*k*n - b*e*k*p + b*e*l*o + b*g*i*p - b*g*l*m - b*h*i*o + b*h*k*m;
	let X = c*(e*j*p - e*l*n - f*i*p + f*l*m + h*i*n - h*j*m);
	let Y = d*(- e*j*o + e*k*n + f*i*o - f*k*m - g*i*n + g*j*m);
	let mul = 1/(W + X + Y);
	if(mul == Infinity) throw 'Not invertible matrix';
	return Float32Array.of(
		(f*k*p - f*l*o - g*j*p + g*l*n + h*j*o - h*k*n)*mul,
		( - b*k*p + b*l*o + c*j*p - c*l*n - d*j*o + d*k*n)*mul,
		(b*g*p - b*h*o - c*f*p + c*h*n + d*f*o - d*g*n)*mul,
		( - b*g*l + b*h*k + c*f*l - c*h*j - d*f*k + d*g*j)*mul,
		( - e*k*p + e*l*o + g*i*p - g*l*m - h*i*o + h*k*m)*mul,
		(a*k*p - a*l*o - c*i*p + c*l*m + d*i*o - d*k*m)*mul,
		( - a*g*p + a*h*o + c*e*p - c*h*m - d*e*o + d*g*m)*mul,
		(a*g*l - a*h*k - c*e*l + c*h*i + d*e*k - d*g*i)*mul,
		(e*j*p - e*l*n - f*i*p + f*l*m + h*i*n - h*j*m)*mul,
		( - a*j*p + a*l*n + b*i*p - b*l*m - d*i*n + d*j*m)*mul,
		(a*f*p - a*h*n - b*e*p + b*h*m + d*e*n - d*f*m)*mul,
		( - a*f*l + a*h*j + b*e*l - b*h*i - d*e*j + d*f*i)*mul,
		( - e*j*o + e*k*n + f*i*o - f*k*m - g*i*n + g*j*m)*mul,
		(a*j*o - a*k*n - b*i*o + b*k*m + c*i*n - c*j*m)*mul,
		( - a*f*o + a*g*n + b*e*o - b*g*m - c*e*n + c*f*m)*mul,
		(a*f*k - a*g*j - b*e*k + b*g*i + c*e*j - c*f*i)*mul
	);
};

/** given a Float32Array(prevCols*prevRows) viewed as [prevCols][prevRows], returns a new Float32Array to be viewed as [prevRows][prevCols]. */
var transpose = function(matrix, prevCols, prevRows){
	if(matrix.length != (prevCols*prevRows)) throw 'matrix.length='+matrix.length+' prevCols='+prevCols+' prevRows='+prevRows;
	let ret = new Float32Array(matrix.length);
	for(let pc=0; pc<prevCols; pc++){
		for(let pr=0; pr<prevRows; pr++){
			ret[pr*prevCols+pc] = matrix[pc*prevRows+pr];
		}
	}
	return ret;
};


const twoPi = 2*Math.PI;


let aftransStr = function(aftrans){
	return 'Float32Array.of('+aftrans[0]+', '+aftrans[1]+', '+aftrans[2]+', '+aftrans[3]+', '
		+aftrans[4]+', '+aftrans[5]+', '+aftrans[6]+', '+aftrans[7]+', '
		+aftrans[8]+', '+aftrans[9]+', '+aftrans[10]+', '+aftrans[11]+', '
		+aftrans[12]+', '+aftrans[13]+', '+aftrans[14]+', '+aftrans[15]+')';
};

var radiusOfAftrans4x4 = af=>Math.hypot(af[AXX],af[AXY],af[AXZ],af[AYX],af[AYY],af[AYZ],af[AZX],af[AZY],af[AZZ]);



var copyFloat32Array = function(arr){
	return Float32Array.from(arr);
};

var copyFloat32ArrayFromTo = function(from, to){
	if(from.length != to.length) throw 'Diff sizes';
	for(let i=0; i<from.length; i++) to[i] = from[i]; //TODO optimize by calling Float32Array func to do this
};

/** a dimension on a gamepad, such as right joystick horizontal (-1 to 1) or left analog trigger (0 to 1),
except the part near 0 is ignored and farther away is moved to be the new 0 so it feels smooth,
but with deadzone so if you arent holding it, it doesnt drift a little.
<br><br>
TODO fix this with better statistics, automatic calibration of center position and size of deadzone.
Statistically, theres a small range of possible joystick positions that the joystick will be in that range unusually often,
and those are either as far as it can be pushed in some direction or when person is not touching the joystick.
If, for each dimension separately, take stats in a float[10000], which is 10000 positions between -1 and 1,
and for each, decay toward the fraction of the time the joystick has been below that position (such as between -1 and .312, is the .312 position),
then can get the fraction of the time it has been in any range by subtracting the 2 ends, such as range .029 to .312 (joystick position)
happened float[indexOf(.312)]-float[indexOf(.029)] fraction of the time (which will always range 0 to 1).
The deadzone of the joystick should be a range somewhere near the middle thats a range its at more often than any other range of the same size.
Instead of decay rate (which could use DecayBell.java, todo copy that code here, for faster decay when have less data)...
Instead of that, could just add to stats whenever the joystick has moved in the last t time (such as 1 second).
<br><br>
TODO make auto joystick calibration while playing be a separate js library,
which could lead to nobody ever having to calibrate any joystick again in any system,
and it would increase precision of the joystick by making the deadzone smaller and the deadzone would vary its position instead of just its size.
*/
var controlWithDeadzone = function(name, deadZone){
	let val = control(name);
	if(Math.abs(val) < deadZone){
		return 0;
	}else{
		if(val > 0){
			return val-deadZone; //dont jump, it starts as 0 movement at border of deadzone and gradually more
		}else{
			return val+deadZone;
		}
	}
};

//returns [valA, valB] with circle of deadzone.
//Not jumpy. It doesnt jump from 0 to deadZone at deadZone. There, its 0, and gradually more.
var control2WithDeadzone = function(deadZone, nameA, nameB){
	let valA = control(nameA);
	let valB = control(nameB);
	let len = Math.hypot(valA,valB);
	if(len < deadZone) return [0, 0];
	let newLen = len-deadZone;
	let mul = newLen/len;
	return [valA*mul, valB*mul];
};

//af is normally selectedOb.aftrans such as a ball to move and rotate.
var controllerTransformsAftrans = function(controllerName, afIn, dt){
	
	//TODO optimize: can this be done by returning an aftrans thats reusable, such as to rotate all the points on the ball?
	
	let mulRotate = 6*dt;
	let mulResize = 2.5*dt;
	let mulMove = 620*dt;
	
	let af = copyFloat32Array(afIn);
	
	for(let i=12; i<16; i++) af[i] = 0; //centered at origin. Put these back after rotations.
	
	
	
	
	let deadZone = .1; //FIXME get this statistically
	let mAndN = control2WithDeadzone(deadZone, controllerName+'_dim0', controllerName+'_dim1'); //left joystick
	let m = mAndN[0];
	let n = mAndN[1];
	let oAndP = control2WithDeadzone(deadZone, controllerName+'_dim2', controllerName+'_dim3'); //right joystick
	let o = oAndP[0];
	let p = oAndP[1];
	let q = controlWithDeadzone(controllerName+'_btn6',deadZone); //left analog trigger, 0..1
	let r = controlWithDeadzone(controllerName+'_btn7',deadZone); //right analog trigger, 0..1
	let qr = r-q; //-1..1
	
	let lb = controlWithDeadzone(controllerName+'_btn4',deadZone);
	let rb = controlWithDeadzone(controllerName+'_btn5',deadZone);
	let mulSize = 1+(rb-lb)*mulResize;
	
	let angleB = m*mulRotate;
	
	let angleC = n*mulRotate;
	
	let angleD = qr*mulRotate;
	
	console.log('angleB='+angleB+' angleC='+angleC+' angleD='+angleD);
	
	
	/*c[AYY] = Math.cos(angleD);
	c[AYX] = -Math.sin(angleD);
	c[AXY] = Math.sin(angleD);
	c[AXX] = Math.cos(angleD);
	*/
	
	//let dimA = AX;
	//let dimB = AY;

	let dimA = 0;
	let dimB = 0;
	let angle = 0;
	for(let kindOfRotation=0; kindOfRotation<3; kindOfRotation++){
		switch(kindOfRotation){
		case 0:
			dimA = AX;
			dimB = AZ;
			angle = angleB;
		break;case 1:
			dimA = AY;
			dimB = AZ;
			angle = angleC;
		break;case 2:
			dimA = AX;
			dimB = AY;
			angle = angleD;
		}
		for(let i=0; i<4; i++){
			//if((i == dimA) || (i == dimB)){
			
				//let indexJ = dimA*4+i; //FIXME i*4+dimA?
				//let indexK = dimB*4+i; //FIXME i*4+dimB?
				let indexJ = i*4+dimA;
				let indexK = i*4+dimB;
				let prevValJ = af[indexJ];
				let prevValK = af[indexK];
				af[indexJ] = prevValJ*Math.cos(angle) - prevValK*Math.sin(angle); //TODO optimize by reusing sin and cos
				af[indexK] = prevValJ*Math.sin(angle) + prevValK*Math.cos(angle);
			//}
		}
		
		/*
		[dimA*4+dimB] = Math.cos(angleD);
		c[dimA*4+dimB] = -Math.sin(angleD);
		c[dimA*4+dimB] = Math.sin(angleD);
		c[dimA*4+dimB] = Math.cos(angleD);
		*/
	}
	
	af[AXX] *= mulSize;
	af[AXY] *= mulSize;
	af[AXZ] *= mulSize;
	af[AYX] *= mulSize;
	af[AYY] *= mulSize;
	af[AYZ] *= mulSize;
	af[AZX] *= mulSize;
	af[AZY] *= mulSize;
	af[AZZ] *= mulSize;
	
	for(let i=12; i<16; i++) af[i] = afIn[i]; //get original position back. keep rotation.
	
	af[ASX] += o*mulMove;
	af[ASY] += p*mulMove;
	
	return af;
};


var nextIdNum = 0;
//prefix is optional
var newId = function(prefix){
	if(!prefix) prefix = 'id';
	return (prefix+(nextIdNum++));
};

//var copySliderToObField = function(slider, ob, field){
//};

//log<base>(val), such as log<e>(e^3)==3
var logBase = function(base, val){
	return Math.log(val)/Math.log(base);
};

//TODO no escapes cuz its field names, but wouldnt hurt to have them anyways
let arrayOfFieldNamesToJsCodeUsingSingleQuotes = function(array){
	let s = '[';
	for(let i in array){
		if(i > 0) s += ', ';
		s += "'"+array[i]+"'";
	}
	return s+']';
};

//used by createControlsForAftransInDiv to refer to js objects in a string of code outside this namespace.
var vars = {};

//filled by getButtonsJoysticksEtc() many times per second.
var controls = {};

/** get something in the controls map or 0 if its not there. Example: control('gamepad0_dim3') returns a number -1 to 1
for that joystick axis, if its a joystick and if there is a first (0th) gamepad.
*/
var control = function(key){
	//TODO call getButtonsJoysticksEtc again? check if its the same millisecond since called it last, and only call again if isnt.
	return controls[key] || 0;
};

//Example: let x = newVar(10); eval(x+' = x*x+5;'); eval(x) is 105.
//used by createControlsForAftransInDiv to refer to js objects in a string of code outside this namespace.
var newVar = function(val){
	let id = newId();
	vars[id] = val;
	return 'vars.'+id;
};


var isFirstUseOfSimAfterWebcamStarted = true;

var mouseY = 0;
var mouseX = 0;
var mouseYFraction = 0;
var mouseXFraction = 0;

//for mouse to rotate andOr move ball. This could be any game object (that has a .aftrans and .childs etc), such as Ball or AfPoint.
//TODO move this and trySetSelectedOb into Sim
var selectedOb = null;

var sim = null; //set in window.onload

//returns true/false did it set selectedOb
var trySetSelectedOb = function(ob){
	let allowChangeIfSomethingAlreadySelected = (!sim || sim.allowChangeSelectedObIfSomethingAlreadySelected);
	if(ob && (!selectedOb || allowChangeIfSomethingAlreadySelected)){
		selectedOb = ob;
		return true;
	}
	return false;
};

var balls = [];


//A ball is a 2d circle (y x) with radius to make it 3d, and a color,
//that moves to fit itself to what a webcam sees, trying to find a ball (normally a tennis ball).
//For lower lag webcam, use lower resolution reading from webcam, but canvas can still be high resolution cuz its faster.
//TODO Will get sub-pixel precision from color in some cases, so dont worry so much about low resolution webcam. bilinear interpolation.
var Ball = function(){
	//this.pos = new Float32Array(4); //position

	//If false, uses ryxrgbDerivs. If true, uses evolveBallXYRadiusToward which is the newer better way but so far is buggy (2023-4-23).
	//this.evolveInsteadOfGradient = false; //TODO default to true when thats working better
	//moved evolveInsteadOfGradient to options.ballFinderFunc

	//radius (same range as y and x) changes depending on whats at the perimeter of the circle,
	//shrinks if its not a good color match, gets bigger if it is a good color match,
	//and considering that fingers etc can be over parts of the ball.
	this.radius = 10;
	this.pushDradius = 0;
	this.pushDradiusScale = 1000; //FIXME nonlinear scale cuz it gets bigger faster the closer it is at constant speed toward camera
	this.minRadius = 4; //FIXME adjust these from canvas size and how big a ball is likely to be seen considering 3d
	this.maxRadius = 30;
	
	//y and x move toward the current color in what webcam sees.
	//TODO what range should these be in?
	this.y = 90;
	this.pushDy = 0; //cam pushes y, so this.y += this.pushDy*this.pushDxyScale*dt
	this.x = 105;
	this.pushDx = 0;
	this.pushDxyScale = 1000;
	//this.pushDxyScale = 0;
	this.minX = 10; //FIXME get this from canvas size even if it changes
	this.maxX = 150;
	this.minY = 10;
	this.maxY = 120;

	//TODO start using the "blur" vars. As of 2023-4-23 they're not used but am planning to use them for more precision and lower lag later.
	//They will need to be hooked in a few places, including evolveBallXYRadiusToward, ryxrgbDerivs (if still ever use that,
	//even if only to paint the predicted ball), and maybe other places.
	//
	//
	//for motionBlur, which webcam often sees and ball prediction needs to consider blurred pixels to find ball at lower lag and more precise 3d position.
	//radius, y, and x choose a circle on screen. blurY and blurX are a direction from there to extend a "rounded line" so theres 2 circles,
	//one at (radius,y-blurY/2,x-blurX/2) and one at (radius,y+blurY/2,x+blurX/2). Fill in all pixels between that (its a 2d shape on screen)
	//so its a convex shape made of a tilted rectangle and 2 half circles at its ends. If blurY and blurX are both 0, then the rectangle is size 0
	//so still appears as a circle.
	this.blurY = 0;
	this.blurX = 0;
	this.minBlurLen = 0; //min Math.hypot(this.blurY,this.blurX)
	this.maxBlurLen = 30; //max Math.hypot(this.blurY,this.blurX)
	this.pushBlurY = 0;
	this.pushBlurX = 0;
	//should be high cuz motionBlur will often change alot from one video frame to the next,
	//though isnt completely random so knowing prev blurY and blurX will help predict the next.
	this.pushBlurScale = 3000;
	
	//color decays toward whatever color webcam sees intersecting the circle (y x radius)
	this.red = 200;
	this.green = 200;
	this.blue = 10;
	this.pushDred = 0;
	this.pushDgreen = 0;
	this.pushDblue = 0;
	this.pushDcolorScale = 10;
	this.minRed = 0;
	this.maxRed = 255;
	this.minGreen = 0;
	this.maxGreen = 255;
	this.minBlue = 0;
	this.maxBlue = 255;
	
	//TODO store derivs here as returned by ryxrgbDerivs?
	//or should Ball just be an array of these 6 numbers, and another 6 as their derivs?
};

Ball.prototype.normTargetColorToSum = function(targetSum){
	let sum = this.red+this.green+this.blue;
	if(sum == 0){
		this.red = this.green = this.blue = Math.round(targetSum/3);
	}else{
		let mul = targetSum/sum;
		this.red *= mul;
		this.green *= mul;
		this.blue *= mul;
		//FIXME this might keep adding roundoff and recolor farther and farther over time for no good reason
	}
};

Ball.prototype.copy = function(){
	let b = new Ball();
	let fields = Object.keys(this);
	for(let field of fields){
		if(this.hasOwnProperty(field)){ //FIXME does this get other fields than i defined? Is there a more efficient way?
			//console.log('Copying field '+field);
			b[field] = this[field];
		}
	}
	return b;
};

//returns a snapshot of this ball as an AvmLambda.
Ball.prototype.toAvmLambda = function(){
	return {...this};
};

//modify this ball, copy from fn.d which should be a {...}.
Ball.prototype.fromAvmLambda = function(fn){
	for(let field in fn){
		//if(fn.hasOwnProperty(field)){
			this[field] = fn[field];
		//}
	}
};

//AvmLambda form of Ball.prototype.evolveBallXYRadiusToward except only the evolveByLoopSquareOverCacheOfPotentialEnergyFloats part.
var BallEvolveBallXYRadiusToward = W(`(me,ball,pic,numTries)=>{
	FIXMEFIXME
}`);

//returns {population: [...], cumulativePotentialEnergyFloats: ..., potentialEnergyFloats: ...} but either of those *floats may be null.
Ball.prototype.evolveBallXYRadiusToward = function(pic, numTries){
	let ret = {
		population: null,
		cumulativePotentialEnergyFloats: null,
		potentialEnergyFloats: null
	};
	//let mutableBall = this.copy();
	//let firstArr = mutableBall.copyToArray([0,0,0]);
	let firstArr = [this.radius, this.y, this.x];
	
	let minRadius = this.minRadius;
	let maxRadius = this.maxRadius;
	let minY = this.minY;
	let maxY = this.maxY;
	let minX = this.minX;
	let maxX = this.maxX;
	let modifyToHoldInRange = function(arr){
		arr[0] = between(minRadius, arr[0], maxRadius);
		arr[1] = between(minY, arr[1], maxY);
		arr[2] = between(minX, arr[2], maxX);
	};
	
	let red = this.red;
	let green = this.green;
	let blue = this.blue;
	//console.log('evolveBallXYRadiusToward rgbsum='+(red+green+blue));
	let population = [firstArr];



	let scorer;
	let cachePixelFloats = null;
	//let cumulativeColorMatchPixels = null; //Float32Array(height*width)
	//let cumulativeColorMatchPixels_middleStepJustColorMatch = null; //Float32Array(height*width)
	const height = this.width;
	const width = this.width;
	switch(options.ballFinderFunc){
		case 'moveByDirectDeriv': case 'moveByPotentialEnergyDeriv':{
			throw 'Cant do that here. Use ByteRect.ryxrgbDerivs instead. options.ballFinderFunc='+options.ballFinderFunc;
		}break; case 'evolveByNoncachedPotentialEnergy':{
			scorer = function(arr){
				if(arr.cache_score === undefined){
					//mutableBall.copyFromArray(arr);
					//arr.cache_score = mutableBall.ryxrgbPotentialEnergy(pic); //roll up gradient. higher is better (FIXME).
					let radius = arr[0];
					let y = arr[1];
					let x = arr[2];
					arr.cache_score = pic.ryxrgbPotentialEnergy(radius, y, x, red, green, blue); //roll up gradient. higher is better (FIXME).
				}
				return arr.cache_score;
			};
		}break; case 'evolveByCumulativeCacheOfPotentialEnergyFloats':{
			throw 'FIXME this doesnt work yet, and even if it did, it would only be more efficient than loopSquareOverCacheOfPotentialEnergyFloats if ball is high resolution (alot of pixels in radius). Its just faster to loop over a row of pixels in Float32Array than to compute Math.sqrt etc, BUT it might end up being faster if cache those int offsets of the perimeter of every possible circle (ignoring where its center is) to a precision of 1/16 pixel increments of radius. But for now just use loopSquareOverCacheOfPotentialEnergyFloats.'.
			cachePixelFloats = pic.cacheColorWeight(red, green, blue, true);
			ret.cumulativePotentialEnergyFloats = cachePixelFloats;
			scorer = function(arr){
				if(arr.cache_score === undefined){
					let radius = arr[0];
					let y = arr[1];
					let x = arr[2];
					//var ryxrgbPotentialEnergyAtCacheCumulative = function(cumulative, width, radius, centerY, centerX){
					arr.cache_score = ryxrgbPotentialEnergyAtCacheCumulative(cachePixelFloats, height, width, radius, y, x); //roll up gradient. higher is better (FIXME).
					//arr.cache_score = pic.ryxrgbPotentialEnergy(radius, y, x, red, green, blue); //roll up gradient. higher is better (FIXME).
				}
				return arr.cache_score;
			};
		}break; case 'evolveByLoopSquareOverCacheOfPotentialEnergyFloats':{
			//TODO rename the following var, cuz its not cumulative...
			//cumulativeColorMatchPixels_middleStepJustColorMatch = pic.cacheColorWeight(red, green, blue, false);
			cachePixelFloats = pic.cacheColorWeight(red, green, blue, false);

			//added this 2023-5-2 cuz ball is white/hill but should be black/valley. Did it work?
			//for(let i=0; i<cachePixelFloats.length; i++) cachePixelFloats[i] = -cachePixelFloats[i];

			ret.potentialEnergyFloats = cachePixelFloats;
			scorer = function(arr){
				if(arr.cache_score === undefined){
					//cumulativeColorMatchPixels_middleStepJustColorMatch = pic.cacheColorWeight(red, green, blue, false);
					let radius = arr[0];
					let y = arr[1];
					//return -y; //FIXME just testing to see if it puts at top of screen when do this
					//return y; //FIXME just testing to see if it puts at bottom of screen when do this
					let x = arr[2];
					//var ryxrgbPotentialEnergyAtCacheCumulative_butDoNoncumulativeMiddleStepOnly = function(colorMatchFloats, height, width, radius, y, x){
					//TODO remove the bytesForTesting param. its there cuz its not matching what ryxrgbPotentialEnergy does 2023-4-25.
					//let bytesForTesting = pic.bytes;
					//var ryxrgbPotentialEnergyAtCacheCumulative_butDoNoncumulativeMiddleStepOnly = function(colorMatchFloats, height, width, radius, y, x, bytesForTesting){
					
					//throw 'FIXMEFIXME';
					arr.cache_score = loopSquareOverCacheOfPotentialEnergyFloats(
						cachePixelFloats, pic.height, pic.width, radius, y, x, red, green, blue);
					//renamed ryxrgbPotentialEnergyAtCacheCumulative_butDoNoncumulativeMiddleStepOnly_2 to loopSquareOverCacheOfPotentialEnergyFloats
					
					//arr.cache_score = ryxrgbPotentialEnergyAtCacheCumulative_butDoNoncumulativeMiddleStepOnly_2(
					//	cumulativeColorMatchPixels_middleStepJustColorMatch, pic, pic.height, pic.width, radius, y, x, red, green, blue);
					//TODO arr.cache_score = ryxrgbPotentialEnergyAtCacheCumulative_butDoNoncumulativeMiddleStepOnly(
					//	cumulativeColorMatchPixels_middleStepJustColorMatch, height, width, radius, y, x, bytesForTesting); //roll up gradient. higher is better (FIXME).
					//ByteRect.prototype.ryxrgbPotentialEnergy = function(radius, y, x, r, g, b, optionalByteRectOut){
					//arr.cache_score = pic.ryxrgbPotentialEnergy(radius, y, x, red, green, blue);
				}
				return arr.cache_score;
			};
		}break; default:{
			throw 'Unknown options.ballFinderFunc='+options.ballFinderFunc;
		}
	}


	let sorter = function(arrA,arrB){
		//return Math.sign(scorer(arrA)-scorer(arrB)); //FIXME is this reversed?
		return Math.sign(scorer(arrB)-scorer(arrA)); //FIXME is this reversed?
	};
	let maxBatchSize = numTries<20 ? 1 : Math.ceil(Math.sqrt(numTries));
	let triesLeft = numTries;
	let weightedRandomPopulationIndex = function(){ return between(0,Math.floor((Math.random()**3)*population.length),population.length-1); };
	let randomnessToPlusMinusPerDim = 10;
	let arrToString = function(arr){
		return JSON.stringify(arr)+'_score'+scorer(arr);
	};
	while(triesLeft){
		//make a batch of new arrays (ball positions etc), using harmonySearch and random mutations on the higher scoring balls.
		let batchSize = Math.min(triesLeft,maxBatchSize);
		let batch = [];
		for(let i=0; i<batchSize; i++){
			let indexA = weightedRandomPopulationIndex();
			let newArr = [0,0,0];
			if(population.length <2 || Math.random() < .5){ //mutate 1
				let parent = population[indexA];
				for(let i=0; i<newArr.length; i++){
					newArr[i] = parent[i] + (Math.random()*2-1)*randomnessToPlusMinusPerDim;
				}
				modifyToHoldInRange(newArr);
				if(options.displayDetailedEvolution) console.log('Mutated '+arrToString(parent)+' to make '+arrToString(newArr));
			}else{ //harmonySearch 2
				let indexB;
				do{
					indexB = weightedRandomPopulationIndex();
				}while(indexB == indexA);
				let parentA = population[indexA];
				let parentB = population[indexB];
				//if this is 0, its all parentA. if 1, all parentB. if 2, its past parentB opposite direction of parentA. or gradually.
				let mix = Math.random()*4-2;
				for(let i=0; i<newArr.length; i++){
					newArr[i] = parentA[i]*(1-mix) + mix*parentB[i];
				}
				modifyToHoldInRange(newArr);
				if(options.displayDetailedEvolution) console.log('HarmonySearched '+arrToString(parentA)+' and '+arrToString(parentB)+' to make '+arrToString(newArr));
			}
			batch.push(newArr); //dont put them in population yet so they arent chosen for next generation until sorted by score.
		}
		population.push(...batch);
		//only computes score on each arr the first time, so this isnt comparing it to pixels/pic again which would be very wasteful.
		population.sort(sorter);
		if(options.displayDetailedEvolution) console.log('After batch size '+batchSize+' population size is '+population.length+' and population[0] is '+arrToString(population[0])+
			' and population['+(population.length-1)+'] is '+population[+(population.length-1)]+' triesLeft='+triesLeft);
		//sort the array
		triesLeft--;
	}
	let bestArr = population[population.length-1];
	if(options.logEvolutionSummaryPerVideoFrame) console.log('Evolved from '+arrToString(firstArr)+' to '+arrToString(bestArr)+
		'. Now copying that back into Ball it was called from, and returning population in case you wanted it for logging or testing or something.');

	this.copyFromArray(bestArr);
	ret.population = population;
	return ret;
};

//the array starts with radius x y. might add red green blue. todo later add blurX and blurY cuz webcam sees long motionBlur.
//Returns this Ball.
Ball.prototype.copyFromArray = function(arr){
	if(arr.length > 0) this.radius = arr[0];
	if(arr.length > 1) this.y = arr[1];
	if(arr.length > 2) this.x = arr[2];
	return this;
};

//the array starts with radius x y. might add red green blue. todo later add blurX and blurY cuz webcam sees long motionBlur.
//returns arr;
Ball.prototype.copyToArray = function(arr){
	if(arr.length > 0) arr[0] = this.radius;
	if(arr.length > 1) arr[1] = this.y;
	if(arr.length > 2) arr[2] = this.x;
	return arr;
};

//FIXME supposed to roll down gradient, not up it. Some of these need negating, but i dont want to break stuff so TODO.
//Until this is fixed, will roll up hills and go for higher potentialEnergy. Just negate it when matching to other calculations. TODO.
//
//pic is a ByteRect. Updates this.pushDy, pushDx, pushDradius, pushDred, pushDgreen, and pushDblue.
//Does not update this.y, this.radius, etc.
//
//You can run time backward (except if it hits holdInRange, and except for slight roundoff)
//if you save a copy of the video (1 ByteRect each) and use negative dt.
//Some games (such as Braid) let the player rewind time or only for certain objects but not others.
//Or just use it as pause dt=0.
//
//If optionalPicOut, paints this Ball on it like seeing what was already
//in optionalPicOut but part of it thru a circle of colored glass.
//Its recommended optionalPicOut not be the same ByteRect as pic if theres
//multiple Balls (but you can, it wont break)
//cuz the others would see the modified colors and be less accurate.
Ball.prototype.updateGradient = function(pic, optionalPicOut){
	let gradient = pic.ryxrgbDerivs(this.radius, this.y, this.x, this.red, this.green, this.blue, optionalPicOut);
	//ryxrgbDerivs "returns [dradius, dy, dx, dred, dgreen, dblue], the direction to change 3d position and color"

	//FIXME supposed to roll down gradient, not up it. Some of these need negating, but i dont want to break stuff so TODO.
	//Until this is fixed, will roll up hills and go for higher potentialEnergy. Just negate it when matching to other calculations. TODO.
	this.pushDradius = gradient[0];
	this.pushDy = gradient[1];
	this.pushDx = gradient[2];
	this.pushDred = gradient[3];
	this.pushDgreen = gradient[4];
	this.pushDblue = gradient[5];
};

//After calling updateGradient, update y x radius red green blue, by += dt*scaleVarForEach
//FIXME truncate positions so cant go off screen, outside valid color range, etc.
Ball.prototype.move = function(dt){
	let m = this.pushDxyScale*dt;
	let c = this.pushDcolorScale*dt;
	this.y += this.pushDy*m;
	this.x += this.pushDx*m;
	this.radius += this.pushDradius*this.pushDradiusScale*dt;
	this.red += this.pushDred*c;
	this.green += this.pushDgreen*c;
	this.blue += this.pushDblue*c;
};

//AvmLambda form of Ball.prototype.move. Ball is an AvmLambda wrapper of {y: 20, minY: -300, radius: 14, ...} for example.
//Returns another such ball {...}. Doesnt modify its param, of course.
var BallMove = W(`(me,dt,ball)=>{
	let ret = {...(ball.d)};
	let m = ret.pushDxyScale*dt.d;
	let c = ret.pushDcolorScale*dt.d;
	ret.y += ret.pushDy*m;
	ret.x += ret.pushDx*m;
	ret.radius += ret.pushDradius*ret.pushDradiusScale*dt.d;
	ret.red += ret.pushDred*c;
	ret.green += ret.pushDgreen*c;
	ret.blue += ret.pushDblue*c;
	return W(ret);
`);

var BallHoldInRange = W(`(me,ball)=>{
	let ret = {...(ball.d)};
	ret.y = between(ret.minY, ret.y, ret.maxY);
	ret.x = between(ret.minX, ret.x, ret.maxX);
	ret.radius = between(ret.minRadius, ret.radius, ret.maxRadius);
	ret.red = between(ret.minRed, ret.red, ret.maxRed);
	ret.green = between(ret.minGreen, ret.green, ret.maxGreen);
	ret.blue = between(ret.minBlue, ret.blue, ret.maxBlue);
	return W(ret);
`);


Ball.prototype.holdInRange = function(){
	this.y = between(this.minY, this.y, this.maxY);
	this.x = between(this.minX, this.x, this.maxX);
	this.radius = between(this.minRadius, this.radius, this.maxRadius);
	this.red = between(this.minRed, this.red, this.maxRed);
	this.green = between(this.minGreen, this.green, this.maxGreen);
	this.blue = between(this.minBlue, this.blue, this.maxBlue);
};


/*
Ball.prototype.asPicfn = ball=>{
	const b = ball;
	return function(y,x,colorDim){
		TODO
	};
};*/

/*
FIXME use the yxderiv code instead of this?
//picfn(y,x,RED_or_GREEN_or_BLUE)->brightnessFraction. Its a kind of smooth image, that can wrap a ByteRect or equation.
//TODO different speeds of changing color, radius, and y_and_x, like the sliders adjust the circular voxels in the desktop version.
Ball.prototype.move = function(picfn){
	TODO
};*/



/*
//Given a ByteRect of what webcam sees, return amount of potentialEnergy
Ball.prototype.potentialEnergy = function(pic){
};
*/

/*
//Given a ByteRect of what webcam sees and a possible state of a ball it might be seeing,
//return amount of potentialEnergy, so can use gradient or harmony-search or other ways of finding lower energy.
//Its lower energy when it knows where the ball is in 3d (y x radius) and its color (normally a yellow tennis ball).
var potentialEnergyOfBallAtPic = function(pic, y, x, radius, red, green, blue){
	TODO
};
*/



/*viewMode: 'liveResearchViewModeInNormedColor',
	//viewMode: 'liveResearchViewModeCachedFloats',

	ballFinderFuncEvolveNumTriesPerVideoFrame: 100, //number of harmony-searched/randomMutated evolutions per video frame. Each is a state of all the balls (as of 2023-4-26 evolution only does 1 ball, but older ballFinderFunc's such as moveByDirectDeriv can do many balls, TODO evolve many after 1 ball is working well. Its all 1 potentialEnergy function to evolve, just more dimensions/dims at once. 50 is a little jumpy. 200 is a little too slow. on mobile browsers might have to reduce this.)
	
	//ballFinderFunc: 'moveByDirectDeriv', //the oldest way. doesnt do calculus on potentialEnergy funcs but tries to approximate it directly.
	//ballFinderFunc: 'moveByPotentialEnergyDeriv', //like moveByDirectDeriv except calls ByteRect.potentialEnergy 7 times for calculus 6d gradient.
	//ballFinderFunc: 'evolveByNoncachedPotentialEnergy', //like moveByPotentialEnergyDeriv except done by harmony-search/evolve.
	//ballFinderFunc: 'evolveByCumulativeCacheOfPotentialEnergyFloats', //ByteRect.cacheColorWeight with cumulative param true. Doesnt work as of 2023-4-26.
	ballFinderFunc: 'evolveByLoopSquareOverCacheOfPotentialEnergyFloats', //ByteRect.cacheColorWeight with cumulative param false. This is best as of 2023-4-26.

	
	*useCumulativePixelsOptimization: true,
	//useCumulativePixelsOptimization: false,
	useCumulativePixelsOptimization_butDoNoncumulativeMiddleStepOnlyIfSo: true, //if useCumulativePixelsOptimization, chooses between 2 functions
	doRyxrgbDerivsUsingPotentialEnergy: true, //else an older way. for testing ryxrgbPotentialEnergy since its likely buggy (2023-4-23) and likely doesnt match ryxrgbDerivs
	*
	startNumBalls: 1,
	displayDetailedEvolution: false,
	//putYellowCircleAtMouseAsTestBall: true,
	putYellowCircleAtMouseAsTestBall: false,
	//putYellowCircleAtMouseAsTestBall: false, //cuz interferes with testing tennis balls sometimes
    colorMatchExponent: 2,
*/




/*
throw 'TODO';

throw 'TODO generalize the return and params of func that process combos of Balls, ByteRects, Float32Array(height*width), options map, etc, so its easier to evolve and easier to try experiments';

var MultiPotenTest = function(potenTests){
	this.potenTests = potenTests;
};

MultiPotenTest.prototype.potentialEnergy = function(potenOptions){
	let poten = 0;
	for(let potenTest of this.potenTests){
		poten += potenTest.potentialEnergy(potenOptions);
	}
	return poten;
};



//yesBalls is list of Ball that should be in pic. noBalls is list of Ball that should not be found in pic (higher potentialEnergy than the yesBalls).
var PotenTest = function(byteRect, yesBalls, noBalls){
	this.byteRect = byteRect;
	this.yesBalls = yesBalls;
	this.noBalls = noBalls;
};

PotenTest.prototype.potentialEnergy = function(potenOptions){
	throw 'TODO eval all yesBalls minus all noBalls on byteRect and return potentialEnergy sun from that. Will need to redesign some things.';
};



var multiPotenTest = new MultiPotenTest();
//TODO multiPotenTest.potenTests.push(new PotenTest(...))
*/

//for(let i=0; i<30; i++) console.log('TODO use '+A+' for MultiPotenTest, graphics, evolution, etc. '+Math.random());




var domSetSize = function(dom, width, height){
	if(dom.width) dom.width = width;
	else dom.style.width = width+'px';
	if(dom.height) dom.height = height;
	else dom.style.height = height+'px';
};

var adjustCanvasEtcSizesToMatchAspectRatioOfWebcamExceptRoundoff = function(){
	let webcamVideo = Webcam.video;
	if(!webcamVideo) throw 'No webcam yet, webcamVideo='+webcamVideo;
	let physicalCameraAspectRatio = webcamVideo.videoWidth/webcamVideo.videoHeight; //may differ from aspectRatio on screen.
	let observedCanvasWidth = canvasOut.width;
	let newCanvasWidth = observedCanvasWidth;
	let newCanvasHeight = Math.ceil(observedCanvasWidth/physicalCameraAspectRatio);
	domSetSize(dom('canvasIn'), newCanvasWidth, newCanvasHeight);
	domSetSize(dom('canvasOut'), newCanvasWidth, newCanvasHeight);
	
};


var FloatsAve = function(floats){
	if(!floats.length) throw 'empty';
	let sum = 0;
	for(let f of floats) sum += f;
	return sum/floats.length;
};

var FloatsDev = function(floats,optionalAve){
	if(!floats.length) throw 'empty';
	let ave = optionalAve===undefined ? FloatsAve(floats) : optionalAve;
	let sumOfSquares = 0;
	for(let f of floats){
		let diff = f-ave;
		sumOfSquares += diff*diff;
	}
	return Math.sqrt(sumOfSquares/floats.length);
};

//to ave 0 dev 1. Returns a new array.
var normFloatsToUnitBell = function(floats){
	let ret = new Float32Array(floats.length);
	let ave = FloatsAve(floats);
	let dev = FloatsDev(floats, ave);
	for(let i=0; i<floats.length; i++){
		ret[i] = (floats[i]-ave)/dev;
	}
	return ret;
};

//FIXME swapped them again
//auto truncates into byte...
//OLD: auto wraps transformToByte(float)'s output. FIXME should that be truncate instead?
var floatsToMonochromeByteRect = function(floats, width, transformToByte){
	let height = floats.length/width;
	if(height != Math.floor(height)) throw 'floats.length='+floats.length+' is not divisible by width='+width;
	let ret = new ByteRect(new Uint8Array(floats.length<<2), height, width);
	for(let i=0; i<floats.length; i++){
		let index = i<<2;
		ret.bytes[index+ALPHA] = 255; //visible
		ret.bytes[index|RED] = ret.bytes[index|GREEN] = ret.bytes[index|BLUE] = transformToByte(floats[i]); //wrap
		//ret.bytes[index|RED] = ret.bytes[index|GREEN] = ret.bytes[index|BLUE] = between(0,transformToByte(floats[i]),255); //truncate
	}
	return ret;
};


var setBallFinderFunc = function(val){
	options.ballFinderFunc = val;
	dom('ballFinderFuncLabel').innerHTML = val;
};

var setViewMode = function(val){
	options.viewMode = val;
	dom('viewModeLabel').innerHTML = val;
};

var mainDiv = null; //set once in window.onload

let isRunningMainLoop = false; //main loop has to stop between painting the screen. Use this to avoid timers possibly running the main loop twice at once.

//TODO move these vars to options
//TODO generate the canvas style instead of duplicating these numbers
//<canvas id="canvasOut" style="transform:matrix(-4,0,0,4,500,200)" width=160 height=120></canvas><br>
let magnifyY = 4, magnifyX = 4;

let avm = A.avm;
if(!avm) throw 'No avm';

window.onload = function(){

	mainDiv = dom('mainDiv');

	if(options.startWebcamAtBoot){
		// Configure a few settings and attach camera
		Webcam.set({
			fps: 120,               // camera frames per second. FIXME? webcamjs seems to ignore this param.
			width: 160, //FIXME changing thse seems to have no effect 2021-8
			height: 120,
			//width: 320, //FIXME changing thse seems to have no effect 2021-8
			//height: 240,
			//image_format: 'png',
			flip_horiz: true,
			image_format: 'jpeg', //FIXME why does this seem to have no effect? jpeg vs png, and jpeg_quality of 90 vs 3?
			//jpeg_quality: 90
			jpeg_quality: 5
		});
		Webcam.attach('#my_camera');
	}else{
		console.log("WARNING: options.startWebcamAtBoot is false so not starting webcam.");
	}

	/*
	// preload shutter audio clip
	var shutter = new Audio();
	shutter.autoplay = true;
	shutter.src = navigator.userAgent.match(/Firefox/) ? 'shutter.ogg' : 'shutter.mp3';
	*/

	updateCanvasObjects();
	//replaceSim();

	dom('canvasOut').addEventListener('mousemove', function(event){
		let rect = this.getBoundingClientRect();
		mouseY = (event.clientY-rect.top)/magnifyY;
		mouseYFraction = between(0,mouseY/this.clientHeight,1);
		mouseX = (rect.left-event.clientX)/magnifyX; //reversed cuz horizontal flip to look like mirror
		mouseXFraction = between(0,mouseX/this.clientWidth,1);
		//trySetSelectedOb(sim.whatsAtYx([mouseY,mouseX]));
		//if(selectedOb) selectedOb.randomizeColors();
	});


	for(let i=0; i<options.startNumBalls; i++){
		let b = new Ball();
		//b.evolveInsteadOfGradient = false; //TODO
		b.y = Math.random()*120;
		b.x = Math.random()*160;
		b.pushDxyScale = 10000;
		b.pushDcolorScale = 3;
		b.radius = Math.random()*20;
		b.red = randInt(256);
		b.green = randInt(256);
		b.blue = randInt(256);
		balls.push(b);
	}

	//the main yellow ball?
	//balls[0].evolveInsteadOfGradient = true;
	balls[0].pushDcolorScale = 0;
	
	balls[0].red = 200;
	balls[0].green = 200;
	balls[0].blue = 0;

	//balls[0].red = 88+1; //88 107 58 was observed in a screenshot 2023-5-2 after normed color. but adding 1 to red and green so sums to 255
	//balls[0].green = 107+1;
	//balls[0].blue = 58;

	balls[0].radius = 10;
	balls[0].y = 80;
	balls[0].x = 80;
	//balls[0].pushDxyScale = 7000;
	balls[0].pushDxyScale = 15000;
	//balls[0].pushDxyScale = 30000;
	//balls[0].pushDxyScale = 700000;
	//balls[0].pushDradiusScale = balls[0].pushDxyScale*.5;
	balls[0].pushDradiusScale = balls[0].pushDxyScale*.2;
	//balls[0].normTargetColorToSum(255); //match the sum of red green and blue in the normed webcam pixels. This has no effect if already sums to that which it should from the numbers above.
	
	


	//why didnt this fix it, and still need to click restart after it loads (to get voxels off edges of screen they moved too fast got stuck)?: sim.restart(); //cuz changed sim.varnames
	
	//createControlsForSimInDiv(sim, dom('controlsDiv_checkboxes'), dom('controlsDiv_sliders'), dom('controlsDiv_buttons'));
	
	let x = function(){
		if(isRunningMainLoop){
			console.log('WARNING: Already isRunningMainLoop='+isRunningMainLoop);
			return;
		}
		isRunningMainLoop = true;
		try{
			if(Webcam.live){ //FIXME also check isPaused here?
				//take_snapshot(sim); use nextState instead
				nextState();
				//dom('buttonsJoysticksEtcDiv').innerHTML = "<br>"+JSON.stringify(getButtonsJoysticksEtc()).replaceAll(',',',<br>');
				//setTimeout(x, 20);
				if(isFirstUseOfSimAfterWebcamStarted){
					isFirstUseOfSimAfterWebcamStarted = false;
					adjustCanvasEtcSizesToMatchAspectRatioOfWebcamExceptRoundoff();
					//sim.restart();
				}
				//if(sim.nextFrameBySetTimeoutElseByRequestanimationframe_warningHigherFpsOutOfSyncCanStillBeLaggierSoKeepThisUnchecked){
				//	setTimeout(x, 1); //likely to get out of sync compared to requestAnimationFrame but seems to get a little higher fps than requestAnimationFrame
				//}else{
					requestAnimationFrame(x);
				//}
			}else{
				console.log('Webcam isnt on yet');
				setTimeout(x, 500);
			}
		}finally{
			isRunningMainLoop = false;
		}
	};
	x();
	setBallFinderFunc(options.ballFinderFunc); //display which one it is
	setViewMode(options.viewMode); //display which one it is

	//setMainTreeState(new TreeState(RootLam));

	//UINode
	let uiNode = uiOf(RootLam);
	uiNode.display();
};


/* Wont need jstree if UINode works out, a fork of Wikibinator203DirectedGraphUI.html modified for AvmLambdas (instead of wikibinator203 lambdas).

//isOpen(fn) and isOpen(fn.n.l.n.r) etc returns true for that branch to be open, false for closed. If you dont give such a func, they're all open except leafs.
//Even leafs can be opened since their left child is identityFunc and right child is themself.
var TreeState = function(fn, isOpen){
	if(!isOpen) isOpen = x=>(x.n.curriesSoFar>0);
	this.fn = fn;
	this.isOpen = isOpen;
};

TreeState.prototype.jstreeMap = function(){
	let ret = {
		text: this.fn.nam,
		state: {opened: this.isOpen(this.fn)},
		children: []
	};
	if(this.fn.n.curriesSoFar == 0){
		ret.icon = 'jstree-file';
	}else{
		ret.icon = 'jstree-folder';
	}
	for(let i=0; i<this.fn.n.curriesSoFar; i++){
		ret.children.push(new TreeState(this.fn.n.l, this.isOpen).jstreeMap());
	}
	if(this.fn.n.curriesSoFar > 0){
		ret.children.push(new TreeState(this.fn.n.r, this.isOpen).jstreeMap());
	}
	return ret;
};

//a TreeState, normally containing a fn that contains rootLam a few levels deep so theres room for user to drag and drop lambda onto lambda to find or create lambda and play with it too.
var setMainTreeState = function(ts){
	let dob = document.getElementById('mainJstree');
	let map = ts.jstreeMap();
	$('#tree').jstree({
		core:{
			"check_callback" : true,
			
			//"name": "default-dark",
			//"dots": false,
			//"icons": false

			data: map
		},
		plugins:['dnd']
	});
};
*/

//both params are string
var saveToCookie = function(key, val){
	return localStorage.setItem(key,val);
};

//param and return are strings, empty string if not found
var loadFromCookie = function(key){
	return localStorage.getItem(key) || '';
};

var saveToCookie_mainCodeTextarea = function(key){
	let code = dom('mainCodeTextarea').value;
	saveToCookie(key,code);
};

var loadFromCookie_mainCodeTextarea = function(key){
	let code = loadFromCookie(key);
	dom('mainCodeTextarea').value = code;
};


//Returns a map of button/joystick/etc name to number in range -1 to 1. TODO Everything not in the map means 0? Or include zeros?
//gamepad api, todo also add mouse, keyboard, etc. Any data flow from person to computer that doesnt need high bandwidth.
//sound and video need high bandwidth.
//This is called many times per second since navigator.getGamepads() only reads gamepad state once and does not start a stream of it (like browsers used to).
//
/*TODO use controller rumble. I got it to work with bluetooth xbox controller in win10 in chrome (first browser I tried) 2021-8-28 with this
gamepad.vibrationActuator.playEffect("dual-rumble", {
	duration: 1000,
	strongMagnitude: 1.0,
	weakMagnitude: 1.0
})
but it kept rumbling, maybe cuz i was in browser debugger at a breakpoint.
*/
var getButtonsJoysticksEtc = function(){
	let gamepads = navigator.getGamepads(); //may contain nulls, such as [null, null, null, null] or [aGamepad, null, null, null].
	let ret = {};
	ret.mouse0_dim0 = mouseYFraction*2-1; //TODO swap y and x order of dims?
	ret.mouse0_dim1 = mouseXFraction*2-1;
	for(let i=0; i<gamepads.length; i++){
		let gamepad = gamepads[i];
		if(gamepad){
			let s = gamepad.id;
			if(!s) s = 'gamepad';
			//s = s.trim().replaceAll(/\s|\(|\)/g,'_');
			s = s.trim().replaceAll(/\(|\)/g,'').replaceAll(/\s/g,'_');
			//let gamepadName = s+'_index'+i;
			let gamepadName = 'gamepad'+i;
			
			//let buttonOrAxisNum = 0;
			for(let a in gamepad.axes){
				//ret[gamepadName+'_'+(buttonOrAxisNum++)] = gamepad.axes[a];
				ret[gamepadName+'_dim'+a] = gamepad.axes[a];
			}
			for(let b in gamepad.buttons){
				ret[gamepadName+'_btn'+b] = gamepad.buttons[b].value; //GamepadButton {pressed: false, touched: false, value: 0}
			}
			if(gamepad.vibrationActuator){
				ret[gamepadName+'_vib0_TODO'] = 0; //TODO see how I used this in comment of getButtonsJoysticksEtc
			}
			
		}
	}
	ret.eventExists = 1; //becomes 0 after event is consumed
	return ret;
};

//https://stackoverflow.com/questions/67865463/disable-tabbing-out-of-textarea
var handleKeyDownToMakeTabsWorkInTextarea = function(e){
	if (e.key == "Tab") {
		e.preventDefault();
		const start = this.selectionStart;
    	const end = this.selectionEnd;
		this.value = this.value.substring(0, start) + "\t" + this.value.substring(end);
		this.selectionStart = this.selectionEnd = start + 1;
	}
};


</script>

</head><body style="background-color:black;color:white">

<b>TODO:</b> Get AvmLambda code (which is a subset of js code) working with copy/pasting code from different times of opening browser tab so some variables overlap and need renaming. Use fn.id() as 256 bit globalId (is already working 2023-5-6) but also allow generated and made up names like Chain2Calls. Get it so I'm using it to store code in various files and copy/pasting them to/from here. Thats a tool I plan to use to get AugmentedBalls working with many tennis balls. ... Instead of V.varname for writing, need to put the varname in the params,
like Pair(Pair(S)(T,'iota'),V.iota) Pair(S)(T) would set V.iota = Pair(S)(T) then use the V.iota.
Add an optional second param of fn (what LambdizeFunc returns).
That solves the problem of vm.n.nams[index]/vm.nam not getting set (TODO use fn.n.nams[index] and get rid of fn.n.nam).
Theres still the problem of how to merge a code string Pair(Pair(S)(T,'iota'),V.iota) into V
when some names overlap such as if theres already a V.iota thats something other than Pair(S)(T).
Do I still want to go with prefixing existing varnames with 'TEMP', while importing code like Pair(Pair(S)(T,'iota'),V.iota),
then merging fn.n.nams which may contain ['TEMPvarx', 'varnamey'] etc?
Or do I want to put the TEMP on the code about to
be evaled "Pair(Pair(S)(T,'iota'),V.iota)" -> Pair(Pair(S)(T,'TEMPiota'),V.TEMPiota)" ?
Its faster to do it that way cuz less usually stuff incoming at a time than all the fns in mem already.
When 2 names collide, what if I want to keep the existing name sometimes and the incoming name (from evaled code) other times?
How should I tell it which? If 1 looks like i wrote it (like Chain2Calls instead of pefup etc) then keep the one i wrote.
Maybe its as simple as prefer those that start with capital letter, and to break ties prefer shorter strings
and to break ties normal string sort order. I could put in an option
to have it pop up for user to choose if both are manually written. More generally, a function of list of names,
and it returns which of those to keep, other than always keep .id()/globalId.
Should I make tostring automatically generate 'TEMP' this.nam (Pair(Pair(S)(T,'TEMPiota'),V.TEMPiota))
so its easier to upload again? Even tho its name is 'iota', it generates it as 'TEMPiota'?



<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>


options.ballFinderFunc = <input type=button onclick="setBallFinderFunc('moveByDirectDeriv');" value="moveByDirectDeriv"></input>
<input type=button onclick="setBallFinderFunc('moveByPotentialEnergyDeriv');" value="moveByPotentialEnergyDeriv"></input>
<input type=button onclick="setBallFinderFunc('evolveByNoncachedPotentialEnergy');" value="evolveByNoncachedPotentialEnergy"></input>
<input type=button onclick="setBallFinderFunc('evolveByCumulativeCacheOfPotentialEnergyFloats');" value="evolveByCumulativeCacheOfPotentialEnergyFloats" disabled></input>
<input type=button onclick="setBallFinderFunc('evolveByLoopSquareOverCacheOfPotentialEnergyFloats');" value="evolveByLoopSquareOverCacheOfPotentialEnergyFloats"></input><label id=ballFinderFuncLabel></label><br>
<br>
options.viewMode = <input type=button onclick="setViewMode('noVideoViewMode');" value="noVideoViewMode" disabled></input>
<input type=button onclick="setViewMode('liveResearchViewModeInOriginalColor');" value="liveResearchViewModeInOriginalColor"></input>
<input type=button onclick="setViewMode('liveResearchViewModeInNormedColor');" value="liveResearchViewModeInNormedColor"></input>
<input type=button onclick="setViewMode('liveResearchViewModeCachedFloats');" value="liveResearchViewModeCachedFloats"></input>
<input type=button onclick="setViewMode('potentialEnergyTestsViewMode');" value="potentialEnergyTestsViewMode" disabled></input>
<input type=button onclick="setViewMode('avmLambdaViewMode');" value="avmLambdaViewMode"></input>
<label id=viewModeLabel></label><br>

canvasOut:<br>
<canvas id="canvasOut" style="transform:matrix(-4,0,0,4,500,200)" width=160 height=120></canvas><br>
<div id="fpsLabel"></div><br>
<textarea id=code rows=7 cols=30 tabIndex="-1" onkeydown="handleKeyDownToMakeTabsWorkInTextarea.call(this, event);"></textarea><br>
<input type=button onclick="let code = document.getElementById('code').value; log.value = eval(code);" value="eval"></input>
<input type=button onclick="document.getElementById('code').value = '';" value="X"></input><br>
<textarea rows=7 cols=30 id=log tabIndex="-1" onkeydown="handleKeyDownToMakeTabsWorkInTextarea.call(this, event);"></textarea><br>
canvasIn:<br>
<canvas id="canvasIn" width=160 height=120 style="transform:scaleX(-1)"></canvas><br>
camera:<br>
<div id="my_camera"></div><br>
<img id=theImg>
<br><br>

<table border=0><tr><td>
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
</td><td>
	<nobr>
		<input type=button onclick="saveToCookie_mainCodeTextarea('code1')" value="save1"></input>
		<input type=button onclick="loadFromCookie_mainCodeTextarea('code1');" value="load1"></input>
	</nobr>&nbsp;&nbsp;&nbsp;
	<nobr>
		<input type=button onclick="saveToCookie_mainCodeTextarea('code2')" value="save2"></input>
		<input type=button onclick="loadFromCookie_mainCodeTextarea('code2');" value="load2"></input>
	</nobr>&nbsp;&nbsp;&nbsp;
	<nobr>
		<input type=button onclick="saveToCookie_mainCodeTextarea('code3')" value="save3"></input>
		<input type=button onclick="loadFromCookie_mainCodeTextarea('code3');" value="load3"></input>
	</nobr>&nbsp;&nbsp;&nbsp;
	<nobr>
		<input type=button onclick="saveToCookie_mainCodeTextarea('code4')" value="save4"></input>
		<input type=button onclick="loadFromCookie_mainCodeTextarea('code4');" value="load4"></input>
	</nobr>&nbsp;&nbsp;&nbsp;
	<nobr>
		<input type=button onclick="saveToCookie_mainCodeTextarea('code5')" value="save5"></input>
		<input type=button onclick="loadFromCookie_mainCodeTextarea('code5');" value="load5"></input>
	</nobr>&nbsp;&nbsp;&nbsp;<br>
	<nobr>
		<input type=button onclick="saveToCookie_mainCodeTextarea(dom('saveLoadByNameTxt6').value);" value="save6*"></input>
		<input type=button onclick="loadFromCookie_mainCodeTextarea(dom('saveLoadByNameTxt6').value);" value="load6*"></input>
		<input id=saveLoadByNameTxt6 type=text size=8 value="code6"></input>
	</nobr>&nbsp;
	<nobr>
		<input type=button onclick="saveToCookie_mainCodeTextarea(dom('saveLoadByNameTxt7').value);" value="save7*"></input>
		<input type=button onclick="loadFromCookie_mainCodeTextarea(dom('saveLoadByNameTxt7').value);" value="load7*"></input>
		<input id=saveLoadByNameTxt7 type=text size=8 value="code7"></input>
	</nobr>&nbsp;
	<nobr>
		<input type=button onclick="saveToCookie_mainCodeTextarea(dom('saveLoadByNameTxt8').value);" value="save8*"></input>
		<input type=button onclick="loadFromCookie_mainCodeTextarea(dom('saveLoadByNameTxt8').value);" value="load8*"></input>
		<input id=saveLoadByNameTxt8 type=text size=8 value="code8"></input>
	</nobr>&nbsp;<br>
	<nobr>
		<input type=button onclick="dom('mainCodeTextarea').value = RootLam+'';" value="get code"></input>
		<input type=button onclick="RootLam = eval(dom('mainCodeTextarea').value);" value="put code"></input>
	</nobr>&nbsp;<br>
	<nobr>
		<input type=button onclick="eval(dom('eval20Txt').value);" value="eval20*"></input>
		<input id=eval20Txt type=text size=60 value="avm.allFns().forEach(fn=>fn.changeToTempIds());"></input>
	</nobr><br>
	<nobr>
		<input type=button onclick="eval(dom('eval21Txt').value);" value="eval21*"></input>
		<input id=eval21Txt type=text size=60 value=""></input>
	</nobr><br>
	<nobr>
		<input type=button onclick="eval(dom('eval22Txt').value);" value="eval22*"></input>
		<input id=eval22Txt type=text size=60 value="avm.allFns().forEach(fn=>fn.undoTempIds());"></input>
	</nobr><br>
	<input type=button onclick="dom('mainCodeTextarea').value = avm.formatAvmCode(dom('mainCodeTextarea').value);" value="format code"></input>
	<br><br>
	<textarea id=mainCodeTextarea rows=50 cols=150 tabIndex="-1" onkeydown="handleKeyDownToMakeTabsWorkInTextarea.call(this, event);"></textarea><br>
	<br><br><br>
	mainDiv is where UINodes go...<br>
	<div id="mainDiv">mainDiv</div>
</td></tr></table>


<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
	<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
	<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
	<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
	<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
	<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
	
<br><br>

<!--div id="mainJstree"></div-->
<br><br><br>
This is fast in android firefox browser, slow in android chrome browser (was earlier version, todo test on android firefox again).<br>
(((Here's the plan to turn it into a real #AugmentedReality game system that thousands of people can use together with their existing phones if they just bring a bunch of tennis balls to a public park or fewer people in their back yard or something, and low lag with desktop cams.)))<br>

<b>TODO:</b> Convert the graphics parts and balls to AvmLambda, and break the big evolution func into smaller parts, and get it working as AvmLambdas while the buttons etc still do the same thing they did before, WITHOUT CHANGING ITS BEHAVIORS even tho the behaviors are right for the wrong reason. Maybe the rest too?: using Put Get BallMove etc (see those AvmLambda vars in this file), rebuild the whole thing, other than the input and output of canvas, webcam, etc... rebuild it in AvmLambda. Use the ability to wrap {} (and maybe []) efficiently in someAvmLambda.d. Wont need Ball.prototype.toAvmLambda() cuz wont be using Ball objects at all. Will use BallMove directly etc.<br>
<b>TODO:</b> The behaviors are right for the wrong reason, and dont work sometimes for that same reason. The potential energy Float32Array per pixel is wrapping around byte range instead of truncating, so the ball is low/valley/black instead of high/hill/white, cuz its too white and it wraps around to black. Switch from wrap to truncate. Switch from 500 totalRGB to 255 in multipl places (like in that *_xxxx*.html) and get the radius finding working again. Display as brighter
<b>TODO:</b> Theres some suffix u can add to an evaled js code to make it appear in the html files list in browser debugger. Have an option to do that, and name the file aLambda.n.nam+'.js' and set lams[name] to it.
<b>TODO:</b> update LICENSE file on github benrayfield augmentedballs to say that AugmentedBalls V1 is MIT licensed but V2 and later is the wikibinator203 license as quoted here.<br>
<b>TODO:</b> Do directedGraphUI first, and if that works out, might not need jstree. use JStree (an opensource from https://www.jstree.com/ but locally) for drag and drop of AvmLambdas. Also save and load in cookies in case write an infinite loop. Have textarea for the selected one to display its .d (data such as string number etc), and a textarea (or same one?) for writing new strings numbers etc.<br>
<b>TODO:</b> testing system for potentialEnergy with each test being a ByteRect and having n Balls (radius y x, ignoring color, use shared ball color for all balls per pic?) that it should find and m balls that it should NOT find, all in same pic. Define it as a loss/energy func per PotenTest. Also MultiPotenTest can be weightedSum of such tests. Define it in a way that params (maybe in options object) can be auto tuned to find balls better and to NOT find balls where they're not, especially not where theres multiple small balls in same big radius or big areas that get matched as a ball cuz potentialEnergy is biased toward bigger radius so it sacrifices some color match and gets stuck on big places theres no ball at all.<br>
<b>TODO:</b> take a few pics of tennis balls, and transform them by normPixelsAllToSameBrightness, and verify loopSquareOverCacheOfPotentialEnergyFloats gives lowest potentialEnergy at radius,x,y where those balls are, and NOT in big areas where they're not (cuz it is biased toward bigger radius, has lower potentialEnergy that way) and NOT at radius,x,y that contains multiple balls.<br>
<b>TODO:</b> If tuning is needed, use a simple neuralnet, maybe 1 RBM layer or a few layers of feedforward or some kind of leastSquares curveFitting. A full convolutional AI model would add lag and is not needed. Just add a small number of params for whatever it takes to make it find yellow circles, including in different places and kinds of tennis balls, some balls older dirtier than others, etc.<br>
<b>TODO:</b> Accurately finds 1 tennis ball in my hand and thrown and bouncing at low lag and accurately in 3d, accurately enough to use it as a joystick (not too jumpy), and with subpixel accuracy by BILINEAR INTERPOLATION on color.<br>
<b>TODO:</b> Replace webcamjs with about 1kB of code, similar to in the chatgptWebcamTest2023_4_26_225pEST.html experiment, cuz webcamjs was made back in the days of Flash and has alot of special cases for when things didnt work back then, and it might be causing webcam not to start (popup not to appear asking for webcam permission) on android chrome or similar problems on other devices. Less code is less chance for bugs. Or look for other smaller newer webcam libraries like maybe https://unpkg.com/webcam-easy@1.0.5/dist/webcam-easy.js https://codepen.io/vyspiansky/pen/xxVVavN (MIT license). TODO choose one. And make sure to sync it the low lag way like webcamjs does, maybe its requestAnimationFrame or something. And u ask it in .init func for a FPS, width, height, etc. TODO log to the dom very detailed about webcam. (((Also: gmentedBalls2.html:1665 Canvas2D: Multiple readback operations using getImageData are faster with the willReadFrequently attribute set to true. See: https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently
updateCanvasObjects @ AugmentedBalls2.html:1665
nextState @ AugmentedBalls2.html:2837
x @ AugmentedBalls2.html:4117
setTimeout (async)
x @ AugmentedBalls2.html:4132
setTimeout (async)
x @ AugmentedBalls2.html:4132
setTimeout (async)
x @ AugmentedBalls2.html:4132
window.onload @ AugmentedBalls2.html:4138
load (async)
(anonymous) @ AugmentedBalls2.html:4033
AugmentedBalls2.html:1666 Canvas2D: Multiple readback operations using getImageData are faster with the willReadFrequently attribute set to true. See: https://html.spec.whatwg.org/multipage/canvas.html#concept-canvas-will-read-frequently
u)))<br>
<b>TODO:</b> After 1 ball is working well, expand to 2 balls and test it when they are partially overlapping in 2d pixels despite they arent overlapping in 3d. The params will likely need adjusting, maybe new params added, and maybe 3d position and velocity estimation or something like that. Whatever it takes to get it working at low lag and high 3d precision.<br>
<b>TODO:</b> Generalize to many tennis balls thrown randomly around floor, curvy hills outside, thrown, bouncing, etc, especially that many balls will be small on screen so need to match them from very few pixels. 3d position and velocity might need to be modelled, or other kinds of math, and if so, a calibration or getting back in sync process might need to be added that user does when moves ways that confuse it. USE THE Ball.blurX and Ball.blurY vars for motion-blur (a convex "rounded line" shape thats a circle if both of those are 0) IF NEEDED. IT WILL ADD DIMENSIONS TO HARMONY-SEARCH SO MAKE IT OPTIONAL (ADD options.evolutionChecksForMotionBlur). IT WILL LIKELY BE NEEDED FOR KNOWING THE RADIUS SINCE RADIUS IS THE THICKNESS OF THE MOTION-BLUR AT THE THINNEST ANGLE.<br>
<b>TODO:</b> Get it working on android firefox again (where earlier version was low enuf lag for gaming on front camera, but still laggy on rear camera) and take it physically outside with multiple other phones seeing it at once, and use a simple server to sync between them where they all see the radius,y,x and their estimated 3d positions etc, and form a 3d coordinate system. Put some simple game objects there. This will be laggy cuz of rear camera hardware, but still could goviral #TennisBallFoom cuz lets ppl play games outside together, and if u have low lag cameras (especially on desktop computer gaming cameras 60FPS cameras etc) it will be low lag in those uses. Put some simple game objects there.<br>
<b>TODO:</b> Hook in CannonJS 3d physics game engine, that the tennis balls are 3d coordinate system for and can throw tennis balls at virtual objects and the balls knock them over, hold 2 balls like a lightsaber, throw fireballs from tennis balls, etc, but no headsets yet if ever, still third-person view of #AugmentedReality or what see when point phone.<br>
<br><br><br>



License of AugmentedBalls2 at time 2023-5-1, for all code changes going forward[[[
<br><br>
AugmentedBalls2 and Wikibinator203 license: The whole turing-complete and hypercomputing space derived from
this universal combinator/lambda or forks of it and other software (prototype by Ben F Rayfield Y2023),
including every lambda of this kind called on a lambda to find/create a lambda or which never halts
(which the author of is defined as the universal combinator since these are tiny shared math objects),
is offered to everyone under opensource GNU AGPL 3 license, plus these extra permissions:<br>
* Classpath/linking exception. Hook it to whatever you want, but within the space (no proprietary lambdas) is AGPL.<br>
* License is instantly unterminated when you start obeying it.<br>
* Free speech absolutism in the evilbit=true namespace in which all possible lambdas are allowed, even viruses etc.
<br><br>
                    GNU AFFERO GENERAL PUBLIC LICENSE
                       Version 3, 19 November 2007
<br><br>
 Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.
 <br><br>
                            Preamble
<br><br>
  The GNU Affero General Public License is a free, copyleft license for
software and other kinds of works, specifically designed to ensure
cooperation with the community in the case of network server software.
<br><br>
  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
our General Public Licenses are intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.
<br><br>
  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.
<br><br>
  Developers that use our General Public Licenses protect your rights
with two steps: (1) assert copyright on the software, and (2) offer
you this License which gives you legal permission to copy, distribute
and/or modify the software.
<br><br>
  A secondary benefit of defending all users' freedom is that
improvements made in alternate versions of the program, if they
receive widespread use, become available for other developers to
incorporate.  Many developers of free software are heartened and
encouraged by the resulting cooperation.  However, in the case of
software used on network servers, this result may fail to come about.
The GNU General Public License permits making a modified version and
letting the public access it on a server without ever releasing its
source code to the public.
<br><br>
  The GNU Affero General Public License is designed specifically to
ensure that, in such cases, the modified source code becomes available
to the community.  It requires the operator of a network server to
provide the source code of the modified version running there to the
users of that server.  Therefore, public use of a modified version, on
a publicly accessible server, gives the public access to the source
code of the modified version.
<br><br>
  An older license, called the Affero General Public License and
published by Affero, was designed to accomplish similar goals.  This is
a different license, not a version of the Affero GPL, but Affero has
released a new version of the Affero GPL which permits relicensing under
this license.
<br><br>
  The precise terms and conditions for copying, distribution and
modification follow.
<br><br>
                       TERMS AND CONDITIONS
<br><br>
  0. Definitions.
<br><br>
  "This License" refers to version 3 of the GNU Affero General Public License.
<br><br>
  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.
<br><br>
  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.
<br><br>
  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.
<br><br>
  A "covered work" means either the unmodified Program or a work based
on the Program.
<br><br>
  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.
<br><br>
  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.
<br><br>
  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.
<br><br>
  1. Source Code.
<br><br>
  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.
<br><br>
  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.
<br><br>
  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.
<br><br>
  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.
<br><br>
  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.
<br><br>
  The Corresponding Source for a work in source code form is that
same work.
<br><br>
  2. Basic Permissions.
<br><br>
  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.
<br><br>
  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.
<br><br>
  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.
<br><br>
  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
<br><br>
  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.
<br><br>
  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.
<br><br>
  4. Conveying Verbatim Copies.
<br><br>
  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.
<br><br>
  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.
<br><br>
  5. Conveying Modified Source Versions.
<br><br>
  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:
<br><br>
    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.
<br><br>
    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".
<br><br>
    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.
<br><br>
    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.
<br><br>
  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.
<br><br>
  6. Conveying Non-Source Forms.
<br><br>
  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:
<br><br>
    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.
<br><br>
    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.
<br><br>
    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.
<br><br>
    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.
<br><br>
    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.
<br><br>
  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.
<br><br>
  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.
<br><br>
  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.
<br><br>
  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).
<br><br>
  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.
<br><br>
  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.
<br><br>
  7. Additional Terms.
<br><br>
  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.
<br><br>
  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.
<br><br>
  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:
<br><br>
    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or
<br><br>
    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or
<br><br>
    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or
<br><br>
    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or
<br><br>
    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or
<br><br>
    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.
<br><br>
  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.
<br><br>
  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.
<br><br>
  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.
<br><br>
  8. Termination.
<br><br>
  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).
<br><br>
  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.
<br><br>
  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.
<br><br>
  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.
<br><br>
  9. Acceptance Not Required for Having Copies.
<br><br>
  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.
<br><br>
  10. Automatic Licensing of Downstream Recipients.
<br><br>
  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.
<br><br>
  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.
<br><br>
  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.
<br><br>
  11. Patents.
<br><br>
  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".
<br><br>
  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.
<br><br>
  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.
<br><br>
  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.
<br><br>
  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.
<br><br>
  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.
<br><br>
  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.
<br><br>
  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.
<br><br>
  12. No Surrender of Others' Freedom.
<br><br>
  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.
<br><br>
  13. Remote Network Interaction; Use with the GNU General Public License.
<br><br>
  Notwithstanding any other provision of this License, if you modify the
Program, your modified version must prominently offer all users
interacting with it remotely through a computer network (if your version
supports such interaction) an opportunity to receive the Corresponding
Source of your version by providing access to the Corresponding Source
from a network server at no charge, through some standard or customary
means of facilitating copying of software.  This Corresponding Source
shall include the Corresponding Source for any work covered by version 3
of the GNU General Public License that is incorporated pursuant to the
following paragraph.
<br><br>
  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the work with which it is combined will remain governed by version
3 of the GNU General Public License.
<br><br>
  14. Revised Versions of this License.
<br><br>
  The Free Software Foundation may publish revised and/or new versions of
the GNU Affero General Public License from time to time.  Such new versions
will be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.
<br><br>
  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU Affero General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU Affero General Public License, you may choose any version ever published
by the Free Software Foundation.
<br><br>
  If the Program specifies that a proxy can decide which future
versions of the GNU Affero General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.
<br><br>
  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.
<br><br>
  15. Disclaimer of Warranty.
<br><br>
  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
<br><br>
  16. Limitation of Liability.
<br><br>
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.
<br><br>
  17. Interpretation of Sections 15 and 16.
  <br><br>
  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.
<br><br>
                     END OF TERMS AND CONDITIONS
<br><br>
            How to Apply These Terms to Your New Programs
<br><br>
  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.
<br><br>
  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.
<br><br>
    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>
<br><br>
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
<br><br>
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.
<br><br>
    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
<br><br>
Also add information on how to contact you by electronic and paper mail.
<br><br>
  If your software can interact with users remotely through a computer
network, you should also make sure that it provides a way for users to
get its source.  For example, if your program is a web application, its
interface could display a "Source" link that leads users to an archive
of the code.  There are many ways you could offer source, and different
solutions will be better for different programs; see section 13 for the
specific requirements.
<br><br>
  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU AGPL, see
<http://www.gnu.org/licenses/>.
<br><br>
                           Classpath/Linking Exception
<br><br>
Linking this library statically or dynamically with other modules is making a 
combined work based on this library. Thus, the terms and conditions of the GNU 
Affero General Public License cover the whole combination.
<br><br>
As a special exception, the copyright holders of this library give you 
permission to link this library with independent modules to produce an 
executable, regardless of the license terms of these independent modules, 
and to copy and distribute the resulting executable under terms of your choice,
provided that you also meet, for each linked independent module, the terms 
and conditions of the license of that module. An independent module is a 
module which is not derived from or based on this library. If you modify 
this library, you may extend this exception to your version of the library, 
but you are not obligated to do so. If you do not wish to do so, delete this 
exception statement from your version.<br>
]]]<br>
<br><br><br><br>

</body></html>